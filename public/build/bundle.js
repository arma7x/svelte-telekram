
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	createCommonjsModule(function (module, exports) {
	  !function (e) {
	    e();
	  }(function () {

	    function e(n) {
	      var t = this.constructor;
	      return this.then(function (e) {
	        return t.resolve(n()).then(function () {
	          return e;
	        });
	      }, function (e) {
	        return t.resolve(n()).then(function () {
	          return t.reject(e);
	        });
	      });
	    }

	    var n = setTimeout;

	    function a(e) {
	      return e && "undefined" != typeof e.length;
	    }

	    function o() {}

	    function i(e) {
	      if (!(this instanceof i)) throw new TypeError("Promises must be constructed via new");
	      if ("function" != typeof e) throw new TypeError("not a function");
	      this._state = 0, this._handled = !1, this._value = undefined, this._deferreds = [], s(e, this);
	    }

	    function r(o, r) {
	      for (; 3 === o._state;) {
	        o = o._value;
	      }

	      0 !== o._state ? (o._handled = !0, i._immediateFn(function () {
	        var e = 1 === o._state ? r.onFulfilled : r.onRejected;

	        if (null !== e) {
	          var n;

	          try {
	            n = e(o._value);
	          } catch (t) {
	            return void u(r.promise, t);
	          }

	          f(r.promise, n);
	        } else (1 === o._state ? f : u)(r.promise, o._value);
	      })) : o._deferreds.push(r);
	    }

	    function f(e, n) {
	      try {
	        if (n === e) throw new TypeError("A promise cannot be resolved with itself.");

	        if (n && ("object" == typeof n || "function" == typeof n)) {
	          var t = n.then;
	          if (n instanceof i) return e._state = 3, e._value = n, void c(e);
	          if ("function" == typeof t) return void s(function o(e, n) {
	            return function () {
	              e.apply(n, arguments);
	            };
	          }(t, n), e);
	        }

	        e._state = 1, e._value = n, c(e);
	      } catch (r) {
	        u(e, r);
	      }
	    }

	    function u(e, n) {
	      e._state = 2, e._value = n, c(e);
	    }

	    function c(e) {
	      2 === e._state && 0 === e._deferreds.length && i._immediateFn(function () {
	        e._handled || i._unhandledRejectionFn(e._value);
	      });

	      for (var n = 0, t = e._deferreds.length; n < t; n++) {
	        r(e, e._deferreds[n]);
	      }

	      e._deferreds = null;
	    }

	    function l(e, n, t) {
	      this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof n ? n : null, this.promise = t;
	    }

	    function s(e, n) {
	      var t = !1;

	      try {
	        e(function (e) {
	          t || (t = !0, f(n, e));
	        }, function (e) {
	          t || (t = !0, u(n, e));
	        });
	      } catch (o) {
	        if (t) return;
	        t = !0, u(n, o);
	      }
	    }

	    i.prototype["catch"] = function (e) {
	      return this.then(null, e);
	    }, i.prototype.then = function (e, n) {
	      var t = new this.constructor(o);
	      return r(this, new l(e, n, t)), t;
	    }, i.prototype["finally"] = e, i.all = function (n) {
	      return new i(function (r, i) {
	        if (!a(n)) return i(new TypeError("Promise.all accepts an array"));
	        var f = Array.prototype.slice.call(n);
	        if (0 === f.length) return r([]);
	        var u = f.length;

	        function c(n, e) {
	          try {
	            if (e && ("object" == typeof e || "function" == typeof e)) {
	              var t = e.then;
	              if ("function" == typeof t) return void t.call(e, function (e) {
	                c(n, e);
	              }, i);
	            }

	            f[n] = e, 0 == --u && r(f);
	          } catch (o) {
	            i(o);
	          }
	        }

	        for (var e = 0; e < f.length; e++) {
	          c(e, f[e]);
	        }
	      });
	    }, i.resolve = function (n) {
	      return n && "object" == typeof n && n.constructor === i ? n : new i(function (e) {
	        e(n);
	      });
	    }, i.reject = function (t) {
	      return new i(function (e, n) {
	        n(t);
	      });
	    }, i.race = function (r) {
	      return new i(function (e, n) {
	        if (!a(r)) return n(new TypeError("Promise.race accepts an array"));

	        for (var t = 0, o = r.length; t < o; t++) {
	          i.resolve(r[t]).then(e, n);
	        }
	      });
	    }, i._immediateFn = "function" == typeof setImmediate ? function (e) {
	      setImmediate(e);
	    } : function (e) {
	      n(e, 0);
	    }, i._unhandledRejectionFn = function (e) {
	      void 0 !== console && console && console.warn("Possible Unhandled Promise Rejection:", e);
	    };

	    var t = function () {
	      if ("undefined" != typeof self) return self;
	      if ("undefined" != typeof window) return window;
	      if ("undefined" != typeof commonjsGlobal) return commonjsGlobal;
	      throw Error("unable to locate global object");
	    }();

	    "function" != typeof t.Promise ? t.Promise = i : t.Promise.prototype["finally"] || (t.Promise.prototype["finally"] = e);
	  });
	});

	if (navigator.mozSetMessageHandler != null) {
	  Object.defineProperty(XMLHttpRequest.prototype, "mozSystem", {
	    value: true
	  });
	}

	if (!String.prototype.replaceAll) {
	  String.prototype.replaceAll = function (str, newStr) {
	    // If a regex pattern
	    if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {
	      return this.replace(str, newStr);
	    } // If a string


	    return this.replace(new RegExp(str, 'g'), newStr);
	  };
	}

	if (!String.prototype.padRight) {
	  String.prototype.padRight = function (n, pad) {
	    var t = this;
	    if (n > this.length) for (var i = 0; i < n - this.length; i++) {
	      t += pad;
	    }
	    return t;
	  };
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

	  if (_i == null) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;

	  var _s, _e;

	  try {
	    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _arrayLikeToArray$2(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}

	function _unsupportedIterableToArray$2(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest();
	}

	function noop() {}

	var identity = x => x;

	function assign(tar, src) {
	  // @ts-ignore
	  for (var k in src) {
	    tar[k] = src[k];
	  }

	  return tar;
	}

	function add_location(element, file, line, column, char) {
	  element.__svelte_meta = {
	    loc: {
	      file,
	      line,
	      column,
	      char
	    }
	  };
	}

	function run(fn) {
	  return fn();
	}

	function blank_object() {
	  return Object.create(null);
	}

	function run_all(fns) {
	  fns.forEach(run);
	}

	function is_function(thing) {
	  return typeof thing === 'function';
	}

	function safe_not_equal(a, b) {
	  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
	}

	var src_url_equal_anchor;

	function src_url_equal(element_src, url) {
	  if (!src_url_equal_anchor) {
	    src_url_equal_anchor = document.createElement('a');
	  }

	  src_url_equal_anchor.href = url;
	  return element_src === src_url_equal_anchor.href;
	}

	function not_equal(a, b) {
	  return a != a ? b == b : a !== b;
	}

	function is_empty(obj) {
	  return Object.keys(obj).length === 0;
	}

	function validate_store(store, name) {
	  if (store != null && typeof store.subscribe !== 'function') {
	    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	  }
	}

	function subscribe(store) {
	  if (store == null) {
	    return noop;
	  }

	  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    callbacks[_key - 1] = arguments[_key];
	  }

	  var unsub = store.subscribe(...callbacks);
	  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	function get_store_value(store) {
	  var value;
	  subscribe(store, _ => value = _)();
	  return value;
	}

	function component_subscribe(component, store, callback) {
	  component.$$.on_destroy.push(subscribe(store, callback));
	}

	function create_slot(definition, ctx, $$scope, fn) {
	  if (definition) {
	    var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	    return definition[0](slot_ctx);
	  }
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
	  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
	  if (definition[2] && fn) {
	    var lets = definition[2](fn(dirty));

	    if ($$scope.dirty === undefined) {
	      return lets;
	    }

	    if (typeof lets === 'object') {
	      var merged = [];
	      var len = Math.max($$scope.dirty.length, lets.length);

	      for (var i = 0; i < len; i += 1) {
	        merged[i] = $$scope.dirty[i] | lets[i];
	      }

	      return merged;
	    }

	    return $$scope.dirty | lets;
	  }

	  return $$scope.dirty;
	}

	function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
	  if (slot_changes) {
	    var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	    slot.p(slot_context, slot_changes);
	  }
	}

	function get_all_dirty_from_scope($$scope) {
	  if ($$scope.ctx.length > 32) {
	    var dirty = [];
	    var length = $$scope.ctx.length / 32;

	    for (var i = 0; i < length; i++) {
	      dirty[i] = -1;
	    }

	    return dirty;
	  }

	  return -1;
	}

	function exclude_internal_props(props) {
	  var result = {};

	  for (var k in props) {
	    if (k[0] !== '$') result[k] = props[k];
	  }

	  return result;
	}

	function compute_rest_props(props, keys) {
	  var rest = {};
	  keys = new Set(keys);

	  for (var k in props) {
	    if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
	  }

	  return rest;
	}

	function compute_slots(slots) {
	  var result = {};

	  for (var key in slots) {
	    result[key] = true;
	  }

	  return result;
	}

	var is_client = typeof window !== 'undefined';
	var now = is_client ? () => window.performance.now() : () => Date.now();
	var raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

	var tasks = new Set();

	function run_tasks(now) {
	  tasks.forEach(task => {
	    if (!task.c(now)) {
	      tasks.delete(task);
	      task.f();
	    }
	  });
	  if (tasks.size !== 0) raf(run_tasks);
	}
	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 */


	function loop(callback) {
	  var task;
	  if (tasks.size === 0) raf(run_tasks);
	  return {
	    promise: new Promise(fulfill => {
	      tasks.add(task = {
	        c: callback,
	        f: fulfill
	      });
	    }),

	    abort() {
	      tasks.delete(task);
	    }

	  };
	} // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

	function append(target, node) {
	  target.appendChild(node);
	}

	function get_root_for_style(node) {
	  if (!node) return document;
	  var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

	  if (root && root.host) {
	    return root;
	  }

	  return node.ownerDocument;
	}

	function append_empty_stylesheet(node) {
	  var style_element = element('style');
	  append_stylesheet(get_root_for_style(node), style_element);
	  return style_element.sheet;
	}

	function append_stylesheet(node, style) {
	  append(node.head || node, style);
	}

	function insert(target, node, anchor) {
	  target.insertBefore(node, anchor || null);
	}

	function detach(node) {
	  node.parentNode.removeChild(node);
	}

	function destroy_each(iterations, detaching) {
	  for (var i = 0; i < iterations.length; i += 1) {
	    if (iterations[i]) iterations[i].d(detaching);
	  }
	}

	function element(name) {
	  return document.createElement(name);
	}

	function text(data) {
	  return document.createTextNode(data);
	}

	function space() {
	  return text(' ');
	}

	function empty() {
	  return text('');
	}

	function listen(node, event, handler, options) {
	  node.addEventListener(event, handler, options);
	  return () => node.removeEventListener(event, handler, options);
	}

	function attr(node, attribute, value) {
	  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}

	function children(element) {
	  return Array.from(element.childNodes);
	}

	function set_style(node, key, value, important) {
	  if (value === null) {
	    node.style.removeProperty(key);
	  } else {
	    node.style.setProperty(key, value, important ? 'important' : '');
	  }
	}

	function toggle_class(element, name, toggle) {
	  element.classList[toggle ? 'add' : 'remove'](name);
	}

	function custom_event(type, detail) {
	  var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var e = document.createEvent('CustomEvent');
	  e.initCustomEvent(type, bubbles, false, detail);
	  return e;
	}

	class HtmlTag {
	  constructor() {
	    this.e = this.n = null;
	  }

	  c(html) {
	    this.h(html);
	  }

	  m(html, target) {
	    var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	    if (!this.e) {
	      this.e = element(target.nodeName);
	      this.t = target;
	      this.c(html);
	    }

	    this.i(anchor);
	  }

	  h(html) {
	    this.e.innerHTML = html;
	    this.n = Array.from(this.e.childNodes);
	  }

	  i(anchor) {
	    for (var i = 0; i < this.n.length; i += 1) {
	      insert(this.t, this.n[i], anchor);
	    }
	  }

	  p(html) {
	    this.d();
	    this.h(html);
	    this.i(this.a);
	  }

	  d() {
	    this.n.forEach(detach);
	  }

	}
	// https://github.com/sveltejs/svelte/issues/3624


	var managed_styles = new Map();
	var active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

	function hash(str) {
	  var hash = 5381;
	  var i = str.length;

	  while (i--) {
	    hash = (hash << 5) - hash ^ str.charCodeAt(i);
	  }

	  return hash >>> 0;
	}

	function create_style_information(doc, node) {
	  var info = {
	    stylesheet: append_empty_stylesheet(node),
	    rules: {}
	  };
	  managed_styles.set(doc, info);
	  return info;
	}

	function create_rule(node, a, b, duration, delay, ease, fn) {
	  var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
	  var step = 16.666 / duration;
	  var keyframes = '{\n';

	  for (var p = 0; p <= 1; p += step) {
	    var t = a + (b - a) * ease(p);
	    keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
	  }

	  var rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
	  var name = `__svelte_${hash(rule)}_${uid}`;
	  var doc = get_root_for_style(node);

	  var _ref = managed_styles.get(doc) || create_style_information(doc, node),
	      stylesheet = _ref.stylesheet,
	      rules = _ref.rules;

	  if (!rules[name]) {
	    rules[name] = true;
	    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
	  }

	  var animation = node.style.animation || '';
	  node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
	  active += 1;
	  return name;
	}

	function delete_rule(node, name) {
	  var previous = (node.style.animation || '').split(', ');
	  var next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
	  : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
	  );
	  var deleted = previous.length - next.length;

	  if (deleted) {
	    node.style.animation = next.join(', ');
	    active -= deleted;
	    if (!active) clear_rules();
	  }
	}

	function clear_rules() {
	  raf(() => {
	    if (active) return;
	    managed_styles.forEach(info => {
	      var stylesheet = info.stylesheet;
	      var i = stylesheet.cssRules.length;

	      while (i--) {
	        stylesheet.deleteRule(i);
	      }

	      info.rules = {};
	    });
	    managed_styles.clear();
	  });
	}

	function create_animation(node, from, fn, params) {
	  if (!from) return noop;
	  var to = node.getBoundingClientRect();
	  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

	  var _fn = fn(node, {
	    from,
	    to
	  }, params),
	      _fn$delay = _fn.delay,
	      delay = _fn$delay === void 0 ? 0 : _fn$delay,
	      _fn$duration = _fn.duration,
	      duration = _fn$duration === void 0 ? 300 : _fn$duration,
	      _fn$easing = _fn.easing,
	      easing = _fn$easing === void 0 ? identity : _fn$easing,
	      _fn$start = _fn.start,
	      start_time = _fn$start === void 0 ? now() + delay : _fn$start,
	      _fn$end = _fn.end,
	      end = _fn$end === void 0 ? start_time + duration : _fn$end,
	      _fn$tick = _fn.tick,
	      tick = _fn$tick === void 0 ? noop : _fn$tick,
	      css = _fn.css;

	  var running = true;
	  var started = false;
	  var name;

	  function start() {
	    if (css) {
	      name = create_rule(node, 0, 1, duration, delay, easing, css);
	    }

	    if (!delay) {
	      started = true;
	    }
	  }

	  function stop() {
	    if (css) delete_rule(node, name);
	    running = false;
	  }

	  loop(now => {
	    if (!started && now >= start_time) {
	      started = true;
	    }

	    if (started && now >= end) {
	      tick(1, 0);
	      stop();
	    }

	    if (!running) {
	      return false;
	    }

	    if (started) {
	      var p = now - start_time;
	      var t = 0 + 1 * easing(p / duration);
	      tick(t, 1 - t);
	    }

	    return true;
	  });
	  start();
	  tick(0, 1);
	  return stop;
	}

	function fix_position(node) {
	  var style = getComputedStyle(node);

	  if (style.position !== 'absolute' && style.position !== 'fixed') {
	    var width = style.width,
	        height = style.height;
	    var a = node.getBoundingClientRect();
	    node.style.position = 'absolute';
	    node.style.width = width;
	    node.style.height = height;
	    add_transform(node, a);
	  }
	}

	function add_transform(node, a) {
	  var b = node.getBoundingClientRect();

	  if (a.left !== b.left || a.top !== b.top) {
	    var style = getComputedStyle(node);
	    var transform = style.transform === 'none' ? '' : style.transform;
	    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
	  }
	}

	var current_component;

	function set_current_component(component) {
	  current_component = component;
	}

	function get_current_component() {
	  if (!current_component) throw new Error('Function called outside component initialization');
	  return current_component;
	}

	function beforeUpdate(fn) {
	  get_current_component().$$.before_update.push(fn);
	}

	function onMount(fn) {
	  get_current_component().$$.on_mount.push(fn);
	}

	function afterUpdate(fn) {
	  get_current_component().$$.after_update.push(fn);
	}

	function onDestroy(fn) {
	  get_current_component().$$.on_destroy.push(fn);
	}

	function setContext(key, context) {
	  get_current_component().$$.context.set(key, context);
	}

	function getContext(key) {
	  return get_current_component().$$.context.get(key);
	}

	var dirty_components = [];
	var binding_callbacks = [];
	var render_callbacks = [];
	var flush_callbacks = [];
	var resolved_promise = Promise.resolve();
	var update_scheduled = false;

	function schedule_update() {
	  if (!update_scheduled) {
	    update_scheduled = true;
	    resolved_promise.then(flush);
	  }
	}

	function tick() {
	  schedule_update();
	  return resolved_promise;
	}

	function add_render_callback(fn) {
	  render_callbacks.push(fn);
	}
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.


	var seen_callbacks = new Set();
	var flushidx = 0; // Do *not* move this inside the flush() function

	function flush() {
	  var saved_component = current_component;

	  do {
	    // first, call beforeUpdate functions
	    // and update components
	    while (flushidx < dirty_components.length) {
	      var component = dirty_components[flushidx];
	      flushidx++;
	      set_current_component(component);
	      update(component.$$);
	    }

	    set_current_component(null);
	    dirty_components.length = 0;
	    flushidx = 0;

	    while (binding_callbacks.length) {
	      binding_callbacks.pop()();
	    } // then, once components are updated, call
	    // afterUpdate functions. This may cause
	    // subsequent updates...


	    for (var i = 0; i < render_callbacks.length; i += 1) {
	      var callback = render_callbacks[i];

	      if (!seen_callbacks.has(callback)) {
	        // ...so guard against infinite loops
	        seen_callbacks.add(callback);
	        callback();
	      }
	    }

	    render_callbacks.length = 0;
	  } while (dirty_components.length);

	  while (flush_callbacks.length) {
	    flush_callbacks.pop()();
	  }

	  update_scheduled = false;
	  seen_callbacks.clear();
	  set_current_component(saved_component);
	}

	function update($$) {
	  if ($$.fragment !== null) {
	    $$.update();
	    run_all($$.before_update);
	    var dirty = $$.dirty;
	    $$.dirty = [-1];
	    $$.fragment && $$.fragment.p($$.ctx, dirty);
	    $$.after_update.forEach(add_render_callback);
	  }
	}

	var promise;

	function wait() {
	  if (!promise) {
	    promise = Promise.resolve();
	    promise.then(() => {
	      promise = null;
	    });
	  }

	  return promise;
	}

	function dispatch(node, direction, kind) {
	  node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	var outroing = new Set();
	var outros;

	function group_outros() {
	  outros = {
	    r: 0,
	    c: [],
	    p: outros // parent group

	  };
	}

	function check_outros() {
	  if (!outros.r) {
	    run_all(outros.c);
	  }

	  outros = outros.p;
	}

	function transition_in(block, local) {
	  if (block && block.i) {
	    outroing.delete(block);
	    block.i(local);
	  }
	}

	function transition_out(block, local, detach, callback) {
	  if (block && block.o) {
	    if (outroing.has(block)) return;
	    outroing.add(block);
	    outros.c.push(() => {
	      outroing.delete(block);

	      if (callback) {
	        if (detach) block.d(1);
	        callback();
	      }
	    });
	    block.o(local);
	  }
	}

	var null_transition = {
	  duration: 0
	};

	function create_in_transition(node, fn, params) {
	  var config = fn(node, params);
	  var running = false;
	  var animation_name;
	  var task;
	  var uid = 0;

	  function cleanup() {
	    if (animation_name) delete_rule(node, animation_name);
	  }

	  function go() {
	    var _ref2 = config || null_transition,
	        _ref2$delay = _ref2.delay,
	        delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
	        _ref2$duration = _ref2.duration,
	        duration = _ref2$duration === void 0 ? 300 : _ref2$duration,
	        _ref2$easing = _ref2.easing,
	        easing = _ref2$easing === void 0 ? identity : _ref2$easing,
	        _ref2$tick = _ref2.tick,
	        tick = _ref2$tick === void 0 ? noop : _ref2$tick,
	        css = _ref2.css;

	    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
	    tick(0, 1);
	    var start_time = now() + delay;
	    var end_time = start_time + duration;
	    if (task) task.abort();
	    running = true;
	    add_render_callback(() => dispatch(node, true, 'start'));
	    task = loop(now => {
	      if (running) {
	        if (now >= end_time) {
	          tick(1, 0);
	          dispatch(node, true, 'end');
	          cleanup();
	          return running = false;
	        }

	        if (now >= start_time) {
	          var t = easing((now - start_time) / duration);
	          tick(t, 1 - t);
	        }
	      }

	      return running;
	    });
	  }

	  var started = false;
	  return {
	    start() {
	      if (started) return;
	      started = true;
	      delete_rule(node);

	      if (is_function(config)) {
	        config = config();
	        wait().then(go);
	      } else {
	        go();
	      }
	    },

	    invalidate() {
	      started = false;
	    },

	    end() {
	      if (running) {
	        cleanup();
	        running = false;
	      }
	    }

	  };
	}

	function create_out_transition(node, fn, params) {
	  var config = fn(node, params);
	  var running = true;
	  var animation_name;
	  var group = outros;
	  group.r += 1;

	  function go() {
	    var _ref3 = config || null_transition,
	        _ref3$delay = _ref3.delay,
	        delay = _ref3$delay === void 0 ? 0 : _ref3$delay,
	        _ref3$duration = _ref3.duration,
	        duration = _ref3$duration === void 0 ? 300 : _ref3$duration,
	        _ref3$easing = _ref3.easing,
	        easing = _ref3$easing === void 0 ? identity : _ref3$easing,
	        _ref3$tick = _ref3.tick,
	        tick = _ref3$tick === void 0 ? noop : _ref3$tick,
	        css = _ref3.css;

	    if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
	    var start_time = now() + delay;
	    var end_time = start_time + duration;
	    add_render_callback(() => dispatch(node, false, 'start'));
	    loop(now => {
	      if (running) {
	        if (now >= end_time) {
	          tick(0, 1);
	          dispatch(node, false, 'end');

	          if (! --group.r) {
	            // this will result in `end()` being called,
	            // so we don't need to clean up here
	            run_all(group.c);
	          }

	          return false;
	        }

	        if (now >= start_time) {
	          var t = easing((now - start_time) / duration);
	          tick(1 - t, t);
	        }
	      }

	      return running;
	    });
	  }

	  if (is_function(config)) {
	    wait().then(() => {
	      // @ts-ignore
	      config = config();
	      go();
	    });
	  } else {
	    go();
	  }

	  return {
	    end(reset) {
	      if (reset && config.tick) {
	        config.tick(1, 0);
	      }

	      if (running) {
	        if (animation_name) delete_rule(node, animation_name);
	        running = false;
	      }
	    }

	  };
	}

	var globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

	function outro_and_destroy_block(block, lookup) {
	  transition_out(block, 1, 1, () => {
	    lookup.delete(block.key);
	  });
	}

	function fix_and_outro_and_destroy_block(block, lookup) {
	  block.f();
	  outro_and_destroy_block(block, lookup);
	}

	function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
	  var o = old_blocks.length;
	  var n = list.length;
	  var i = o;
	  var old_indexes = {};

	  while (i--) {
	    old_indexes[old_blocks[i].key] = i;
	  }

	  var new_blocks = [];
	  var new_lookup = new Map();
	  var deltas = new Map();
	  i = n;

	  while (i--) {
	    var child_ctx = get_context(ctx, list, i);
	    var key = get_key(child_ctx);
	    var block = lookup.get(key);

	    if (!block) {
	      block = create_each_block(key, child_ctx);
	      block.c();
	    } else if (dynamic) {
	      block.p(child_ctx, dirty);
	    }

	    new_lookup.set(key, new_blocks[i] = block);
	    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	  }

	  var will_move = new Set();
	  var did_move = new Set();

	  function insert(block) {
	    transition_in(block, 1);
	    block.m(node, next);
	    lookup.set(block.key, block);
	    next = block.first;
	    n--;
	  }

	  while (o && n) {
	    var new_block = new_blocks[n - 1];
	    var old_block = old_blocks[o - 1];
	    var new_key = new_block.key;
	    var old_key = old_block.key;

	    if (new_block === old_block) {
	      // do nothing
	      next = new_block.first;
	      o--;
	      n--;
	    } else if (!new_lookup.has(old_key)) {
	      // remove old block
	      destroy(old_block, lookup);
	      o--;
	    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
	      insert(new_block);
	    } else if (did_move.has(old_key)) {
	      o--;
	    } else if (deltas.get(new_key) > deltas.get(old_key)) {
	      did_move.add(new_key);
	      insert(new_block);
	    } else {
	      will_move.add(old_key);
	      o--;
	    }
	  }

	  while (o--) {
	    var _old_block = old_blocks[o];
	    if (!new_lookup.has(_old_block.key)) destroy(_old_block, lookup);
	  }

	  while (n) {
	    insert(new_blocks[n - 1]);
	  }

	  return new_blocks;
	}

	function validate_each_keys(ctx, list, get_context, get_key) {
	  var keys = new Set();

	  for (var i = 0; i < list.length; i++) {
	    var key = get_key(get_context(ctx, list, i));

	    if (keys.has(key)) {
	      throw new Error('Cannot have duplicate keys in a keyed each');
	    }

	    keys.add(key);
	  }
	}

	function get_spread_update(levels, updates) {
	  var update = {};
	  var to_null_out = {};
	  var accounted_for = {
	    $$scope: 1
	  };
	  var i = levels.length;

	  while (i--) {
	    var o = levels[i];
	    var n = updates[i];

	    if (n) {
	      for (var key in o) {
	        if (!(key in n)) to_null_out[key] = 1;
	      }

	      for (var _key3 in n) {
	        if (!accounted_for[_key3]) {
	          update[_key3] = n[_key3];
	          accounted_for[_key3] = 1;
	        }
	      }

	      levels[i] = n;
	    } else {
	      for (var _key4 in o) {
	        accounted_for[_key4] = 1;
	      }
	    }
	  }

	  for (var _key5 in to_null_out) {
	    if (!(_key5 in update)) update[_key5] = undefined;
	  }

	  return update;
	}

	function get_spread_object(spread_props) {
	  return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	} // source: https://html.spec.whatwg.org/multipage/indices.html

	function create_component(block) {
	  block && block.c();
	}

	function mount_component(component, target, anchor, customElement) {
	  var _component$$$ = component.$$,
	      fragment = _component$$$.fragment,
	      on_mount = _component$$$.on_mount,
	      on_destroy = _component$$$.on_destroy,
	      after_update = _component$$$.after_update;
	  fragment && fragment.m(target, anchor);

	  if (!customElement) {
	    // onMount happens before the initial afterUpdate
	    add_render_callback(() => {
	      var new_on_destroy = on_mount.map(run).filter(is_function);

	      if (on_destroy) {
	        on_destroy.push(...new_on_destroy);
	      } else {
	        // Edge case - component was destroyed immediately,
	        // most likely as a result of a binding initialising
	        run_all(new_on_destroy);
	      }

	      component.$$.on_mount = [];
	    });
	  }

	  after_update.forEach(add_render_callback);
	}

	function destroy_component(component, detaching) {
	  var $$ = component.$$;

	  if ($$.fragment !== null) {
	    run_all($$.on_destroy);
	    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
	    // preserve final state?)

	    $$.on_destroy = $$.fragment = null;
	    $$.ctx = [];
	  }
	}

	function make_dirty(component, i) {
	  if (component.$$.dirty[0] === -1) {
	    dirty_components.push(component);
	    schedule_update();
	    component.$$.dirty.fill(0);
	  }

	  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
	}

	function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
	  var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
	  var parent_component = current_component;
	  set_current_component(component);
	  var $$ = component.$$ = {
	    fragment: null,
	    ctx: null,
	    // state
	    props,
	    update: noop,
	    not_equal,
	    bound: blank_object(),
	    // lifecycle
	    on_mount: [],
	    on_destroy: [],
	    on_disconnect: [],
	    before_update: [],
	    after_update: [],
	    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	    // everything else
	    callbacks: blank_object(),
	    dirty,
	    skip_bound: false,
	    root: options.target || parent_component.$$.root
	  };
	  append_styles && append_styles($$.root);
	  var ready = false;
	  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
	    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;

	    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
	      if (ready) make_dirty(component, i);
	    }

	    return ret;
	  }) : [];
	  $$.update();
	  ready = true;
	  run_all($$.before_update); // `false` as a special case of no DOM component

	  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

	  if (options.target) {
	    if (options.hydrate) {
	      var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

	      $$.fragment && $$.fragment.l(nodes);
	      nodes.forEach(detach);
	    } else {
	      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	      $$.fragment && $$.fragment.c();
	    }

	    if (options.intro) transition_in(component.$$.fragment);
	    mount_component(component, options.target, options.anchor, options.customElement);
	    flush();
	  }

	  set_current_component(parent_component);
	}
	/**
	 * Base class for Svelte components. Used when dev=false.
	 */


	class SvelteComponent {
	  $destroy() {
	    destroy_component(this, 1);
	    this.$destroy = noop;
	  }

	  $on(type, callback) {
	    var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
	    callbacks.push(callback);
	    return () => {
	      var index = callbacks.indexOf(callback);
	      if (index !== -1) callbacks.splice(index, 1);
	    };
	  }

	  $set($$props) {
	    if (this.$$set && !is_empty($$props)) {
	      this.$$.skip_bound = true;
	      this.$$set($$props);
	      this.$$.skip_bound = false;
	    }
	  }

	}

	function dispatch_dev(type, detail) {
	  document.dispatchEvent(custom_event(type, Object.assign({
	    version: '3.46.4'
	  }, detail), true));
	}

	function append_dev(target, node) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node
	  });
	  append(target, node);
	}

	function insert_dev(target, node, anchor) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node,
	    anchor
	  });
	  insert(target, node, anchor);
	}

	function detach_dev(node) {
	  dispatch_dev('SvelteDOMRemove', {
	    node
	  });
	  detach(node);
	}

	function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
	  var modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	  if (has_prevent_default) modifiers.push('preventDefault');
	  if (has_stop_propagation) modifiers.push('stopPropagation');
	  dispatch_dev('SvelteDOMAddEventListener', {
	    node,
	    event,
	    handler,
	    modifiers
	  });
	  var dispose = listen(node, event, handler, options);
	  return () => {
	    dispatch_dev('SvelteDOMRemoveEventListener', {
	      node,
	      event,
	      handler,
	      modifiers
	    });
	    dispose();
	  };
	}

	function attr_dev(node, attribute, value) {
	  attr(node, attribute, value);
	  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
	    node,
	    attribute
	  });else dispatch_dev('SvelteDOMSetAttribute', {
	    node,
	    attribute,
	    value
	  });
	}

	function prop_dev(node, property, value) {
	  node[property] = value;
	  dispatch_dev('SvelteDOMSetProperty', {
	    node,
	    property,
	    value
	  });
	}

	function set_data_dev(text, data) {
	  data = '' + data;
	  if (text.wholeText === data) return;
	  dispatch_dev('SvelteDOMSetData', {
	    node: text,
	    data
	  });
	  text.data = data;
	}

	function validate_each_argument(arg) {
	  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
	    var msg = '{#each} only iterates over array-like objects.';

	    if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
	      msg += ' You can use a spread to convert this iterable into an array.';
	    }

	    throw new Error(msg);
	  }
	}

	function validate_slots(name, slot, keys) {
	  for (var _i4 = 0, _Object$keys = Object.keys(slot); _i4 < _Object$keys.length; _i4++) {
	    var slot_key = _Object$keys[_i4];

	    if (!~keys.indexOf(slot_key)) {
	      console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
	    }
	  }
	}
	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 */


	class SvelteComponentDev extends SvelteComponent {
	  constructor(options) {
	    if (!options || !options.target && !options.$$inline) {
	      throw new Error("'target' is a required option");
	    }

	    super();
	  }

	  $destroy() {
	    super.$destroy();

	    this.$destroy = () => {
	      console.warn('Component was already destroyed'); // eslint-disable-line no-console
	    };
	  }

	  $capture_state() {}

	  $inject_state() {}

	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	/*
	 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
	 *
	 * https://github.com/reach/router/blob/master/LICENSE
	 */
	var isUndefined = value => typeof value === "undefined";
	var isFunction = value => typeof value === "function";
	var isNumber = value => typeof value === "number";
	function createCounter() {
	  var i = 0;
	  /**
	   * Returns an id and increments the internal state
	   * @returns {number}
	   */

	  return () => i++;
	}
	/**
	 * Create a globally unique id
	 *
	 * @returns {string} An id
	 */

	function createGlobalId() {
	  return Math.random().toString(36).substring(2);
	}
	var isSSR = typeof window === "undefined";
	function addListener(target, type, handler) {
	  target.addEventListener(type, handler);
	  return () => target.removeEventListener(type, handler);
	}

	function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

	function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var subscriber_queue = [];
	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 * @param value initial value
	 * @param {StartStopNotifier}start start and stop notifications for subscriptions
	 */

	function readable(value, start) {
	  return {
	    subscribe: writable(value, start).subscribe
	  };
	}
	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 * @param {*=}value initial value
	 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
	 */


	function writable(value) {
	  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	  var stop;
	  var subscribers = new Set();

	  function set(new_value) {
	    if (safe_not_equal(value, new_value)) {
	      value = new_value;

	      if (stop) {
	        // store is ready
	        var run_queue = !subscriber_queue.length;

	        var _iterator = _createForOfIteratorHelper$1(subscribers),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var subscriber = _step.value;
	            subscriber[1]();
	            subscriber_queue.push(subscriber, value);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }

	        if (run_queue) {
	          for (var i = 0; i < subscriber_queue.length; i += 2) {
	            subscriber_queue[i][0](subscriber_queue[i + 1]);
	          }

	          subscriber_queue.length = 0;
	        }
	      }
	    }
	  }

	  function update(fn) {
	    set(fn(value));
	  }

	  function subscribe(run) {
	    var invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	    var subscriber = [run, invalidate];
	    subscribers.add(subscriber);

	    if (subscribers.size === 1) {
	      stop = start(set) || noop;
	    }

	    run(value);
	    return () => {
	      subscribers.delete(subscriber);

	      if (subscribers.size === 0) {
	        stop();
	        stop = null;
	      }
	    };
	  }

	  return {
	    set,
	    update,
	    subscribe
	  };
	}

	function derived(stores, fn, initial_value) {
	  var single = !Array.isArray(stores);
	  var stores_array = single ? [stores] : stores;
	  var auto = fn.length < 2;
	  return readable(initial_value, set => {
	    var inited = false;
	    var values = [];
	    var pending = 0;
	    var cleanup = noop;

	    var sync = () => {
	      if (pending) {
	        return;
	      }

	      cleanup();
	      var result = fn(single ? values[0] : values, set);

	      if (auto) {
	        set(result);
	      } else {
	        cleanup = is_function(result) ? result : noop;
	      }
	    };

	    var unsubscribers = stores_array.map((store, i) => subscribe(store, value => {
	      values[i] = value;
	      pending &= ~(1 << i);

	      if (inited) {
	        sync();
	      }
	    }, () => {
	      pending |= 1 << i;
	    }));
	    inited = true;
	    sync();
	    return function stop() {
	      run_all(unsubscribers);
	      cleanup();
	    };
	  });
	}

	/*
	 * Adapted from https://github.com/EmilTholin/svelte-routing
	 *
	 * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE
	 */
	var createKey = ctxName => `@@svnav-ctx__${ctxName}`; // Use strings instead of objects, so different versions of
	// svelte-navigator can potentially still work together


	var LOCATION = createKey("LOCATION");
	var ROUTER = createKey("ROUTER");
	var ROUTE = createKey("ROUTE");
	var ROUTE_PARAMS = createKey("ROUTE_PARAMS");
	var FOCUS_ELEM = createKey("FOCUS_ELEM");

	var paramRegex = /^:(.+)/;
	/**
	 * Check if `string` starts with `search`
	 * @param {string} string
	 * @param {string} search
	 * @return {boolean}
	 */

	var startsWith = (string, search) => string.substr(0, search.length) === search;
	/**
	 * Check if `segment` is a root segment
	 * @param {string} segment
	 * @return {boolean}
	 */

	var isRootSegment = segment => segment === "";
	/**
	 * Check if `segment` is a dynamic segment
	 * @param {string} segment
	 * @return {boolean}
	 */

	var isDynamic = segment => paramRegex.test(segment);
	/**
	 * Check if `segment` is a splat
	 * @param {string} segment
	 * @return {boolean}
	 */

	var isSplat = segment => segment[0] === "*";
	/**
	 * Strip potention splat and splatname of the end of a path
	 * @param {string} str
	 * @return {string}
	 */

	var stripSplat = str => str.replace(/\*.*$/, "");
	/**
	 * Strip `str` of potential start and end `/`
	 * @param {string} str
	 * @return {string}
	 */

	var stripSlashes = str => str.replace(/(^\/+|\/+$)/g, "");
	/**
	 * Split up the URI into segments delimited by `/`
	 * @param {string} uri
	 * @return {string[]}
	 */

	function segmentize(uri) {
	  var filterFalsy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var segments = stripSlashes(uri).split("/");
	  return filterFalsy ? segments.filter(Boolean) : segments;
	}
	/**
	 * Add the query to the pathname if a query is given
	 * @param {string} pathname
	 * @param {string} [query]
	 * @return {string}
	 */

	var addQuery = (pathname, query) => pathname + (query ? `?${query}` : "");
	/**
	 * Normalizes a basepath
	 *
	 * @param {string} path
	 * @returns {string}
	 *
	 * @example
	 * normalizePath("base/path/") // -> "/base/path"
	 */

	var normalizePath = path => `/${stripSlashes(path)}`;
	/**
	 * Joins and normalizes multiple path fragments
	 *
	 * @param {...string} pathFragments
	 * @returns {string}
	 */

	function join$1() {
	  var joinFragment = fragment => segmentize(fragment, true).join("/");

	  for (var _len = arguments.length, pathFragments = new Array(_len), _key = 0; _key < _len; _key++) {
	    pathFragments[_key] = arguments[_key];
	  }

	  var joinedSegments = pathFragments.map(joinFragment).join("/");
	  return normalizePath(joinedSegments);
	}

	// by using `originId || <fallback>`

	var LINK_ID = 1;
	var ROUTE_ID = 2;
	var ROUTER_ID = 3;
	var USE_FOCUS_ID = 4;
	var USE_LOCATION_ID = 5;
	var USE_MATCH_ID = 6;
	var USE_NAVIGATE_ID = 7;
	var USE_PARAMS_ID = 8;
	var USE_RESOLVABLE_ID = 9;
	var USE_RESOLVE_ID = 10;
	var NAVIGATE_ID = 11;
	var labels = {
	  [LINK_ID]: "Link",
	  [ROUTE_ID]: "Route",
	  [ROUTER_ID]: "Router",
	  [USE_FOCUS_ID]: "useFocus",
	  [USE_LOCATION_ID]: "useLocation",
	  [USE_MATCH_ID]: "useMatch",
	  [USE_NAVIGATE_ID]: "useNavigate",
	  [USE_PARAMS_ID]: "useParams",
	  [USE_RESOLVABLE_ID]: "useResolvable",
	  [USE_RESOLVE_ID]: "useResolve",
	  [NAVIGATE_ID]: "navigate"
	};
	var createLabel = labelId => labels[labelId];
	function createIdentifier(labelId, props) {
	  var attr;

	  if (labelId === ROUTE_ID) {
	    attr = props.path ? `path="${props.path}"` : "default";
	  } else if (labelId === LINK_ID) {
	    attr = `to="${props.to}"`;
	  } else if (labelId === ROUTER_ID) {
	    attr = `basepath="${props.basepath || ""}"`;
	  }

	  return `<${createLabel(labelId)} ${attr || ""} />`;
	}
	function createMessage(labelId, message, props, originId) {
	  var origin = props && createIdentifier(originId || labelId, props);
	  var originMsg = origin ? `\n\nOccurred in: ${origin}` : "";
	  var label = createLabel(labelId);
	  var msg = isFunction(message) ? message(label) : message;
	  return `<${label}> ${msg}${originMsg}`;
	}
	var createMessageHandler = handler => function () {
	  return handler(createMessage(...arguments));
	};
	var fail = createMessageHandler(message => {
	  throw new Error(message);
	}); // eslint-disable-next-line no-console

	var warn = createMessageHandler(console.warn);

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var SEGMENT_POINTS = 4;
	var STATIC_POINTS = 3;
	var DYNAMIC_POINTS = 2;
	var SPLAT_PENALTY = 1;
	var ROOT_POINTS = 1;
	/**
	 * Score a route depending on how its individual segments look
	 * @param {object} route
	 * @param {number} index
	 * @return {object}
	 */

	function rankRoute(route, index) {
	  var score = route.default ? 0 : segmentize(route.fullPath).reduce((acc, segment) => {
	    var nextScore = acc;
	    nextScore += SEGMENT_POINTS;

	    if (isRootSegment(segment)) {
	      nextScore += ROOT_POINTS;
	    } else if (isDynamic(segment)) {
	      nextScore += DYNAMIC_POINTS;
	    } else if (isSplat(segment)) {
	      nextScore -= SEGMENT_POINTS + SPLAT_PENALTY;
	    } else {
	      nextScore += STATIC_POINTS;
	    }

	    return nextScore;
	  }, 0);
	  return {
	    route,
	    score,
	    index
	  };
	}
	/**
	 * Give a score to all routes and sort them on that
	 * @param {object[]} routes
	 * @return {object[]}
	 */

	function rankRoutes(routes) {
	  return routes.map(rankRoute) // If two routes have the exact same score, we go by index instead
	  .sort((a, b) => {
	    if (a.score < b.score) {
	      return 1;
	    }

	    if (a.score > b.score) {
	      return -1;
	    }

	    return a.index - b.index;
	  });
	}
	/**
	 * Ranks and picks the best route to match. Each segment gets the highest
	 * amount of points, then the type of segment gets an additional amount of
	 * points where
	 *
	 *  static > dynamic > splat > root
	 *
	 * This way we don't have to worry about the order of our routes, let the
	 * computers do it.
	 *
	 * A route looks like this
	 *
	 *  { fullPath, default, value }
	 *
	 * And a returned match looks like:
	 *
	 *  { route, params, uri }
	 *
	 * @param {object[]} routes
	 * @param {string} uri
	 * @return {?object}
	 */

	function pick(routes, uri) {
	  var bestMatch;
	  var defaultMatch;

	  var _uri$split = uri.split("?"),
	      _uri$split2 = _slicedToArray(_uri$split, 1),
	      uriPathname = _uri$split2[0];

	  var uriSegments = segmentize(uriPathname);
	  var isRootUri = uriSegments[0] === "";
	  var ranked = rankRoutes(routes);

	  var _loop = function _loop(i, l) {
	    var route = ranked[i].route;
	    var missed = false;
	    var params = {}; // eslint-disable-next-line no-shadow

	    var createMatch = uri => _objectSpread$3(_objectSpread$3({}, route), {}, {
	      params,
	      uri
	    });

	    if (route.default) {
	      defaultMatch = createMatch(uri);
	      return "continue";
	    }

	    var routeSegments = segmentize(route.fullPath);
	    var max = Math.max(uriSegments.length, routeSegments.length);
	    var index = 0;

	    for (; index < max; index++) {
	      var routeSegment = routeSegments[index];
	      var uriSegment = uriSegments[index];

	      if (!isUndefined(routeSegment) && isSplat(routeSegment)) {
	        // Hit a splat, just grab the rest, and return a match
	        // uri:   /files/documents/work
	        // route: /files/* or /files/*splatname
	        var splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);
	        params[splatName] = uriSegments.slice(index).map(decodeURIComponent).join("/");
	        break;
	      }

	      if (isUndefined(uriSegment)) {
	        // URI is shorter than the route, no match
	        // uri:   /users
	        // route: /users/:userId
	        missed = true;
	        break;
	      }

	      var dynamicMatch = paramRegex.exec(routeSegment);

	      if (dynamicMatch && !isRootUri) {
	        var value = decodeURIComponent(uriSegment);
	        params[dynamicMatch[1]] = value;
	      } else if (routeSegment !== uriSegment) {
	        // Current segments don't match, not dynamic, not splat, so no match
	        // uri:   /users/123/settings
	        // route: /users/:id/profile
	        missed = true;
	        break;
	      }
	    }

	    if (!missed) {
	      bestMatch = createMatch(join$1(...uriSegments.slice(0, index)));
	      return "break";
	    }
	  };

	  for (var i = 0, l = ranked.length; i < l; i++) {
	    var _ret = _loop(i);

	    if (_ret === "continue") continue;
	    if (_ret === "break") break;
	  }

	  return bestMatch || defaultMatch || null;
	}
	/**
	 * Check if the `route.fullPath` matches the `uri`.
	 * @param {Object} route
	 * @param {string} uri
	 * @return {?object}
	 */

	function match(route, uri) {
	  return pick([route], uri);
	}
	/**
	 * Resolve URIs as though every path is a directory, no files. Relative URIs
	 * in the browser can feel awkward because not only can you be "in a directory",
	 * you can be "at a file", too. For example:
	 *
	 *  browserSpecResolve('foo', '/bar/') => /bar/foo
	 *  browserSpecResolve('foo', '/bar') => /foo
	 *
	 * But on the command line of a file system, it's not as complicated. You can't
	 * `cd` from a file, only directories. This way, links have to know less about
	 * their current path. To go deeper you can do this:
	 *
	 *  <Link to="deeper"/>
	 *  // instead of
	 *  <Link to=`{${props.uri}/deeper}`/>
	 *
	 * Just like `cd`, if you want to go deeper from the command line, you do this:
	 *
	 *  cd deeper
	 *  # not
	 *  cd $(pwd)/deeper
	 *
	 * By treating every path as a directory, linking to relative paths should
	 * require less contextual information and (fingers crossed) be more intuitive.
	 * @param {string} to
	 * @param {string} base
	 * @return {string}
	 */

	function resolve$1(to, base) {
	  // /foo/bar, /baz/qux => /foo/bar
	  if (startsWith(to, "/")) {
	    return to;
	  }

	  var _to$split = to.split("?"),
	      _to$split2 = _slicedToArray(_to$split, 2),
	      toPathname = _to$split2[0],
	      toQuery = _to$split2[1];

	  var _base$split = base.split("?"),
	      _base$split2 = _slicedToArray(_base$split, 1),
	      basePathname = _base$split2[0];

	  var toSegments = segmentize(toPathname);
	  var baseSegments = segmentize(basePathname); // ?a=b, /users?b=c => /users?a=b

	  if (toSegments[0] === "") {
	    return addQuery(basePathname, toQuery);
	  } // profile, /users/789 => /users/789/profile


	  if (!startsWith(toSegments[0], ".")) {
	    var pathname = baseSegments.concat(toSegments).join("/");
	    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
	  } // ./       , /users/123 => /users/123
	  // ../      , /users/123 => /users
	  // ../..    , /users/123 => /
	  // ../../one, /a/b/c/d   => /a/b/one
	  // .././one , /a/b/c/d   => /a/b/c/one


	  var allSegments = baseSegments.concat(toSegments);
	  var segments = [];
	  allSegments.forEach(segment => {
	    if (segment === "..") {
	      segments.pop();
	    } else if (segment !== ".") {
	      segments.push(segment);
	    }
	  });
	  return addQuery(`/${segments.join("/")}`, toQuery);
	}
	/**
	 * Normalizes a location for consumption by `Route` children and the `Router`.
	 * It removes the apps basepath from the pathname
	 * and sets default values for `search` and `hash` properties.
	 *
	 * @param {Object} location The current global location supplied by the history component
	 * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)
	 *
	 * @returns The normalized location
	 */

	function normalizeLocation(location, basepath) {
	  var pathname = location.pathname,
	      _location$hash = location.hash,
	      hash = _location$hash === void 0 ? "" : _location$hash,
	      _location$search = location.search,
	      search = _location$search === void 0 ? "" : _location$search,
	      state = location.state;
	  var baseSegments = segmentize(basepath, true);
	  var pathSegments = segmentize(pathname, true);

	  while (baseSegments.length) {
	    if (baseSegments[0] !== pathSegments[0]) {
	      fail(ROUTER_ID, `Invalid state: All locations must begin with the basepath "${basepath}", found "${pathname}"`);
	    }

	    baseSegments.shift();
	    pathSegments.shift();
	  }

	  return {
	    pathname: join$1(...pathSegments),
	    hash,
	    search,
	    state
	  };
	}

	var normalizeUrlFragment = frag => frag.length === 1 ? "" : frag;
	/**
	 * Creates a location object from an url.
	 * It is used to create a location from the url prop used in SSR
	 *
	 * @param {string} url The url string (e.g. "/path/to/somewhere")
	 *
	 * @returns {{ pathname: string; search: string; hash: string }} The location
	 */


	function createLocation(url) {
	  var searchIndex = url.indexOf("?");
	  var hashIndex = url.indexOf("#");
	  var hasSearchIndex = searchIndex !== -1;
	  var hasHashIndex = hashIndex !== -1;
	  var hash = hasHashIndex ? normalizeUrlFragment(url.substr(hashIndex)) : "";
	  var pathnameAndSearch = hasHashIndex ? url.substr(0, hashIndex) : url;
	  var search = hasSearchIndex ? normalizeUrlFragment(pathnameAndSearch.substr(searchIndex)) : "";
	  var pathname = hasSearchIndex ? pathnameAndSearch.substr(0, searchIndex) : pathnameAndSearch;
	  return {
	    pathname,
	    search,
	    hash
	  };
	}
	/**
	 * Resolves a link relative to the parent Route and the Routers basepath.
	 *
	 * @param {string} path The given path, that will be resolved
	 * @param {string} routeBase The current Routes base path
	 * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory
	 * @returns {string} The resolved path
	 *
	 * @example
	 * resolveLink("relative", "/routeBase", "/") // -> "/routeBase/relative"
	 * resolveLink("/absolute", "/routeBase", "/") // -> "/absolute"
	 * resolveLink("relative", "/routeBase", "/base") // -> "/base/routeBase/relative"
	 * resolveLink("/absolute", "/routeBase", "/base") // -> "/base/absolute"
	 */

	function resolveLink(path, routeBase, appBase) {
	  return join$1(appBase, resolve$1(path, routeBase));
	}
	/**
	 * Get the uri for a Route, by matching it against the current location.
	 *
	 * @param {string} routePath The Routes resolved path
	 * @param {string} pathname The current locations pathname
	 */

	function extractBaseUri(routePath, pathname) {
	  var fullPath = normalizePath(stripSplat(routePath));
	  var baseSegments = segmentize(fullPath, true);
	  var pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);
	  var routeMatch = match({
	    fullPath
	  }, join$1(...pathSegments));
	  return routeMatch && routeMatch.uri;
	}

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var POP = "POP";
	var PUSH = "PUSH";
	var REPLACE = "REPLACE";

	function getLocation(source) {
	  return _objectSpread$2(_objectSpread$2({}, source.location), {}, {
	    pathname: encodeURI(decodeURI(source.location.pathname)),
	    state: source.history.state,
	    _key: source.history.state && source.history.state._key || "initial"
	  });
	}

	function createHistory(source) {
	  var listeners = [];
	  var location = getLocation(source);
	  var action = POP;

	  var notifyListeners = function notifyListeners() {
	    var listenerFns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : listeners;
	    return listenerFns.forEach(listener => listener({
	      location,
	      action
	    }));
	  };

	  return {
	    get location() {
	      return location;
	    },

	    listen(listener) {
	      listeners.push(listener);

	      var popstateListener = () => {
	        location = getLocation(source);
	        action = POP;
	        notifyListeners([listener]);
	      }; // Call listener when it is registered


	      notifyListeners([listener]);
	      var unlisten = addListener(source, "popstate", popstateListener);
	      return () => {
	        unlisten();
	        listeners = listeners.filter(fn => fn !== listener);
	      };
	    },

	    /**
	     * Navigate to a new absolute route.
	     *
	     * @param {string|number} to The path to navigate to.
	     *
	     * If `to` is a number we will navigate to the stack entry index + `to`
	     * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
	     * @param {Object} options
	     * @param {*} [options.state] The state will be accessible through `location.state`
	     * @param {boolean} [options.replace=false] Replace the current entry in the history
	     * stack, instead of pushing on a new one
	     */
	    navigate(to, options) {
	      var _ref = options || {},
	          _ref$state = _ref.state,
	          state = _ref$state === void 0 ? {} : _ref$state,
	          _ref$replace = _ref.replace,
	          replace = _ref$replace === void 0 ? false : _ref$replace;

	      action = replace ? REPLACE : PUSH;

	      if (isNumber(to)) {
	        if (options) {
	          warn(NAVIGATE_ID, "Navigation options (state or replace) are not supported, " + "when passing a number as the first argument to navigate. " + "They are ignored.");
	        }

	        action = POP;
	        source.history.go(to);
	      } else {
	        var keyedState = _objectSpread$2(_objectSpread$2({}, state), {}, {
	          _key: createGlobalId()
	        }); // try...catch iOS Safari limits to 100 pushState calls


	        try {
	          source.history[replace ? "replaceState" : "pushState"](keyedState, "", to);
	        } catch (e) {
	          source.location[replace ? "replace" : "assign"](to);
	        }
	      }

	      location = getLocation(source);
	      notifyListeners();
	    }

	  };
	}

	function createStackFrame(state, uri) {
	  return _objectSpread$2(_objectSpread$2({}, createLocation(uri)), {}, {
	    state
	  });
	} // Stores history entries in memory for testing or other platforms like Native


	function createMemorySource() {
	  var initialPathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
	  var index = 0;
	  var stack = [createStackFrame(null, initialPathname)];
	  return {
	    // This is just for testing...
	    get entries() {
	      return stack;
	    },

	    get location() {
	      return stack[index];
	    },

	    addEventListener() {},

	    removeEventListener() {},

	    history: {
	      get state() {
	        return stack[index].state;
	      },

	      pushState(state, title, uri) {
	        index++; // Throw away anything in the stack with an index greater than the current index.
	        // This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.
	        // If we call `go(+n)` the stack entries with an index greater than the current index can
	        // be reused.
	        // However, if we navigate to a path, instead of a number, we want to create a new branch
	        // of navigation.

	        stack = stack.slice(0, index);
	        stack.push(createStackFrame(state, uri));
	      },

	      replaceState(state, title, uri) {
	        stack[index] = createStackFrame(state, uri);
	      },

	      go(to) {
	        var newIndex = index + to;

	        if (newIndex < 0 || newIndex > stack.length - 1) {
	          return;
	        }

	        index = newIndex;
	      }

	    }
	  };
	} // Global history uses window.history as the source if available,
	// otherwise a memory history


	var canUseDOM = !!(!isSSR && window.document && window.document.createElement); // Use memory history in iframes (for example in Svelte REPL)

	var isEmbeddedPage = !isSSR && window.location.origin === "null";
	var globalHistory = createHistory(canUseDOM && !isEmbeddedPage ? window : createMemorySource());
	var navigate = globalHistory.navigate;

	// not update, when we mutate it.
	// Also, we need a single global reference, because taking focus needs to
	// work globally, even if we have multiple top level routers
	// eslint-disable-next-line import/no-mutable-exports

	var focusCandidate = null; // eslint-disable-next-line import/no-mutable-exports

	var initialNavigation = true;
	/**
	 * Check if RouterA is above RouterB in the document
	 * @param {number} routerIdA The first Routers id
	 * @param {number} routerIdB The second Routers id
	 */

	function isAbove(routerIdA, routerIdB) {
	  var routerMarkers = document.querySelectorAll("[data-svnav-router]");

	  for (var i = 0; i < routerMarkers.length; i++) {
	    var node = routerMarkers[i];
	    var currentId = Number(node.dataset.svnavRouter);
	    if (currentId === routerIdA) return true;
	    if (currentId === routerIdB) return false;
	  }

	  return false;
	}
	/**
	 * Check if a Route candidate is the best choice to move focus to,
	 * and store the best match.
	 * @param {{
	     level: number;
	     routerId: number;
	     route: {
	       id: number;
	       focusElement: import("svelte/store").Readable<Promise<Element>|null>;
	     }
	   }} item A Route candidate, that updated and is visible after a navigation
	 */


	function pushFocusCandidate(item) {
	  if ( // Best candidate if it's the only candidate...
	  !focusCandidate || // Route is nested deeper, than previous candidate
	  // -> Route change was triggered in the deepest affected
	  // Route, so that's were focus should move to
	  item.level > focusCandidate.level || // If the level is identical, we want to focus the first Route in the document,
	  // so we pick the first Router lookin from page top to page bottom.
	  item.level === focusCandidate.level && isAbove(item.routerId, focusCandidate.routerId)) {
	    focusCandidate = item;
	  }
	}
	/**
	 * Reset the focus candidate.
	 */

	function clearFocusCandidate() {
	  focusCandidate = null;
	}
	function initialNavigationOccurred() {
	  initialNavigation = false;
	}
	/*
	 * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts
	 *
	 * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE
	 */

	function focus(elem) {
	  if (!elem) return false;
	  var TABINDEX = "tabindex";

	  try {
	    if (!elem.hasAttribute(TABINDEX)) {
	      elem.setAttribute(TABINDEX, "-1");
	      var unlisten; // We remove tabindex after blur to avoid weird browser behavior
	      // where a mouse click can activate elements with tabindex="-1".

	      var blurListener = () => {
	        elem.removeAttribute(TABINDEX);
	        unlisten();
	      };

	      unlisten = addListener(elem, "blur", blurListener);
	    }

	    elem.focus();
	    return document.activeElement === elem;
	  } catch (e) {
	    // Apparently trying to focus a disabled element in IE can throw.
	    // See https://stackoverflow.com/a/1600194/2476884
	    return false;
	  }
	}
	function isEndMarker(elem, id) {
	  return Number(elem.dataset.svnavRouteEnd) === id;
	}
	function isHeading(elem) {
	  return /^H[1-6]$/i.test(elem.tagName);
	}

	function query(selector) {
	  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
	  return parent.querySelector(selector);
	}

	function queryHeading(id) {
	  var marker = query(`[data-svnav-route-start="${id}"]`);
	  var current = marker.nextElementSibling;

	  while (!isEndMarker(current, id)) {
	    if (isHeading(current)) {
	      return current;
	    }

	    var heading = query("h1,h2,h3,h4,h5,h6", current);

	    if (heading) {
	      return heading;
	    }

	    current = current.nextElementSibling;
	  }

	  return null;
	}
	function handleFocus(route) {
	  Promise.resolve(get_store_value(route.focusElement)).then(elem => {
	    var focusElement = elem || queryHeading(route.id);

	    if (!focusElement) {
	      warn(ROUTER_ID, "Could not find an element to focus. " + "You should always render a header for accessibility reasons, " + 'or set a custom focus element via the "useFocus" hook. ' + "If you don't want this Route or Router to manage focus, " + 'pass "primary={false}" to it.', route, ROUTE_ID);
	    }

	    var headingFocused = focus(focusElement);
	    if (headingFocused) return;
	    focus(document.documentElement);
	  });
	}
	var createTriggerFocus = (a11yConfig, announcementText, location) => (manageFocus, announceNavigation) => // Wait until the dom is updated, so we can look for headings
	tick().then(() => {
	  if (!focusCandidate || initialNavigation) {
	    initialNavigationOccurred();
	    return;
	  }

	  if (manageFocus) {
	    handleFocus(focusCandidate.route);
	  }

	  if (a11yConfig.announcements && announceNavigation) {
	    var _focusCandidate$route = focusCandidate.route,
	        path = _focusCandidate$route.path,
	        fullPath = _focusCandidate$route.fullPath,
	        meta = _focusCandidate$route.meta,
	        params = _focusCandidate$route.params,
	        uri = _focusCandidate$route.uri;
	    var announcementMessage = a11yConfig.createAnnouncement({
	      path,
	      fullPath,
	      meta,
	      params,
	      uri
	    }, get_store_value(location));
	    Promise.resolve(announcementMessage).then(message => {
	      announcementText.set(message);
	    });
	  }

	  clearFocusCandidate();
	});
	var visuallyHiddenStyle = "position:fixed;" + "top:-1px;" + "left:0;" + "width:1px;" + "height:1px;" + "padding:0;" + "overflow:hidden;" + "clip:rect(0,0,0,0);" + "white-space:nowrap;" + "border:0;";

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var file$1h = "node_modules/svelte-navigator/src/Router.svelte"; // (195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}

	function create_if_block$j(ctx) {
	  var div;
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      t = text(
	      /*$announcementText*/
	      ctx[0]);
	      attr_dev(div, "role", "status");
	      attr_dev(div, "aria-atomic", "true");
	      attr_dev(div, "aria-live", "polite");
	      attr_dev(div, "style", visuallyHiddenStyle);
	      add_location(div, file$1h, 195, 1, 5906);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*$announcementText*/
	      1) set_data_dev(t,
	      /*$announcementText*/
	      ctx[0]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$j.name,
	    type: "if",
	    source: "(195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1h(ctx) {
	  var div;
	  var t0;
	  var t1;
	  var if_block_anchor;
	  var current;
	  var default_slot_template =
	  /*#slots*/
	  ctx[20].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[19], null);
	  var if_block =
	  /*isTopLevelRouter*/
	  ctx[2] &&
	  /*manageFocus*/
	  ctx[4] &&
	  /*a11yConfig*/
	  ctx[1].announcements && create_if_block$j(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      t0 = space();
	      if (default_slot) default_slot.c();
	      t1 = space();
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	      set_style(div, "display", "none");
	      attr_dev(div, "aria-hidden", "true");
	      attr_dev(div, "data-svnav-router",
	      /*routerId*/
	      ctx[3]);
	      add_location(div, file$1h, 190, 0, 5750);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      insert_dev(target, t0, anchor);

	      if (default_slot) {
	        default_slot.m(target, anchor);
	      }

	      insert_dev(target, t1, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty[0] &
	        /*$$scope*/
	        524288)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[19], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[19]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[19], dirty, null), null);
	        }
	      }

	      if (
	      /*isTopLevelRouter*/
	      ctx[2] &&
	      /*manageFocus*/
	      ctx[4] &&
	      /*a11yConfig*/
	      ctx[1].announcements) if_block.p(ctx, dirty);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (detaching) detach_dev(t0);
	      if (default_slot) default_slot.d(detaching);
	      if (detaching) detach_dev(t1);
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach_dev(if_block_anchor);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1h.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var createId$1 = createCounter();
	var defaultBasepath = "/";

	function instance$1h($$self, $$props, $$invalidate) {
	  var $location;
	  var $activeRoute;
	  var $prevLocation;
	  var $routes;
	  var $announcementText;
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  validate_slots('Router', slots, ['default']);
	  var _$$props$basepath = $$props.basepath,
	      basepath = _$$props$basepath === void 0 ? defaultBasepath : _$$props$basepath;
	  var _$$props$url = $$props.url,
	      url = _$$props$url === void 0 ? null : _$$props$url;
	  var _$$props$history = $$props.history,
	      history = _$$props$history === void 0 ? globalHistory : _$$props$history;
	  var _$$props$primary = $$props.primary,
	      primary = _$$props$primary === void 0 ? true : _$$props$primary;
	  var _$$props$a11y = $$props.a11y,
	      a11y = _$$props$a11y === void 0 ? {} : _$$props$a11y;

	  var a11yConfig = _objectSpread$1({
	    createAnnouncement: route => `Navigated to ${route.uri}`,
	    announcements: true
	  }, a11y); // Remember the initial `basepath`, so we can fire a warning
	  // when the user changes it later


	  var initialBasepath = basepath;
	  var normalizedBasepath = normalizePath(basepath);
	  var locationContext = getContext(LOCATION);
	  var routerContext = getContext(ROUTER);
	  var isTopLevelRouter = !locationContext;
	  var routerId = createId$1();
	  var manageFocus = primary && !(routerContext && !routerContext.manageFocus);
	  var announcementText = writable("");
	  validate_store(announcementText, 'announcementText');
	  component_subscribe($$self, announcementText, value => $$invalidate(0, $announcementText = value));
	  var routes = writable([]);
	  validate_store(routes, 'routes');
	  component_subscribe($$self, routes, value => $$invalidate(18, $routes = value));
	  var activeRoute = writable(null);
	  validate_store(activeRoute, 'activeRoute');
	  component_subscribe($$self, activeRoute, value => $$invalidate(16, $activeRoute = value)); // Used in SSR to synchronously set that a Route is active.

	  var hasActiveRoute = false; // Nesting level of router.
	  // We will need this to identify sibling routers, when moving
	  // focus on navigation, so we can focus the first possible router

	  var level = isTopLevelRouter ? 0 : routerContext.level + 1; // If we're running an SSR we force the location to the `url` prop

	  var getInitialLocation = () => normalizeLocation(isSSR ? createLocation(url) : history.location, normalizedBasepath);

	  var location = isTopLevelRouter ? writable(getInitialLocation()) : locationContext;
	  validate_store(location, 'location');
	  component_subscribe($$self, location, value => $$invalidate(15, $location = value));
	  var prevLocation = writable($location);
	  validate_store(prevLocation, 'prevLocation');
	  component_subscribe($$self, prevLocation, value => $$invalidate(17, $prevLocation = value));
	  var triggerFocus = createTriggerFocus(a11yConfig, announcementText, location);

	  var createRouteFilter = routeId => routeList => routeList.filter(routeItem => routeItem.id !== routeId);

	  function registerRoute(route) {
	    if (isSSR) {
	      // In SSR we should set the activeRoute immediately if it is a match.
	      // If there are more Routes being registered after a match is found,
	      // we just skip them.
	      if (hasActiveRoute) {
	        return;
	      }

	      var matchingRoute = match(route, $location.pathname);

	      if (matchingRoute) {
	        hasActiveRoute = true; // Return the match in SSR mode, so the matched Route can use it immediatly.
	        // Waiting for activeRoute to update does not work, because it updates
	        // after the Route is initialized

	        return matchingRoute; // eslint-disable-line consistent-return
	      }
	    } else {
	      routes.update(prevRoutes => {
	        // Remove an old version of the updated route,
	        // before pushing the new version
	        var nextRoutes = createRouteFilter(route.id)(prevRoutes);
	        nextRoutes.push(route);
	        return nextRoutes;
	      });
	    }
	  }

	  function unregisterRoute(routeId) {
	    routes.update(createRouteFilter(routeId));
	  }

	  if (!isTopLevelRouter && basepath !== defaultBasepath) {
	    warn(ROUTER_ID, 'Only top-level Routers can have a "basepath" prop. It is ignored.', {
	      basepath
	    });
	  }

	  if (isTopLevelRouter) {
	    // The topmost Router in the tree is responsible for updating
	    // the location store and supplying it through context.
	    onMount(() => {
	      var unlisten = history.listen(changedHistory => {
	        var normalizedLocation = normalizeLocation(changedHistory.location, normalizedBasepath);
	        prevLocation.set($location);
	        location.set(normalizedLocation);
	      });
	      return unlisten;
	    });
	    setContext(LOCATION, location);
	  }

	  setContext(ROUTER, {
	    activeRoute,
	    registerRoute,
	    unregisterRoute,
	    manageFocus,
	    level,
	    id: routerId,
	    history: isTopLevelRouter ? history : routerContext.history,
	    basepath: isTopLevelRouter ? normalizedBasepath : routerContext.basepath
	  });
	  var writable_props = ['basepath', 'url', 'history', 'primary', 'a11y'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('basepath' in $$props) $$invalidate(10, basepath = $$props.basepath);
	    if ('url' in $$props) $$invalidate(11, url = $$props.url);
	    if ('history' in $$props) $$invalidate(12, history = $$props.history);
	    if ('primary' in $$props) $$invalidate(13, primary = $$props.primary);
	    if ('a11y' in $$props) $$invalidate(14, a11y = $$props.a11y);
	    if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
	  };

	  $$self.$capture_state = () => ({
	    createCounter,
	    createId: createId$1,
	    getContext,
	    setContext,
	    onMount,
	    writable,
	    LOCATION,
	    ROUTER,
	    globalHistory,
	    normalizePath,
	    pick,
	    match,
	    normalizeLocation,
	    createLocation,
	    isSSR,
	    warn,
	    ROUTER_ID,
	    pushFocusCandidate,
	    visuallyHiddenStyle,
	    createTriggerFocus,
	    defaultBasepath,
	    basepath,
	    url,
	    history,
	    primary,
	    a11y,
	    a11yConfig,
	    initialBasepath,
	    normalizedBasepath,
	    locationContext,
	    routerContext,
	    isTopLevelRouter,
	    routerId,
	    manageFocus,
	    announcementText,
	    routes,
	    activeRoute,
	    hasActiveRoute,
	    level,
	    getInitialLocation,
	    location,
	    prevLocation,
	    triggerFocus,
	    createRouteFilter,
	    registerRoute,
	    unregisterRoute,
	    $location,
	    $activeRoute,
	    $prevLocation,
	    $routes,
	    $announcementText
	  });

	  $$self.$inject_state = $$props => {
	    if ('basepath' in $$props) $$invalidate(10, basepath = $$props.basepath);
	    if ('url' in $$props) $$invalidate(11, url = $$props.url);
	    if ('history' in $$props) $$invalidate(12, history = $$props.history);
	    if ('primary' in $$props) $$invalidate(13, primary = $$props.primary);
	    if ('a11y' in $$props) $$invalidate(14, a11y = $$props.a11y);
	    if ('hasActiveRoute' in $$props) hasActiveRoute = $$props.hasActiveRoute;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] &
	    /*basepath*/
	    1024) {
	      if (basepath !== initialBasepath) {
	        warn(ROUTER_ID, 'You cannot change the "basepath" prop. It is ignored.');
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*$routes, $location*/
	    294912) {
	      // This reactive statement will be run when the Router is created
	      // when there are no Routes and then again the following tick, so it
	      // will not find an active Route in SSR and in the browser it will only
	      // pick an active Route after all Routes have been registered.
	      {
	        var bestMatch = pick($routes, $location.pathname);
	        activeRoute.set(bestMatch);
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*$location, $prevLocation*/
	    163840) {
	      // Manage focus and announce navigation to screen reader users
	      {
	        if (isTopLevelRouter) {
	          var hasHash = !!$location.hash; // When a hash is present in the url, we skip focus management, because
	          // focusing a different element will prevent in-page jumps (See #3)

	          var shouldManageFocus = !hasHash && manageFocus; // We don't want to make an announcement, when the hash changes,
	          // but the active route stays the same

	          var announceNavigation = !hasHash || $location.pathname !== $prevLocation.pathname;
	          triggerFocus(shouldManageFocus, announceNavigation);
	        }
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*$activeRoute*/
	    65536) {
	      // Queue matched Route, so top level Router can decide which Route to focus.
	      // Non primary Routers should just be ignored
	      if (manageFocus && $activeRoute && $activeRoute.primary) {
	        pushFocusCandidate({
	          level,
	          routerId,
	          route: $activeRoute
	        });
	      }
	    }
	  };

	  return [$announcementText, a11yConfig, isTopLevelRouter, routerId, manageFocus, announcementText, routes, activeRoute, location, prevLocation, basepath, url, history, primary, a11y, $location, $activeRoute, $prevLocation, $routes, $$scope, slots];
	}

	class Router extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
	      basepath: 10,
	      url: 11,
	      history: 12,
	      primary: 13,
	      a11y: 14
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Router",
	      options,
	      id: create_fragment$1h.name
	    });
	  }

	  get basepath() {
	    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set basepath(value) {
	    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get url() {
	    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set url(value) {
	    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get history() {
	    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set history(value) {
	    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get primary() {
	    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set primary(value) {
	    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get a11y() {
	    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set a11y(value) {
	    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Router$1 = Router;

	/**
	 * Check if a component or hook have been created outside of a
	 * context providing component
	 * @param {number} componentId
	 * @param {*} props
	 * @param {string?} ctxKey
	 * @param {number?} ctxProviderId
	 */

	function usePreflightCheck(componentId, props) {
	  var ctxKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ROUTER;
	  var ctxProviderId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ROUTER_ID;
	  var ctx = getContext(ctxKey);

	  if (!ctx) {
	    fail(componentId, label => `You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`, props);
	  }
	}

	var toReadonly = ctx => {
	  var _getContext = getContext(ctx),
	      subscribe = _getContext.subscribe;

	  return {
	    subscribe
	  };
	};
	/**
	 * Access the current location via a readable store.
	 * @returns {import("svelte/store").Readable<{
	    pathname: string;
	    search: string;
	    hash: string;
	    state: {};
	  }>}
	 *
	 * @example
	  ```html
	  <script>
	    import { useLocation } from "svelte-navigator";

	    const location = useLocation();

	    $: console.log($location);
	    // {
	    //   pathname: "/blog",
	    //   search: "?id=123",
	    //   hash: "#comments",
	    //   state: {}
	    // }
	  </script>
	  ```
	 */


	function useLocation() {
	  usePreflightCheck(USE_LOCATION_ID);
	  return toReadonly(LOCATION);
	}
	/**
	 * @typedef {{
	    path: string;
	    fullPath: string;
	    uri: string;
	    params: {};
	  }} RouteMatch
	 */

	/**
	 * @typedef {import("svelte/store").Readable<RouteMatch|null>} RouteMatchStore
	 */

	/**
	 * Access the history of top level Router.
	 */

	function useHistory() {
	  var _getContext2 = getContext(ROUTER),
	      history = _getContext2.history;

	  return history;
	}
	/**
	 * Access the base of the parent Route.
	 */

	function useRouteBase() {
	  var route = getContext(ROUTE);
	  return route ? derived(route, _route => _route.base) : writable("/");
	}
	/**
	 * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.
	 * It is used under the hood in `Link` and `useNavigate`.
	 * You can use it to manually resolve links, when using the `link` or `links` actions.
	 *
	 * @returns {(path: string) => string}
	 *
	 * @example
	  ```html
	  <script>
	    import { link, useResolve } from "svelte-navigator";

	    const resolve = useResolve();
	    // `resolvedLink` will be resolved relative to its parent Route
	    // and the Routers `basepath`
	    const resolvedLink = resolve("relativePath");
	  </script>

	  <a href={resolvedLink} use:link>Relative link</a>
	  ```
	 */

	function useResolve() {
	  usePreflightCheck(USE_RESOLVE_ID);
	  var routeBase = useRouteBase();

	  var _getContext3 = getContext(ROUTER),
	      appBase = _getContext3.basepath;
	  /**
	   * Resolves the path relative to the current route and basepath.
	   *
	   * @param {string} path The path to resolve
	   * @returns {string} The resolved path
	   */


	  var resolve = path => resolveLink(path, get_store_value(routeBase), appBase);

	  return resolve;
	}
	/**
	 * A hook, that returns a context-aware version of `navigate`.
	 * It will automatically resolve the given link relative to the current Route.
	 * It will also resolve a link against the `basepath` of the Router.
	 *
	 * @example
	  ```html
	  <!-- App.svelte -->
	  <script>
	    import { link, Route } from "svelte-navigator";
	    import RouteComponent from "./RouteComponent.svelte";
	  </script>

	  <Router>
	    <Route path="route1">
	      <RouteComponent />
	    </Route>
	    <!-- ... -->
	  </Router>

	  <!-- RouteComponent.svelte -->
	  <script>
	    import { useNavigate } from "svelte-navigator";

	    const navigate = useNavigate();
	  </script>

	  <button on:click="{() => navigate('relativePath')}">
	    go to /route1/relativePath
	  </button>
	  <button on:click="{() => navigate('/absolutePath')}">
	    go to /absolutePath
	  </button>
	  ```
	  *
	  * @example
	  ```html
	  <!-- App.svelte -->
	  <script>
	    import { link, Route } from "svelte-navigator";
	    import RouteComponent from "./RouteComponent.svelte";
	  </script>

	  <Router basepath="/base">
	    <Route path="route1">
	      <RouteComponent />
	    </Route>
	    <!-- ... -->
	  </Router>

	  <!-- RouteComponent.svelte -->
	  <script>
	    import { useNavigate } from "svelte-navigator";

	    const navigate = useNavigate();
	  </script>

	  <button on:click="{() => navigate('relativePath')}">
	    go to /base/route1/relativePath
	  </button>
	  <button on:click="{() => navigate('/absolutePath')}">
	    go to /base/absolutePath
	  </button>
	  ```
	 */

	function useNavigate() {
	  usePreflightCheck(USE_NAVIGATE_ID);
	  var resolve = useResolve();

	  var _useHistory = useHistory(),
	      navigate = _useHistory.navigate;
	  /**
	   * Navigate to a new route.
	   * Resolves the link relative to the current route and basepath.
	   *
	   * @param {string|number} to The path to navigate to.
	   *
	   * If `to` is a number we will navigate to the stack entry index + `to`
	   * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
	   * @param {Object} options
	   * @param {*} [options.state]
	   * @param {boolean} [options.replace=false]
	   */


	  var navigateRelative = (to, options) => {
	    // If to is a number, we navigate to the target stack entry via `history.go`.
	    // Otherwise resolve the link
	    var target = isNumber(to) ? to : resolve(to);
	    return navigate(target, options);
	  };

	  return navigateRelative;
	}

	var file$1g = "node_modules/svelte-navigator/src/Route.svelte";

	var get_default_slot_changes = dirty => ({
	  params: dirty &
	  /*$params*/
	  16,
	  location: dirty &
	  /*$location*/
	  8
	});

	var get_default_slot_context = ctx => ({
	  params: isSSR ? get_store_value(
	  /*params*/
	  ctx[9]) :
	  /*$params*/
	  ctx[4],
	  location:
	  /*$location*/
	  ctx[3],
	  navigate:
	  /*navigate*/
	  ctx[10]
	}); // (97:0) {#if isActive}


	function create_if_block$i(ctx) {
	  var router;
	  var current;
	  router = new Router$1({
	    props: {
	      primary:
	      /*primary*/
	      ctx[1],
	      $$slots: {
	        default: [create_default_slot$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(router.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(router, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var router_changes = {};
	      if (dirty &
	      /*primary*/
	      2) router_changes.primary =
	      /*primary*/
	      ctx[1];

	      if (dirty &
	      /*$$scope, component, $location, $params, $$restProps*/
	      264217) {
	        router_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      router.$set(router_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(router.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(router.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(router, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$i.name,
	    type: "if",
	    source: "(97:0) {#if isActive}",
	    ctx
	  });
	  return block;
	} // (113:2) {:else}


	function create_else_block$7(ctx) {
	  var current;
	  var default_slot_template =
	  /*#slots*/
	  ctx[17].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[18], get_default_slot_context);
	  var block = {
	    c: function create() {
	      if (default_slot) default_slot.c();
	    },
	    m: function mount(target, anchor) {
	      if (default_slot) {
	        default_slot.m(target, anchor);
	      }

	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty &
	        /*$$scope, $params, $location*/
	        262168)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[18], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[18]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[18], dirty, get_default_slot_changes), get_default_slot_context);
	        }
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (default_slot) default_slot.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$7.name,
	    type: "else",
	    source: "(113:2) {:else}",
	    ctx
	  });
	  return block;
	} // (105:2) {#if component !== null}


	function create_if_block_1$b(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_instance_spread_levels = [{
	    location:
	    /*$location*/
	    ctx[3]
	  }, {
	    navigate:
	    /*navigate*/
	    ctx[10]
	  }, isSSR ? get_store_value(
	  /*params*/
	  ctx[9]) :
	  /*$params*/
	  ctx[4],
	  /*$$restProps*/
	  ctx[11]];
	  var switch_value =
	  /*component*/
	  ctx[0];

	  function switch_props(ctx) {
	    var switch_instance_props = {};

	    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
	      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
	    }

	    return {
	      props: switch_instance_props,
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props());
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = dirty &
	      /*$location, navigate, isSSR, get, params, $params, $$restProps*/
	      3608 ? get_spread_update(switch_instance_spread_levels, [dirty &
	      /*$location*/
	      8 && {
	        location:
	        /*$location*/
	        ctx[3]
	      }, dirty &
	      /*navigate*/
	      1024 && {
	        navigate:
	        /*navigate*/
	        ctx[10]
	      }, dirty &
	      /*isSSR, get, params, $params*/
	      528 && get_spread_object(isSSR ? get_store_value(
	      /*params*/
	      ctx[9]) :
	      /*$params*/
	      ctx[4]), dirty &
	      /*$$restProps*/
	      2048 && get_spread_object(
	      /*$$restProps*/
	      ctx[11])]) : {};

	      if (switch_value !== (switch_value =
	      /*component*/
	      ctx[0])) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$b.name,
	    type: "if",
	    source: "(105:2) {#if component !== null}",
	    ctx
	  });
	  return block;
	} // (98:1) <Router {primary}>


	function create_default_slot$1(ctx) {
	  var current_block_type_index;
	  var if_block;
	  var if_block_anchor;
	  var current;
	  var if_block_creators = [create_if_block_1$b, create_else_block$7];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*component*/
	    ctx[0] !== null) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  var block = {
	    c: function create() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach_dev(if_block_anchor);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot$1.name,
	    type: "slot",
	    source: "(98:1) <Router {primary}>",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1g(ctx) {
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var if_block =
	  /*isActive*/
	  ctx[2] && create_if_block$i(ctx);
	  var block = {
	    c: function create() {
	      div0 = element("div");
	      t0 = space();
	      if (if_block) if_block.c();
	      t1 = space();
	      div1 = element("div");
	      set_style(div0, "display", "none");
	      attr_dev(div0, "aria-hidden", "true");
	      attr_dev(div0, "data-svnav-route-start",
	      /*id*/
	      ctx[5]);
	      add_location(div0, file$1g, 95, 0, 2622);
	      set_style(div1, "display", "none");
	      attr_dev(div1, "aria-hidden", "true");
	      attr_dev(div1, "data-svnav-route-end",
	      /*id*/
	      ctx[5]);
	      add_location(div1, file$1g, 121, 0, 3295);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div0, anchor);
	      insert_dev(target, t0, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, t1, anchor);
	      insert_dev(target, div1, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*isActive*/
	      ctx[2]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty &
	          /*isActive*/
	          4) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$i(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t1.parentNode, t1);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div0);
	      if (detaching) detach_dev(t0);
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach_dev(t1);
	      if (detaching) detach_dev(div1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1g.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var createId = createCounter();

	function instance$1g($$self, $$props, $$invalidate) {
	  var isActive;
	  var omit_props_names = ["path", "component", "meta", "primary"];
	  var $$restProps = compute_rest_props($$props, omit_props_names);
	  var $activeRoute;
	  var $location;
	  var $parentBase;
	  var $params;
	  var _$$props = $$props,
	      _$$props$$$slots = _$$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = _$$props.$$scope;
	  validate_slots('Route', slots, ['default']);
	  var _$$props2 = $$props,
	      _$$props2$path = _$$props2.path,
	      path = _$$props2$path === void 0 ? "" : _$$props2$path;
	  var _$$props3 = $$props,
	      _$$props3$component = _$$props3.component,
	      component = _$$props3$component === void 0 ? null : _$$props3$component;
	  var _$$props4 = $$props,
	      _$$props4$meta = _$$props4.meta,
	      meta = _$$props4$meta === void 0 ? {} : _$$props4$meta;
	  var _$$props5 = $$props,
	      _$$props5$primary = _$$props5.primary,
	      primary = _$$props5$primary === void 0 ? true : _$$props5$primary;
	  usePreflightCheck(ROUTE_ID, $$props);
	  var id = createId();

	  var _getContext = getContext(ROUTER),
	      registerRoute = _getContext.registerRoute,
	      unregisterRoute = _getContext.unregisterRoute,
	      activeRoute = _getContext.activeRoute;

	  validate_store(activeRoute, 'activeRoute');
	  component_subscribe($$self, activeRoute, value => $$invalidate(15, $activeRoute = value));
	  var parentBase = useRouteBase();
	  validate_store(parentBase, 'parentBase');
	  component_subscribe($$self, parentBase, value => $$invalidate(16, $parentBase = value));
	  var location = useLocation();
	  validate_store(location, 'location');
	  component_subscribe($$self, location, value => $$invalidate(3, $location = value));
	  var focusElement = writable(null); // In SSR we cannot wait for $activeRoute to update,
	  // so we use the match returned from `registerRoute` instead

	  var ssrMatch;
	  var route = writable();
	  var params = writable({});
	  validate_store(params, 'params');
	  component_subscribe($$self, params, value => $$invalidate(4, $params = value));
	  setContext(ROUTE, route);
	  setContext(ROUTE_PARAMS, params);
	  setContext(FOCUS_ELEM, focusElement); // We need to call useNavigate after the route is set,
	  // so we can use the routes path for link resolution

	  var navigate = useNavigate(); // There is no need to unregister Routes in SSR since it will all be
	  // thrown away anyway

	  if (!isSSR) {
	    onDestroy(() => unregisterRoute(id));
	  }

	  $$self.$$set = $$new_props => {
	    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
	    if ('path' in $$new_props) $$invalidate(12, path = $$new_props.path);
	    if ('component' in $$new_props) $$invalidate(0, component = $$new_props.component);
	    if ('meta' in $$new_props) $$invalidate(13, meta = $$new_props.meta);
	    if ('primary' in $$new_props) $$invalidate(1, primary = $$new_props.primary);
	    if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	  };

	  $$self.$capture_state = () => ({
	    createCounter,
	    createId,
	    getContext,
	    onDestroy,
	    setContext,
	    writable,
	    get: get_store_value,
	    Router: Router$1,
	    ROUTER,
	    ROUTE,
	    ROUTE_PARAMS,
	    FOCUS_ELEM,
	    useLocation,
	    useNavigate,
	    useRouteBase,
	    usePreflightCheck,
	    isSSR,
	    extractBaseUri,
	    join: join$1,
	    ROUTE_ID,
	    path,
	    component,
	    meta,
	    primary,
	    id,
	    registerRoute,
	    unregisterRoute,
	    activeRoute,
	    parentBase,
	    location,
	    focusElement,
	    ssrMatch,
	    route,
	    params,
	    navigate,
	    isActive,
	    $activeRoute,
	    $location,
	    $parentBase,
	    $params
	  });

	  $$self.$inject_state = $$new_props => {
	    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
	    if ('path' in $$props) $$invalidate(12, path = $$new_props.path);
	    if ('component' in $$props) $$invalidate(0, component = $$new_props.component);
	    if ('meta' in $$props) $$invalidate(13, meta = $$new_props.meta);
	    if ('primary' in $$props) $$invalidate(1, primary = $$new_props.primary);
	    if ('ssrMatch' in $$props) $$invalidate(14, ssrMatch = $$new_props.ssrMatch);
	    if ('isActive' in $$props) $$invalidate(2, isActive = $$new_props.isActive);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  $$self.$$.update = () => {
	    if ($$self.$$.dirty &
	    /*path, $parentBase, meta, $location, primary*/
	    77834) {
	      {
	        // The route store will be re-computed whenever props, location or parentBase change
	        var isDefault = path === "";
	        var rawBase = join$1($parentBase, path);
	        var updatedRoute = {
	          id,
	          path,
	          meta,
	          // If no path prop is given, this Route will act as the default Route
	          // that is rendered if no other Route in the Router is a match
	          default: isDefault,
	          fullPath: isDefault ? "" : rawBase,
	          base: isDefault ? $parentBase : extractBaseUri(rawBase, $location.pathname),
	          primary,
	          focusElement
	        };
	        route.set(updatedRoute); // If we're in SSR mode and the Route matches,
	        // `registerRoute` will return the match

	        $$invalidate(14, ssrMatch = registerRoute(updatedRoute));
	      }
	    }

	    if ($$self.$$.dirty &
	    /*ssrMatch, $activeRoute*/
	    49152) {
	      $$invalidate(2, isActive = !!(ssrMatch || $activeRoute && $activeRoute.id === id));
	    }

	    if ($$self.$$.dirty &
	    /*isActive, ssrMatch, $activeRoute*/
	    49156) {
	      if (isActive) {
	        var _ref3 = ssrMatch || $activeRoute,
	            activeParams = _ref3.params;

	        params.set(activeParams);
	      }
	    }
	  };

	  $$props = exclude_internal_props($$props);
	  return [component, primary, isActive, $location, $params, id, activeRoute, parentBase, location, params, navigate, $$restProps, path, meta, ssrMatch, $activeRoute, $parentBase, slots, $$scope];
	}

	class Route extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {
	      path: 12,
	      component: 0,
	      meta: 13,
	      primary: 1
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Route",
	      options,
	      id: create_fragment$1g.name
	    });
	  }

	  get path() {
	    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set path(value) {
	    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get component() {
	    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set component(value) {
	    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get meta() {
	    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set meta(value) {
	    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get primary() {
	    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set primary(value) {
	    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Route$1 = Route;

	var file$1f = "src/components/AppBar.svelte";

	function create_fragment$1f(ctx) {
	  var div;
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      t = text(
	      /*title*/
	      ctx[0]);
	      attr_dev(div, "class", "kai-app-bar svelte-1p9fyqe");
	      set_style(div, "display",
	      /*visible*/
	      ctx[1] ? '' : 'none');
	      add_location(div, file$1f, 14, 0, 274);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*title*/
	      1) set_data_dev(t,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*visible*/
	      2) {
	        set_style(div, "display",
	        /*visible*/
	        ctx[1] ? '' : 'none');
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1f.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1f($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('AppBar', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Svelte' : _$$props$title;
	  var visible = true;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  function toggleVisibility() {
	    $$invalidate(1, visible = !visible);
	    return visible;
	  }

	  function getVisibility() {
	    return visible;
	  }

	  var writable_props = ['title'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AppBar> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	  };

	  $$self.$capture_state = () => ({
	    title,
	    visible,
	    setTitleText,
	    toggleVisibility,
	    getVisibility
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, visible, setTitleText, toggleVisibility, getVisibility];
	}

	class AppBar extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {
	      title: 0,
	      setTitleText: 2,
	      toggleVisibility: 3,
	      getVisibility: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "AppBar",
	      options,
	      id: create_fragment$1f.name
	    });
	  }

	  get title() {
	    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set title(value) {
	    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get setTitleText() {
	    return this.$$.ctx[2];
	  }

	  set setTitleText(value) {
	    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get toggleVisibility() {
	    return this.$$.ctx[3];
	  }

	  set toggleVisibility(value) {
	    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get getVisibility() {
	    return this.$$.ctx[4];
	  }

	  set getVisibility(value) {
	    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$1e = "src/components/SoftwareKey.svelte";

	function create_fragment$1e(ctx) {
	  var div3;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var t2;
	  var t3;
	  var div2;
	  var t4;
	  var div3_class_value;
	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*leftText*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");
	      t2 = text(
	      /*centerText*/
	      ctx[1]);
	      t3 = space();
	      div2 = element("div");
	      t4 = text(
	      /*rightText*/
	      ctx[2]);
	      attr_dev(div0, "class", "left svelte-1i4w4yo");
	      add_location(div0, file$1e, 30, 2, 751);
	      attr_dev(div1, "class", "center svelte-1i4w4yo");
	      add_location(div1, file$1e, 31, 2, 788);
	      attr_dev(div2, "class", "right svelte-1i4w4yo");
	      add_location(div2, file$1e, 32, 2, 829);
	      attr_dev(div3, "class", div3_class_value = "kai-software-key " + (
	      /*isInvert*/
	      ctx[3] ? 'invert' : '') + " svelte-1i4w4yo");
	      add_location(div3, file$1e, 29, 0, 691);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div0);
	      append_dev(div0, t0);
	      append_dev(div3, t1);
	      append_dev(div3, div1);
	      append_dev(div1, t2);
	      append_dev(div3, t3);
	      append_dev(div3, div2);
	      append_dev(div2, t4);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*leftText*/
	      1) set_data_dev(t0,
	      /*leftText*/
	      ctx[0]);
	      if (dirty &
	      /*centerText*/
	      2) set_data_dev(t2,
	      /*centerText*/
	      ctx[1]);
	      if (dirty &
	      /*rightText*/
	      4) set_data_dev(t4,
	      /*rightText*/
	      ctx[2]);

	      if (dirty &
	      /*isInvert*/
	      8 && div3_class_value !== (div3_class_value = "kai-software-key " + (
	      /*isInvert*/
	      ctx[3] ? 'invert' : '') + " svelte-1i4w4yo")) {
	        attr_dev(div3, "class", div3_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1e.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1e($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('SoftwareKey', slots, []);
	  var _$$props$leftText = $$props.leftText,
	      leftText = _$$props$leftText === void 0 ? 'Left' : _$$props$leftText;
	  var _$$props$centerText = $$props.centerText,
	      centerText = _$$props$centerText === void 0 ? 'Center' : _$$props$centerText;
	  var _$$props$rightText = $$props.rightText,
	      rightText = _$$props$rightText === void 0 ? 'Right' : _$$props$rightText;
	  var _$$props$isInvert = $$props.isInvert,
	      isInvert = _$$props$isInvert === void 0 ? false : _$$props$isInvert;

	  function setLeftText(text) {
	    $$invalidate(0, leftText = text);
	  }

	  function setCenterText(text) {
	    $$invalidate(1, centerText = text);
	  }

	  function setRightText(text) {
	    $$invalidate(2, rightText = text);
	  }

	  function setText() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    if (opts['left'] != null) setLeftText(opts['left']);
	    if (opts['center'] != null) setCenterText(opts['center']);
	    if (opts['right'] != null) setRightText(opts['right']);
	  }

	  function normalStyle() {
	    $$invalidate(3, isInvert = false);
	  }

	  function invertStyle() {
	    $$invalidate(3, isInvert = true);
	  }

	  var writable_props = ['leftText', 'centerText', 'rightText', 'isInvert'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SoftwareKey> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('leftText' in $$props) $$invalidate(0, leftText = $$props.leftText);
	    if ('centerText' in $$props) $$invalidate(1, centerText = $$props.centerText);
	    if ('rightText' in $$props) $$invalidate(2, rightText = $$props.rightText);
	    if ('isInvert' in $$props) $$invalidate(3, isInvert = $$props.isInvert);
	  };

	  $$self.$capture_state = () => ({
	    leftText,
	    centerText,
	    rightText,
	    isInvert,
	    setLeftText,
	    setCenterText,
	    setRightText,
	    setText,
	    normalStyle,
	    invertStyle
	  });

	  $$self.$inject_state = $$props => {
	    if ('leftText' in $$props) $$invalidate(0, leftText = $$props.leftText);
	    if ('centerText' in $$props) $$invalidate(1, centerText = $$props.centerText);
	    if ('rightText' in $$props) $$invalidate(2, rightText = $$props.rightText);
	    if ('isInvert' in $$props) $$invalidate(3, isInvert = $$props.isInvert);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [leftText, centerText, rightText, isInvert, setLeftText, setCenterText, setRightText, setText, normalStyle, invertStyle];
	}

	class SoftwareKey extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
	      leftText: 0,
	      centerText: 1,
	      rightText: 2,
	      isInvert: 3,
	      setLeftText: 4,
	      setCenterText: 5,
	      setRightText: 6,
	      setText: 7,
	      normalStyle: 8,
	      invertStyle: 9
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "SoftwareKey",
	      options,
	      id: create_fragment$1e.name
	    });
	  }

	  get leftText() {
	    throw new Error("<SoftwareKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set leftText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get centerText() {
	    throw new Error("<SoftwareKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set centerText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get rightText() {
	    throw new Error("<SoftwareKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set rightText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get isInvert() {
	    throw new Error("<SoftwareKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set isInvert(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get setLeftText() {
	    return this.$$.ctx[4];
	  }

	  set setLeftText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get setCenterText() {
	    return this.$$.ctx[5];
	  }

	  set setCenterText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get setRightText() {
	    return this.$$.ctx[6];
	  }

	  set setRightText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get setText() {
	    return this.$$.ctx[7];
	  }

	  set setText(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get normalStyle() {
	    return this.$$.ctx[8];
	  }

	  set normalStyle(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get invertStyle() {
	    return this.$$.ctx[9];
	  }

	  set invertStyle(value) {
	    throw new Error("<SoftwareKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	function keydownEventHandler(evt, scope) {
	  switch (evt.key) {
	    case 'Backspace':
	    case 'EndCall':
	      scope.backspaceListener(evt);
	      break;

	    case 'SoftLeft':
	    case 'PageUp':
	    case 'Shift':
	      scope.softkeyLeftListener(evt);
	      evt.preventDefault();
	      break;

	    case 'SoftRight':
	    case 'PageDown':
	    case 'Control':
	      scope.softkeyRightListener(evt);
	      evt.preventDefault();
	      break;

	    case 'Enter':
	      scope.enterListener(evt);
	      break;

	    case 'ArrowUp':
	      scope.arrowUpListener(evt);
	      break;

	    case 'ArrowDown':
	      scope.arrowDownListener(evt);
	      break;

	    case 'ArrowLeft':
	      scope.arrowLeftListener(evt);
	      break;

	    case 'ArrowRight':
	      scope.arrowRightListener(evt);
	      break;
	  }
	}

	function isElementInViewport(el) {
	  var marginTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  var marginBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  if (el.parentElement.getAttribute("data-pad-top")) marginTop = parseFloat(el.parentElement.getAttribute("data-pad-top"));
	  if (el.parentElement.getAttribute("data-pad-bottom")) marginBottom = parseFloat(el.parentElement.getAttribute("data-pad-bottom"));
	  var rect = el.getBoundingClientRect();
	  return rect.top >= 0 + marginTop && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) - marginBottom &&
	  /* or $(window).height() */
	  rect.right <= (window.innerWidth || document.documentElement.clientWidth)
	  /* or $(window).width() */
	  ;
	}

	function dispatchScroll(target, newScrollTop) {
	  target.scroll({
	    top: newScrollTop,
	    behavior: 'smooth'
	  });
	}

	function dispatchFocus(target, newScrollTop) {
	  target.scrollTop = newScrollTop;
	  var e = document.createEvent("UIEvents");
	  e.initUIEvent("scroll", true, true, window, 1);
	  target.dispatchEvent(e);
	}

	class KaiNavigator {
	  constructor() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    this.init = false;
	    this.verticalNavIndex = -1;
	    this.horizontalNavIndex = -1;

	    this.arrowUpListener = evt => {
	      if (this.verticalNavClass) {
	        evt.preventDefault();
	        this.navigateListNav(-1);
	      }
	    };

	    this.arrowDownListener = evt => {
	      if (this.verticalNavClass) {
	        evt.preventDefault();
	        this.navigateListNav(1);
	      }
	    };

	    this.arrowLeftListener = evt => {
	      if (this.horizontalNavClass) {
	        evt.preventDefault();
	        this.navigateTabNav(-1);
	      }
	    };

	    this.arrowRightListener = evt => {
	      if (this.horizontalNavClass) {
	        evt.preventDefault();
	        this.navigateTabNav(1);
	      }
	    };

	    this.softkeyLeftListener = evt => {};

	    this.softkeyRightListener = evt => {};

	    this.enterListener = evt => {};

	    this.backspaceListener = evt => {};

	    for (var x in opts) {
	      if (typeof opts[x] === 'function') typeof opts[x];
	      this[x] = opts[x];
	    }

	    this.eventHandler = evt => {
	      keydownEventHandler(evt, this);
	    };
	  }

	  navigateListNav(next) {
	    return this.nav(next, 'verticalNavIndex', 'verticalNavClass');
	  }

	  navigateTabNav(next) {
	    return this.nav(next, 'horizontalNavIndex', 'horizontalNavClass');
	  }

	  nav(next, navIndex, navClass) {
	    var currentIndex = this[navIndex];
	    var nav = document.getElementsByClassName(this[navClass]);

	    if (nav.length === 0) {
	      return;
	    }

	    var move = currentIndex + next;
	    var cursor = nav[move];

	    if (cursor != undefined) {
	      cursor.focus();
	      this[navIndex] = move;
	    } else {
	      if (move < 0) {
	        move = nav.length - 1;
	      } else if (move >= nav.length) {
	        move = 0;
	      }

	      cursor = nav[move];
	      cursor.focus();
	      this[navIndex] = move;
	    }

	    cursor.classList.add('focus');

	    if (currentIndex > -1 && nav.length > 1) {
	      nav[currentIndex].classList.remove('focus');
	    }

	    if (!isElementInViewport(cursor)) {
	      var marginTop = 0,
	          marginBottom = 0;
	      if (cursor.parentElement.getAttribute("data-pad-top")) marginTop = parseFloat(cursor.parentElement.getAttribute("data-pad-top"));
	      if (cursor.parentElement.getAttribute("data-pad-bottom")) marginBottom = parseFloat(cursor.parentElement.getAttribute("data-pad-bottom"));
	      var offsetTop = cursor.offsetTop - (cursor.parentElement.clientHeight - marginTop - marginBottom) / 2;
	      if (cursor.clientHeight / cursor.parentElement.clientHeight >= 0.7) offsetTop = cursor.offsetTop;
	      dispatchScroll(cursor.parentElement, offsetTop);
	      setTimeout(() => {
	        if (!isElementInViewport(cursor)) {
	          dispatchFocus(cursor.parentElement, offsetTop);
	        }
	      }, 150);
	    }

	    if (['INPUT', 'TEXTAREA'].indexOf(document.activeElement.tagName) > -1) {
	      if (document.activeElement instanceof HTMLElement) {
	        document.activeElement.blur();
	      }
	    }

	    var keys = Object.keys(cursor.children);

	    for (var k in keys) {
	      if (['INPUT', 'TEXTAREA'].indexOf(cursor.children[k].tagName) > -1) {
	        setTimeout(() => {
	          cursor.children[k].focus();
	          cursor.children[k].selectionStart = cursor.children[k].selectionEnd = cursor.children[k].value.length || cursor.children[k].value.length;
	        }, 100);
	        break;
	      }
	    }
	  }

	  attachListener() {
	    var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    document.addEventListener('keydown', this.eventHandler);
	    if (!this.init) this.init = true;else return;
	    setTimeout(() => {
	      if (this.verticalNavClass != null) this.navigateListNav(next);else if (this.horizontalNavClass != null) this.navigateTabNav(next);
	    }, 100);
	  }

	  detachListener() {
	    document.removeEventListener('keydown', this.eventHandler);
	  }

	}

	var createKaiNavigator = function createKaiNavigator() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  return new KaiNavigator(opts);
	};

	var file$1d = "src/components/Dialog.svelte"; // (91:4) {:else}

	function create_else_block$6(ctx) {
	  var div;
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      t = text(
	      /*body*/
	      ctx[1]);
	      attr_dev(div, "class", "kai-dialog-body svelte-1ko4p3e");
	      add_location(div, file$1d, 91, 4, 2480);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, t);
	      /*div_binding_1*/

	      ctx[15](div);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*body*/
	      2) set_data_dev(t,
	      /*body*/
	      ctx[1]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      /*div_binding_1*/

	      ctx[15](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$6.name,
	    type: "else",
	    source: "(91:4) {:else}",
	    ctx
	  });
	  return block;
	} // (89:4) {#if html}


	function create_if_block$h(ctx) {
	  var div;
	  var block = {
	    c: function create() {
	      div = element("div");
	      attr_dev(div, "class", "kai-dialog-body svelte-1ko4p3e");
	      add_location(div, file$1d, 89, 4, 2396);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      div.innerHTML =
	      /*body*/
	      ctx[1];
	      /*div_binding*/

	      ctx[14](div);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*body*/
	      2) div.innerHTML =
	      /*body*/
	      ctx[1];
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      /*div_binding*/

	      ctx[14](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$h.name,
	    type: "if",
	    source: "(89:4) {#if html}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1d(ctx) {
	  var div2;
	  var div1;
	  var div0;
	  var t0;
	  var t1;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*html*/
	    ctx[2]) return create_if_block$h;
	    return create_else_block$6;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      div1 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      if_block.c();
	      attr_dev(div0, "class", "kai-dialog-header svelte-1ko4p3e");
	      add_location(div0, file$1d, 87, 4, 2332);
	      attr_dev(div1, "class", "kai-dialog-content svelte-1ko4p3e");
	      add_location(div1, file$1d, 86, 2, 2295);
	      attr_dev(div2, "class", "kai-dialog svelte-1ko4p3e");
	      add_location(div2, file$1d, 85, 0, 2268);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div1);
	      append_dev(div1, div0);
	      append_dev(div0, t0);
	      append_dev(div1, t1);
	      if_block.m(div1, null);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(div1, null);
	        }
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1d.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1d($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Dialog', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Dialog' : _$$props$title;
	  var _$$props$body = $$props.body,
	      body = _$$props$body === void 0 ? '' : _$$props$body;
	  var _$$props$html = $$props.html,
	      html = _$$props$html === void 0 ? false : _$$props$html;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? evt => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? evt => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? evt => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? evt => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  var softwareKey;
	  var nodeRef;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    arrowUpListener(evt) {
	      $$invalidate(3, nodeRef.scrollTop -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      $$invalidate(3, nodeRef.scrollTop += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      $$invalidate(3, nodeRef.scrollLeft -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      $$invalidate(3, nodeRef.scrollLeft += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt);
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt);
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt);
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: false,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed();
	  });
	  var writable_props = ['title', 'body', 'html', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dialog> was created with unknown prop '${key}'`);
	  });

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(3, nodeRef);
	    });
	  }

	  function div_binding_1($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(3, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('body' in $$props) $$invalidate(1, body = $$props.body);
	    if ('html' in $$props) $$invalidate(2, html = $$props.html);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(5, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(6, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(7, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    title,
	    body,
	    html,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    softwareKey,
	    nodeRef,
	    setTitleText,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('body' in $$props) $$invalidate(1, body = $$props.body);
	    if ('html' in $$props) $$invalidate(2, html = $$props.html);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(5, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(6, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(7, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('nodeRef' in $$props) $$invalidate(3, nodeRef = $$props.nodeRef);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, body, html, nodeRef, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText, div_binding, div_binding_1];
	}

	class Dialog extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
	      title: 0,
	      body: 1,
	      html: 2,
	      softKeyLeftText: 4,
	      softKeyCenterText: 5,
	      softKeyRightText: 6,
	      onEnter: 7,
	      onBackspace: 8,
	      onSoftkeyLeft: 9,
	      onSoftkeyRight: 10,
	      onOpened: 11,
	      onClosed: 12,
	      setTitleText: 13
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Dialog",
	      options,
	      id: create_fragment$1d.name
	    });
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get body() {
	    return this.$$.ctx[1];
	  }

	  set body(body) {
	    this.$$set({
	      body
	    });
	    flush();
	  }

	  get html() {
	    return this.$$.ctx[2];
	  }

	  set html(html) {
	    this.$$set({
	      html
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[4];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[5];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[6];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[7];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[8];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[9];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[10];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[11];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[12];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[13];
	  }

	  set setTitleText(value) {
	    throw new Error("<Dialog>: Cannot set read-only property 'setTitleText'");
	  }

	}

	var file$1c = "src/components/ListView.svelte";

	var get_rightWidget_slot_changes$1 = dirty => ({});

	var get_rightWidget_slot_context$1 = ctx => ({});

	var get_leftWidget_slot_changes$1 = dirty => ({});

	var get_leftWidget_slot_context$1 = ctx => ({}); // (9:2) {#if $$slots.leftWidget}


	function create_if_block_1$a(ctx) {
	  var current;
	  var leftWidget_slot_template =
	  /*#slots*/
	  ctx[7].leftWidget;
	  var leftWidget_slot = create_slot(leftWidget_slot_template, ctx,
	  /*$$scope*/
	  ctx[6], get_leftWidget_slot_context$1);
	  var block = {
	    c: function create() {
	      if (leftWidget_slot) leftWidget_slot.c();
	    },
	    m: function mount(target, anchor) {
	      if (leftWidget_slot) {
	        leftWidget_slot.m(target, anchor);
	      }

	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (leftWidget_slot) {
	        if (leftWidget_slot.p && (!current || dirty &
	        /*$$scope*/
	        64)) {
	          update_slot_base(leftWidget_slot, leftWidget_slot_template, ctx,
	          /*$$scope*/
	          ctx[6], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[6]) : get_slot_changes(leftWidget_slot_template,
	          /*$$scope*/
	          ctx[6], dirty, get_leftWidget_slot_changes$1), get_leftWidget_slot_context$1);
	        }
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(leftWidget_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(leftWidget_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (leftWidget_slot) leftWidget_slot.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$a.name,
	    type: "if",
	    source: "(9:2) {#if $$slots.leftWidget}",
	    ctx
	  });
	  return block;
	} // (15:6) {#if subtitle}


	function create_if_block$g(ctx) {
	  var small;
	  var t;
	  var block = {
	    c: function create() {
	      small = element("small");
	      t = text(
	      /*subtitle*/
	      ctx[2]);
	      attr_dev(small, "class", "svelte-17c16wl");
	      add_location(small, file$1c, 14, 20, 417);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*subtitle*/
	      4) set_data_dev(t,
	      /*subtitle*/
	      ctx[2]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$g.name,
	    type: "if",
	    source: "(15:6) {#if subtitle}",
	    ctx
	  });
	  return block;
	} // (12:8)      


	function fallback_block_1(ctx) {
	  var div;
	  var p;
	  var t0;
	  var t1;
	  var if_block =
	  /*subtitle*/
	  ctx[2] && create_if_block$g(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(
	      /*title*/
	      ctx[1]);
	      t1 = space();
	      if (if_block) if_block.c();
	      attr_dev(p, "class", "svelte-17c16wl");
	      add_location(p, file$1c, 13, 6, 382);
	      attr_dev(div, "class", "kai-list-view-content svelte-17c16wl");
	      add_location(div, file$1c, 12, 4, 340);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(div, t1);
	      if (if_block) if_block.m(div, null);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*title*/
	      2) set_data_dev(t0,
	      /*title*/
	      ctx[1]);

	      if (
	      /*subtitle*/
	      ctx[2]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$g(ctx);
	          if_block.c();
	          if_block.m(div, null);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: fallback_block_1.name,
	    type: "fallback",
	    source: "(12:8)      ",
	    ctx
	  });
	  return block;
	} // (18:27) <span class="kai-icon-arrow">


	function fallback_block(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "class", "kai-icon-arrow svelte-17c16wl");
	      add_location(span, file$1c, 17, 27, 496);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: fallback_block.name,
	    type: "fallback",
	    source: "(18:27) <span class=\\\"kai-icon-arrow\\\">",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1c(ctx) {
	  var div;
	  var t0;
	  var t1;
	  var div_class_value;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*$$slots*/
	  ctx[5].leftWidget && create_if_block_1$a(ctx);
	  var default_slot_template =
	  /*#slots*/
	  ctx[7].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[6], null);
	  var default_slot_or_fallback = default_slot || fallback_block_1(ctx);
	  var rightWidget_slot_template =
	  /*#slots*/
	  ctx[7].rightWidget;
	  var rightWidget_slot = create_slot(rightWidget_slot_template, ctx,
	  /*$$scope*/
	  ctx[6], get_rightWidget_slot_context$1);
	  var rightWidget_slot_or_fallback = rightWidget_slot || fallback_block(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      if (if_block) if_block.c();
	      t0 = space();
	      if (default_slot_or_fallback) default_slot_or_fallback.c();
	      t1 = space();
	      if (rightWidget_slot_or_fallback) rightWidget_slot_or_fallback.c();
	      attr_dev(div, "data-key",
	      /*key*/
	      ctx[0]);
	      attr_dev(div, "class", div_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-17c16wl");
	      add_location(div, file$1c, 7, 0, 165);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if (if_block) if_block.m(div, null);
	      append_dev(div, t0);

	      if (default_slot_or_fallback) {
	        default_slot_or_fallback.m(div, null);
	      }

	      append_dev(div, t1);

	      if (rightWidget_slot_or_fallback) {
	        rightWidget_slot_or_fallback.m(div, null);
	      }

	      current = true;

	      if (!mounted) {
	        dispose = listen_dev(div, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[4]))
	            /*onClick*/
	            ctx[4].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;

	      if (
	      /*$$slots*/
	      ctx[5].leftWidget) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty &
	          /*$$slots*/
	          32) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_1$a(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(div, t0);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }

	      if (default_slot) {
	        if (default_slot.p && (!current || dirty &
	        /*$$scope*/
	        64)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[6], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[6]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[6], dirty, null), null);
	        }
	      } else {
	        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty &
	        /*subtitle, title*/
	        6)) {
	          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
	        }
	      }

	      if (rightWidget_slot) {
	        if (rightWidget_slot.p && (!current || dirty &
	        /*$$scope*/
	        64)) {
	          update_slot_base(rightWidget_slot, rightWidget_slot_template, ctx,
	          /*$$scope*/
	          ctx[6], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[6]) : get_slot_changes(rightWidget_slot_template,
	          /*$$scope*/
	          ctx[6], dirty, get_rightWidget_slot_changes$1), get_rightWidget_slot_context$1);
	        }
	      }

	      if (!current || dirty &
	      /*key*/
	      1) {
	        attr_dev(div, "data-key",
	        /*key*/
	        ctx[0]);
	      }

	      if (!current || dirty &
	      /*className*/
	      8 && div_class_value !== (div_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-17c16wl")) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      transition_in(default_slot_or_fallback, local);
	      transition_in(rightWidget_slot_or_fallback, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      transition_out(default_slot_or_fallback, local);
	      transition_out(rightWidget_slot_or_fallback, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
	      if (rightWidget_slot_or_fallback) rightWidget_slot_or_fallback.d(detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1c.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1c($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  validate_slots('ListView', slots, ['leftWidget', 'default', 'rightWidget']);
	  var $$slots = compute_slots(slots);
	  var _$$props$key = $$props.key,
	      key = _$$props$key === void 0 ? '' : _$$props$key;
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? '' : _$$props$title;
	  var _$$props$subtitle = $$props.subtitle,
	      subtitle = _$$props$subtitle === void 0 ? null : _$$props$subtitle;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? null : _$$props$className;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var writable_props = ['key', 'title', 'subtitle', 'className', 'onClick'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ListView> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('title' in $$props) $$invalidate(1, title = $$props.title);
	    if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	    if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	  };

	  $$self.$capture_state = () => ({
	    key,
	    title,
	    subtitle,
	    className,
	    onClick
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('title' in $$props) $$invalidate(1, title = $$props.title);
	    if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [key, title, subtitle, className, onClick, $$slots, $$scope, slots];
	}

	class ListView extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
	      key: 0,
	      title: 1,
	      subtitle: 2,
	      className: 3,
	      onClick: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ListView",
	      options,
	      id: create_fragment$1c.name
	    });
	  }

	  get key() {
	    throw new Error("<ListView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set key(value) {
	    throw new Error("<ListView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get title() {
	    throw new Error("<ListView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set title(value) {
	    throw new Error("<ListView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get subtitle() {
	    throw new Error("<ListView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set subtitle(value) {
	    throw new Error("<ListView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get className() {
	    throw new Error("<ListView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set className(value) {
	    throw new Error("<ListView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onClick() {
	    throw new Error("<ListView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onClick(value) {
	    throw new Error("<ListView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$1b = "src/components/OptionMenu.svelte";

	function get_each_context$8(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[16] = list[i];
	  return child_ctx;
	} // (74:8) 


	function create_leftWidget_slot$1(ctx) {
	  var span;
	  var raw_value = (
	  /*option*/
	  ctx[16].icon ?
	  /*option*/
	  ctx[16].icon : '') + "";
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      set_style(span, "padding-right", "4px");
	      add_location(span, file$1b, 73, 8, 2592);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	      span.innerHTML = raw_value;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*options*/
	      2 && raw_value !== (raw_value = (
	      /*option*/
	      ctx[16].icon ?
	      /*option*/
	      ctx[16].icon : '') + "")) span.innerHTML = raw_value;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot$1.name,
	    type: "slot",
	    source: "(74:8) ",
	    ctx
	  });
	  return block;
	} // (75:8) 


	function create_rightWidget_slot$3(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      add_location(span, file$1b, 74, 8, 2700);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot$3.name,
	    type: "slot",
	    source: "(75:8) ",
	    ctx
	  });
	  return block;
	} // (72:6) {#each options as option}


	function create_each_block$8(ctx) {
	  var listview;
	  var current;
	  listview = new ListView({
	    props: {
	      className: navClass$6,
	      title:
	      /*option*/
	      ctx[16].title,
	      subtitle:
	      /*option*/
	      ctx[16].subtitle,
	      $$slots: {
	        rightWidget: [create_rightWidget_slot$3],
	        leftWidget: [create_leftWidget_slot$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(listview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(listview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var listview_changes = {};
	      if (dirty &
	      /*options*/
	      2) listview_changes.title =
	      /*option*/
	      ctx[16].title;
	      if (dirty &
	      /*options*/
	      2) listview_changes.subtitle =
	      /*option*/
	      ctx[16].subtitle;

	      if (dirty &
	      /*$$scope, options*/
	      524290) {
	        listview_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      listview.$set(listview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(listview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(listview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(listview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$8.name,
	    type: "each",
	    source: "(72:6) {#each options as option}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1b(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var each_value =
	  /*options*/
	  ctx[1];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-19odwqw");
	      add_location(div0, file$1b, 69, 4, 2332);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-19odwqw");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$1b, 70, 4, 2386);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-19odwqw");
	      add_location(div2, file$1b, 68, 2, 2290);
	      attr_dev(div3, "class", "kai-option-menu svelte-19odwqw");
	      add_location(div3, file$1b, 67, 0, 2258);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*navClass, options*/
	      2) {
	        each_value =
	        /*options*/
	        ctx[1];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$8(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$8(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1b.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$6 = 'optionMenuNav';

	function instance$1b($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('OptionMenu', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Option Menu' : _$$props$title;
	  var _$$props$focusIndex = $$props.focusIndex,
	      focusIndex = _$$props$focusIndex === void 0 ? 0 : _$$props$focusIndex;
	  var options = $$props.options;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, scope) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, scope) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? scope => {} : _$$props$onClosed;
	  var softwareKey;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    verticalNavClass: navClass$6,

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {
	    navInstance.attachListener(focusIndex + 1);
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed({
	      index: navInstance.verticalNavIndex,
	      selected: options[navInstance.verticalNavIndex]
	    });
	  });
	  var writable_props = ['title', 'focusIndex', 'options', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OptionMenu> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(2, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(3, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(4, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(5, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(6, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(7, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(8, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(9, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(10, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(11, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    ListView,
	    navClass: navClass$6,
	    title,
	    focusIndex,
	    options,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    softwareKey,
	    setTitleText,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(2, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(3, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(4, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(5, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(6, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(7, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(8, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(9, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(10, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(11, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, options, focusIndex, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText];
	}

	class OptionMenu extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1b, create_fragment$1b, not_equal, {
	      title: 0,
	      focusIndex: 2,
	      options: 1,
	      softKeyLeftText: 3,
	      softKeyCenterText: 4,
	      softKeyRightText: 5,
	      onEnter: 6,
	      onBackspace: 7,
	      onSoftkeyLeft: 8,
	      onSoftkeyRight: 9,
	      onOpened: 10,
	      onClosed: 11,
	      setTitleText: 12
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "OptionMenu",
	      options,
	      id: create_fragment$1b.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*options*/
	    ctx[1] === undefined && !('options' in props)) {
	      console.warn("<OptionMenu> was created without expected prop 'options'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get focusIndex() {
	    return this.$$.ctx[2];
	  }

	  set focusIndex(focusIndex) {
	    this.$$set({
	      focusIndex
	    });
	    flush();
	  }

	  get options() {
	    return this.$$.ctx[1];
	  }

	  set options(options) {
	    this.$$set({
	      options
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[3];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[4];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[5];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[6];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[7];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[8];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[9];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[10];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[11];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[12];
	  }

	  set setTitleText(value) {
	    throw new Error("<OptionMenu>: Cannot set read-only property 'setTitleText'");
	  }

	}

	var file$1a = "src/components/Radio.svelte";

	function create_fragment$1a(ctx) {
	  var span;
	  var span_class_value;
	  var mounted;
	  var dispose;
	  var block = {
	    c: function create() {
	      span = element("span");
	      set_style(span, "font-size", "20px");
	      attr_dev(span, "class", span_class_value =
	      /*selected*/
	      ctx[0] ? 'kai-icon-radio-button-selected' : 'kai-icon-radio-button-unselected');
	      add_location(span, file$1a, 9, 0, 202);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);

	      if (!mounted) {
	        dispose = listen_dev(span, "click",
	        /*onClick*/
	        ctx[1], false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*selected*/
	      1 && span_class_value !== (span_class_value =
	      /*selected*/
	      ctx[0] ? 'kai-icon-radio-button-selected' : 'kai-icon-radio-button-unselected')) {
	        attr_dev(span, "class", span_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1a.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1a($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Radio', slots, []);
	  var key = $$props.key;
	  var _$$props$selected = $$props.selected,
	      selected = _$$props$selected === void 0 ? false : _$$props$selected;
	  var _$$props$onChange = $$props.onChange,
	      onChange = _$$props$onChange === void 0 ? params => {} : _$$props$onChange;

	  var onClick = evt => {
	    $$invalidate(0, selected = !selected);
	    onChange({
	      key,
	      selected
	    });
	  };

	  var writable_props = ['key', 'selected', 'onChange'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Radio> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(2, key = $$props.key);
	    if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	    if ('onChange' in $$props) $$invalidate(3, onChange = $$props.onChange);
	  };

	  $$self.$capture_state = () => ({
	    key,
	    selected,
	    onChange,
	    onClick
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(2, key = $$props.key);
	    if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	    if ('onChange' in $$props) $$invalidate(3, onChange = $$props.onChange);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [selected, onClick, key, onChange];
	}

	class Radio extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
	      key: 2,
	      selected: 0,
	      onChange: 3
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Radio",
	      options,
	      id: create_fragment$1a.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*key*/
	    ctx[2] === undefined && !('key' in props)) {
	      console.warn("<Radio> was created without expected prop 'key'");
	    }
	  }

	  get key() {
	    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set key(value) {
	    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get selected() {
	    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set selected(value) {
	    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onChange() {
	    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onChange(value) {
	    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Object_1$3 = globals.Object;
	var file$19 = "src/components/SingleSelector.svelte";

	function get_each_context$7(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[17] = list[i];
	  child_ctx[19] = i;
	  return child_ctx;
	} // (92:8) 


	function create_rightWidget_slot$2(ctx) {
	  var radio;
	  var current;
	  radio = new Radio({
	    props: {
	      slot: "rightWidget",
	      key:
	      /*i*/
	      ctx[19],
	      selected:
	      /*option*/
	      ctx[17].selected,
	      onChange:
	      /*onRadioChange*/
	      ctx[2]
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(radio.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(radio, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var radio_changes = {};
	      if (dirty &
	      /*options*/
	      2) radio_changes.selected =
	      /*option*/
	      ctx[17].selected;
	      radio.$set(radio_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(radio.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(radio.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(radio, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot$2.name,
	    type: "slot",
	    source: "(92:8) ",
	    ctx
	  });
	  return block;
	} // (90:6) {#each options as option, i}


	function create_each_block$7(ctx) {
	  var listview;
	  var current;
	  listview = new ListView({
	    props: {
	      className: navClass$5,
	      title:
	      /*option*/
	      ctx[17].title,
	      subtitle:
	      /*option*/
	      ctx[17].subtitle,
	      $$slots: {
	        rightWidget: [create_rightWidget_slot$2]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(listview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(listview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var listview_changes = {};
	      if (dirty &
	      /*options*/
	      2) listview_changes.title =
	      /*option*/
	      ctx[17].title;
	      if (dirty &
	      /*options*/
	      2) listview_changes.subtitle =
	      /*option*/
	      ctx[17].subtitle;

	      if (dirty &
	      /*$$scope, options*/
	      1048578) {
	        listview_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      listview.$set(listview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(listview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(listview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(listview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$7.name,
	    type: "each",
	    source: "(90:6) {#each options as option, i}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$19(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var each_value =
	  /*options*/
	  ctx[1];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-19odwqw");
	      add_location(div0, file$19, 87, 4, 2650);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-19odwqw");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$19, 88, 4, 2704);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-19odwqw");
	      add_location(div2, file$19, 86, 2, 2608);
	      attr_dev(div3, "class", "kai-option-menu svelte-19odwqw");
	      add_location(div3, file$19, 85, 0, 2576);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*navClass, options, onRadioChange*/
	      6) {
	        each_value =
	        /*options*/
	        ctx[1];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$7(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$7(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$19.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$5 = 'singleSelectorNav';

	function instance$19($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('SingleSelector', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Single Selector' : _$$props$title;
	  var _$$props$focusIndex = $$props.focusIndex,
	      focusIndex = _$$props$focusIndex === void 0 ? 0 : _$$props$focusIndex;
	  var options = $$props.options;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'SELECT' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, scope) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, scope) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? scope => {} : _$$props$onClosed;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var softwareKey;
	  var navOptions = {
	    verticalNavClass: navClass$5,

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, {
	        options
	      });
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, {
	        options
	      });
	    },

	    enterListener(evt) {
	      if (options[this.verticalNavIndex].selected) {
	        onEnter(evt, {
	          options
	        });
	        return;
	      }

	      var navClasses = document.getElementsByClassName(navClass$5);

	      if (navClasses[this.verticalNavIndex] != null) {
	        var children = navClasses[this.verticalNavIndex].children;
	        var keys = Object.keys(children);

	        for (var c in keys) {
	          children[c].click();
	        }
	      }

	      onEnter(evt, {
	        options
	      });
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, {
	        options
	      });
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function onRadioChange(scope) {
	    $$invalidate(1, options[scope.key].selected = scope.selected, options);
	    options.forEach((o, i) => {
	      if (i != scope.key) o.selected = false;
	    });
	  }

	  onMount(() => {
	    navInstance.attachListener(focusIndex + 1);
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed({
	      options
	    });
	  });
	  var writable_props = ['title', 'focusIndex', 'options', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object_1$3.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SingleSelector> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(5, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(6, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(7, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    ListView,
	    Radio,
	    title,
	    focusIndex,
	    options,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    setTitleText,
	    navClass: navClass$5,
	    softwareKey,
	    navOptions,
	    navInstance,
	    onRadioChange
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(5, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(6, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(7, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, options, onRadioChange, focusIndex, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText];
	}

	class SingleSelector extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$19, create_fragment$19, not_equal, {
	      title: 0,
	      focusIndex: 3,
	      options: 1,
	      softKeyLeftText: 4,
	      softKeyCenterText: 5,
	      softKeyRightText: 6,
	      onEnter: 7,
	      onBackspace: 8,
	      onSoftkeyLeft: 9,
	      onSoftkeyRight: 10,
	      onOpened: 11,
	      onClosed: 12,
	      setTitleText: 13
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "SingleSelector",
	      options,
	      id: create_fragment$19.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*options*/
	    ctx[1] === undefined && !('options' in props)) {
	      console.warn("<SingleSelector> was created without expected prop 'options'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get focusIndex() {
	    return this.$$.ctx[3];
	  }

	  set focusIndex(focusIndex) {
	    this.$$set({
	      focusIndex
	    });
	    flush();
	  }

	  get options() {
	    return this.$$.ctx[1];
	  }

	  set options(options) {
	    this.$$set({
	      options
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[4];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[5];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[6];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[7];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[8];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[9];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[10];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[11];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[12];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[13];
	  }

	  set setTitleText(value) {
	    throw new Error("<SingleSelector>: Cannot set read-only property 'setTitleText'");
	  }

	}

	var file$18 = "src/components/Checkbox.svelte";

	function create_fragment$18(ctx) {
	  var span;
	  var span_class_value;
	  var mounted;
	  var dispose;
	  var block = {
	    c: function create() {
	      span = element("span");
	      set_style(span, "font-size", "20px");
	      attr_dev(span, "class", span_class_value =
	      /*checked*/
	      ctx[0] ? 'kai-icon-checkbox-checked' : 'kai-icon-checkbox-unchecked');
	      add_location(span, file$18, 9, 0, 198);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);

	      if (!mounted) {
	        dispose = listen_dev(span, "click",
	        /*onClick*/
	        ctx[1], false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*checked*/
	      1 && span_class_value !== (span_class_value =
	      /*checked*/
	      ctx[0] ? 'kai-icon-checkbox-checked' : 'kai-icon-checkbox-unchecked')) {
	        attr_dev(span, "class", span_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$18.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$18($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Checkbox', slots, []);
	  var key = $$props.key;
	  var _$$props$checked = $$props.checked,
	      checked = _$$props$checked === void 0 ? false : _$$props$checked;
	  var _$$props$onChange = $$props.onChange,
	      onChange = _$$props$onChange === void 0 ? params => {} : _$$props$onChange;

	  var onClick = evt => {
	    $$invalidate(0, checked = !checked);
	    onChange({
	      key,
	      checked
	    });
	  };

	  var writable_props = ['key', 'checked', 'onChange'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkbox> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(2, key = $$props.key);
	    if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
	    if ('onChange' in $$props) $$invalidate(3, onChange = $$props.onChange);
	  };

	  $$self.$capture_state = () => ({
	    key,
	    checked,
	    onChange,
	    onClick
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(2, key = $$props.key);
	    if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
	    if ('onChange' in $$props) $$invalidate(3, onChange = $$props.onChange);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [checked, onClick, key, onChange];
	}

	class Checkbox extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$18, create_fragment$18, safe_not_equal, {
	      key: 2,
	      checked: 0,
	      onChange: 3
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Checkbox",
	      options,
	      id: create_fragment$18.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*key*/
	    ctx[2] === undefined && !('key' in props)) {
	      console.warn("<Checkbox> was created without expected prop 'key'");
	    }
	  }

	  get key() {
	    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set key(value) {
	    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get checked() {
	    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set checked(value) {
	    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onChange() {
	    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onChange(value) {
	    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Object_1$2 = globals.Object;
	var file$17 = "src/components/MultiSelector.svelte";

	function get_each_context$6(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[18] = list[i];
	  child_ctx[20] = i;
	  return child_ctx;
	} // (103:8) 


	function create_rightWidget_slot$1(ctx) {
	  var checkbox;
	  var current;
	  checkbox = new Checkbox({
	    props: {
	      slot: "rightWidget",
	      key:
	      /*i*/
	      ctx[20],
	      checked:
	      /*option*/
	      ctx[18].checked,
	      onChange:
	      /*onCheckboxChange*/
	      ctx[2]
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(checkbox.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(checkbox, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var checkbox_changes = {};
	      if (dirty &
	      /*options*/
	      2) checkbox_changes.checked =
	      /*option*/
	      ctx[18].checked;
	      checkbox.$set(checkbox_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(checkbox.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(checkbox.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(checkbox, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot$1.name,
	    type: "slot",
	    source: "(103:8) ",
	    ctx
	  });
	  return block;
	} // (101:6) {#each options as option, i}


	function create_each_block$6(ctx) {
	  var listview;
	  var current;
	  listview = new ListView({
	    props: {
	      className: navClass$4,
	      title:
	      /*option*/
	      ctx[18].title,
	      subtitle:
	      /*option*/
	      ctx[18].subtitle,
	      $$slots: {
	        rightWidget: [create_rightWidget_slot$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(listview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(listview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var listview_changes = {};
	      if (dirty &
	      /*options*/
	      2) listview_changes.title =
	      /*option*/
	      ctx[18].title;
	      if (dirty &
	      /*options*/
	      2) listview_changes.subtitle =
	      /*option*/
	      ctx[18].subtitle;

	      if (dirty &
	      /*$$scope, options*/
	      2097154) {
	        listview_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      listview.$set(listview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(listview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(listview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(listview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$6.name,
	    type: "each",
	    source: "(101:6) {#each options as option, i}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$17(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var each_value =
	  /*options*/
	  ctx[1];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-19odwqw");
	      add_location(div0, file$17, 98, 4, 2993);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-19odwqw");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$17, 99, 4, 3047);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-19odwqw");
	      add_location(div2, file$17, 97, 2, 2951);
	      attr_dev(div3, "class", "kai-option-menu svelte-19odwqw");
	      add_location(div3, file$17, 96, 0, 2919);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*navClass, options, onCheckboxChange*/
	      6) {
	        each_value =
	        /*options*/
	        ctx[1];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$6(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$6(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$17.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$4 = 'singleSelectorNav';

	function instance$17($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MultiSelector', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Single Selector' : _$$props$title;
	  var _$$props$focusIndex = $$props.focusIndex,
	      focusIndex = _$$props$focusIndex === void 0 ? 0 : _$$props$focusIndex;
	  var options = $$props.options;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterTextSelect,
	      softKeyCenterTextSelect = _$$props$softKeyCente === void 0 ? 'SELECT' : _$$props$softKeyCente;
	  var _$$props$softKeyCente2 = $$props.softKeyCenterTextDeselect,
	      softKeyCenterTextDeselect = _$$props$softKeyCente2 === void 0 ? 'DESELECT' : _$$props$softKeyCente2;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, scope) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? scope => {} : _$$props$onClosed;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var softwareKey;
	  var navOptions = {
	    verticalNavClass: navClass$4,

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, {
	        options
	      });
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, {
	        options
	      });
	    },

	    enterListener(evt) {
	      var navClasses = document.getElementsByClassName(navClass$4);

	      if (navClasses[this.verticalNavIndex] != null) {
	        var children = navClasses[this.verticalNavIndex].children;
	        var keys = Object.keys(children);

	        for (var c in keys) {
	          children[c].click();
	        }
	      }
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, {
	        options
	      });
	    },

	    arrowUpListener(evt) {
	      evt.preventDefault();
	      this.navigateListNav(-1);
	      renderCenterKey(this.verticalNavIndex);
	    },

	    arrowDownListener(evt) {
	      evt.preventDefault();
	      this.navigateListNav(1);
	      renderCenterKey(this.verticalNavIndex);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function onCheckboxChange(scope) {
	    $$invalidate(1, options[scope.key].checked = scope.checked, options);
	    renderCenterKey(scope.key);
	  }

	  function renderCenterKey(index) {
	    if (options[index].checked) {
	      softwareKey.setCenterText(softKeyCenterTextDeselect);
	    } else {
	      softwareKey.setCenterText(softKeyCenterTextSelect);
	    }
	  }

	  onMount(() => {
	    navInstance.attachListener(focusIndex + 1);
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: '',
	        rightText: softKeyRightText
	      }
	    });
	    renderCenterKey(focusIndex);
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed({
	      options
	    });
	  });
	  var writable_props = ['title', 'focusIndex', 'options', 'softKeyLeftText', 'softKeyCenterTextSelect', 'softKeyCenterTextDeselect', 'softKeyRightText', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object_1$2.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiSelector> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterTextSelect' in $$props) $$invalidate(5, softKeyCenterTextSelect = $$props.softKeyCenterTextSelect);
	    if ('softKeyCenterTextDeselect' in $$props) $$invalidate(6, softKeyCenterTextDeselect = $$props.softKeyCenterTextDeselect);
	    if ('softKeyRightText' in $$props) $$invalidate(7, softKeyRightText = $$props.softKeyRightText);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    ListView,
	    Checkbox,
	    title,
	    focusIndex,
	    options,
	    softKeyLeftText,
	    softKeyCenterTextSelect,
	    softKeyCenterTextDeselect,
	    softKeyRightText,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    setTitleText,
	    navClass: navClass$4,
	    softwareKey,
	    navOptions,
	    navInstance,
	    onCheckboxChange,
	    renderCenterKey
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('softKeyLeftText' in $$props) $$invalidate(4, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterTextSelect' in $$props) $$invalidate(5, softKeyCenterTextSelect = $$props.softKeyCenterTextSelect);
	    if ('softKeyCenterTextDeselect' in $$props) $$invalidate(6, softKeyCenterTextDeselect = $$props.softKeyCenterTextDeselect);
	    if ('softKeyRightText' in $$props) $$invalidate(7, softKeyRightText = $$props.softKeyRightText);
	    if ('onBackspace' in $$props) $$invalidate(8, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(9, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(10, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(11, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(12, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, options, onCheckboxChange, focusIndex, softKeyLeftText, softKeyCenterTextSelect, softKeyCenterTextDeselect, softKeyRightText, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText];
	}

	class MultiSelector extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$17, create_fragment$17, not_equal, {
	      title: 0,
	      focusIndex: 3,
	      options: 1,
	      softKeyLeftText: 4,
	      softKeyCenterTextSelect: 5,
	      softKeyCenterTextDeselect: 6,
	      softKeyRightText: 7,
	      onBackspace: 8,
	      onSoftkeyLeft: 9,
	      onSoftkeyRight: 10,
	      onOpened: 11,
	      onClosed: 12,
	      setTitleText: 13
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MultiSelector",
	      options,
	      id: create_fragment$17.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*options*/
	    ctx[1] === undefined && !('options' in props)) {
	      console.warn("<MultiSelector> was created without expected prop 'options'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get focusIndex() {
	    return this.$$.ctx[3];
	  }

	  set focusIndex(focusIndex) {
	    this.$$set({
	      focusIndex
	    });
	    flush();
	  }

	  get options() {
	    return this.$$.ctx[1];
	  }

	  set options(options) {
	    this.$$set({
	      options
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[4];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterTextSelect() {
	    return this.$$.ctx[5];
	  }

	  set softKeyCenterTextSelect(softKeyCenterTextSelect) {
	    this.$$set({
	      softKeyCenterTextSelect
	    });
	    flush();
	  }

	  get softKeyCenterTextDeselect() {
	    return this.$$.ctx[6];
	  }

	  set softKeyCenterTextDeselect(softKeyCenterTextDeselect) {
	    this.$$set({
	      softKeyCenterTextDeselect
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[7];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[8];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[9];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[10];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[11];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[12];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[13];
	  }

	  set setTitleText(value) {
	    throw new Error("<MultiSelector>: Cannot set read-only property 'setTitleText'");
	  }

	}

	/* src/components/LoadingBar.svelte generated by Svelte v3.46.4 */
	var file$16 = "src/components/LoadingBar.svelte";

	function create_fragment$16(ctx) {
	  var div2;
	  var div0;
	  var t;
	  var div1;
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      div0 = element("div");
	      t = space();
	      div1 = element("div");
	      attr_dev(div0, "class", "bar bar1 svelte-148me75");
	      add_location(div0, file$16, 12, 2, 246);
	      attr_dev(div1, "class", "bar bar2 svelte-148me75");
	      add_location(div1, file$16, 13, 2, 277);
	      attr_dev(div2, "class", "kai-loading-bar svelte-148me75");
	      add_location(div2, file$16, 11, 0, 214);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div0);
	      append_dev(div2, t);
	      append_dev(div2, div1);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$16.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$16($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('LoadingBar', slots, []);
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  onMount(() => {
	    onOpened();
	  });
	  onDestroy(() => {
	    onClosed();
	  });
	  var writable_props = ['onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingBar> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('onOpened' in $$props) $$invalidate(0, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(1, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    onOpened,
	    onClosed
	  });

	  $$self.$inject_state = $$props => {
	    if ('onOpened' in $$props) $$invalidate(0, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(1, onClosed = $$props.onClosed);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [onOpened, onClosed];
	}

	class LoadingBar extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$16, create_fragment$16, safe_not_equal, {
	      onOpened: 0,
	      onClosed: 1
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "LoadingBar",
	      options,
	      id: create_fragment$16.name
	    });
	  }

	  get onOpened() {
	    throw new Error("<LoadingBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onOpened(value) {
	    throw new Error("<LoadingBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onClosed() {
	    throw new Error("<LoadingBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onClosed(value) {
	    throw new Error("<LoadingBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$15 = "src/components/Button.svelte";

	var get_rightWidget_slot_changes = dirty => ({});

	var get_rightWidget_slot_context = ctx => ({});

	var get_leftWidget_slot_changes = dirty => ({});

	var get_leftWidget_slot_context = ctx => ({});

	function create_fragment$15(ctx) {
	  var div;
	  var t0;
	  var span;
	  var t1;
	  var t2;
	  var div_class_value;
	  var current;
	  var mounted;
	  var dispose;
	  var leftWidget_slot_template =
	  /*#slots*/
	  ctx[4].leftWidget;
	  var leftWidget_slot = create_slot(leftWidget_slot_template, ctx,
	  /*$$scope*/
	  ctx[3], get_leftWidget_slot_context);
	  var rightWidget_slot_template =
	  /*#slots*/
	  ctx[4].rightWidget;
	  var rightWidget_slot = create_slot(rightWidget_slot_template, ctx,
	  /*$$scope*/
	  ctx[3], get_rightWidget_slot_context);
	  var block = {
	    c: function create() {
	      div = element("div");
	      if (leftWidget_slot) leftWidget_slot.c();
	      t0 = space();
	      span = element("span");
	      t1 = text(
	      /*text*/
	      ctx[1]);
	      t2 = space();
	      if (rightWidget_slot) rightWidget_slot.c();
	      add_location(span, file$15, 7, 2, 205);
	      attr_dev(div, "class", div_class_value = "kai-button " +
	      /*className*/
	      ctx[0] + " svelte-1ag0473");
	      add_location(div, file$15, 5, 0, 113);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);

	      if (leftWidget_slot) {
	        leftWidget_slot.m(div, null);
	      }

	      append_dev(div, t0);
	      append_dev(div, span);
	      append_dev(span, t1);
	      append_dev(div, t2);

	      if (rightWidget_slot) {
	        rightWidget_slot.m(div, null);
	      }

	      current = true;

	      if (!mounted) {
	        dispose = listen_dev(div, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[2]))
	            /*onClick*/
	            ctx[2].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;

	      if (leftWidget_slot) {
	        if (leftWidget_slot.p && (!current || dirty &
	        /*$$scope*/
	        8)) {
	          update_slot_base(leftWidget_slot, leftWidget_slot_template, ctx,
	          /*$$scope*/
	          ctx[3], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[3]) : get_slot_changes(leftWidget_slot_template,
	          /*$$scope*/
	          ctx[3], dirty, get_leftWidget_slot_changes), get_leftWidget_slot_context);
	        }
	      }

	      if (!current || dirty &
	      /*text*/
	      2) set_data_dev(t1,
	      /*text*/
	      ctx[1]);

	      if (rightWidget_slot) {
	        if (rightWidget_slot.p && (!current || dirty &
	        /*$$scope*/
	        8)) {
	          update_slot_base(rightWidget_slot, rightWidget_slot_template, ctx,
	          /*$$scope*/
	          ctx[3], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[3]) : get_slot_changes(rightWidget_slot_template,
	          /*$$scope*/
	          ctx[3], dirty, get_rightWidget_slot_changes), get_rightWidget_slot_context);
	        }
	      }

	      if (!current || dirty &
	      /*className*/
	      1 && div_class_value !== (div_class_value = "kai-button " +
	      /*className*/
	      ctx[0] + " svelte-1ag0473")) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(leftWidget_slot, local);
	      transition_in(rightWidget_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(leftWidget_slot, local);
	      transition_out(rightWidget_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (leftWidget_slot) leftWidget_slot.d(detaching);
	      if (rightWidget_slot) rightWidget_slot.d(detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$15.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$15($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  validate_slots('Button', slots, ['leftWidget', 'rightWidget']);
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? '' : _$$props$className;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var writable_props = ['className', 'text', 'onClick'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('text' in $$props) $$invalidate(1, text = $$props.text);
	    if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
	    if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	  };

	  $$self.$capture_state = () => ({
	    className,
	    text,
	    onClick
	  });

	  $$self.$inject_state = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('text' in $$props) $$invalidate(1, text = $$props.text);
	    if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [className, text, onClick, $$scope, slots];
	}

	class Button extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$15, create_fragment$15, safe_not_equal, {
	      className: 0,
	      text: 1,
	      onClick: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Button",
	      options,
	      id: create_fragment$15.name
	    });
	  }

	  get className() {
	    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set className(value) {
	    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get text() {
	    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set text(value) {
	    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onClick() {
	    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onClick(value) {
	    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$14 = "src/components/TextInputField.svelte"; // (12:2) {#if label}

	function create_if_block$f(ctx) {
	  var label_1;
	  var t;
	  var label_1_for_value;
	  var block = {
	    c: function create() {
	      label_1 = element("label");
	      t = text(
	      /*label*/
	      ctx[1]);
	      attr_dev(label_1, "for", label_1_for_value =
	      /*label*/
	      ctx[1].split(' ').join('-'));
	      attr_dev(label_1, "class", "svelte-8mjoxj");
	      add_location(label_1, file$14, 12, 2, 325);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, label_1, anchor);
	      append_dev(label_1, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*label*/
	      2) set_data_dev(t,
	      /*label*/
	      ctx[1]);

	      if (dirty &
	      /*label*/
	      2 && label_1_for_value !== (label_1_for_value =
	      /*label*/
	      ctx[1].split(' ').join('-'))) {
	        attr_dev(label_1, "for", label_1_for_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(label_1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$f.name,
	    type: "if",
	    source: "(12:2) {#if label}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$14(ctx) {
	  var div;
	  var t;
	  var input;
	  var input_id_value;
	  var div_class_value;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*label*/
	  ctx[1] && create_if_block$f(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      if (if_block) if_block.c();
	      t = space();
	      input = element("input");
	      attr_dev(input, "id", input_id_value =
	      /*label*/
	      ctx[1] &&
	      /*label*/
	      ctx[1].split(' ').join('-'));
	      attr_dev(input, "name",
	      /*label*/
	      ctx[1]);
	      attr_dev(input, "type",
	      /*type*/
	      ctx[3]);
	      input.value =
	      /*value*/
	      ctx[2];
	      attr_dev(input, "placeholder",
	      /*placeholder*/
	      ctx[4]);
	      attr_dev(input, "class", "svelte-8mjoxj");
	      add_location(input, file$14, 14, 2, 391);
	      attr_dev(div, "class", div_class_value = "kai-text-input " +
	      /*className*/
	      ctx[0] + " svelte-8mjoxj");
	      add_location(div, file$14, 10, 0, 268);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if (if_block) if_block.m(div, null);
	      append_dev(div, t);
	      append_dev(div, input);

	      if (!mounted) {
	        dispose = [listen_dev(input, "input", function () {
	          if (is_function(
	          /*onInput*/
	          ctx[5]))
	            /*onInput*/
	            ctx[5].apply(this, arguments);
	        }, false, false, false), listen_dev(input, "focus", function () {
	          if (is_function(
	          /*onFocus*/
	          ctx[6]))
	            /*onFocus*/
	            ctx[6].apply(this, arguments);
	        }, false, false, false), listen_dev(input, "blur", function () {
	          if (is_function(
	          /*onBlur*/
	          ctx[7]))
	            /*onBlur*/
	            ctx[7].apply(this, arguments);
	        }, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;

	      if (
	      /*label*/
	      ctx[1]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$f(ctx);
	          if_block.c();
	          if_block.m(div, t);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if (dirty &
	      /*label*/
	      2 && input_id_value !== (input_id_value =
	      /*label*/
	      ctx[1] &&
	      /*label*/
	      ctx[1].split(' ').join('-'))) {
	        attr_dev(input, "id", input_id_value);
	      }

	      if (dirty &
	      /*label*/
	      2) {
	        attr_dev(input, "name",
	        /*label*/
	        ctx[1]);
	      }

	      if (dirty &
	      /*type*/
	      8) {
	        attr_dev(input, "type",
	        /*type*/
	        ctx[3]);
	      }

	      if (dirty &
	      /*value*/
	      4 && input.value !==
	      /*value*/
	      ctx[2]) {
	        prop_dev(input, "value",
	        /*value*/
	        ctx[2]);
	      }

	      if (dirty &
	      /*placeholder*/
	      16) {
	        attr_dev(input, "placeholder",
	        /*placeholder*/
	        ctx[4]);
	      }

	      if (dirty &
	      /*className*/
	      1 && div_class_value !== (div_class_value = "kai-text-input " +
	      /*className*/
	      ctx[0] + " svelte-8mjoxj")) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$14.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$14($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('TextInputField', slots, []);
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? '' : _$$props$className;
	  var _$$props$label = $$props.label,
	      label = _$$props$label === void 0 ? undefined : _$$props$label;
	  var _$$props$value = $$props.value,
	      value = _$$props$value === void 0 ? '' : _$$props$value;
	  var _$$props$type = $$props.type,
	      type = _$$props$type === void 0 ? 'text' : _$$props$type;
	  var _$$props$placeholder = $$props.placeholder,
	      placeholder = _$$props$placeholder === void 0 ? '' : _$$props$placeholder;
	  var _$$props$onInput = $$props.onInput,
	      onInput = _$$props$onInput === void 0 ? evt => {} : _$$props$onInput;
	  var _$$props$onFocus = $$props.onFocus,
	      onFocus = _$$props$onFocus === void 0 ? evt => {} : _$$props$onFocus;
	  var _$$props$onBlur = $$props.onBlur,
	      onBlur = _$$props$onBlur === void 0 ? evt => {} : _$$props$onBlur;
	  var writable_props = ['className', 'label', 'value', 'type', 'placeholder', 'onInput', 'onFocus', 'onBlur'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInputField> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('label' in $$props) $$invalidate(1, label = $$props.label);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
	    if ('onInput' in $$props) $$invalidate(5, onInput = $$props.onInput);
	    if ('onFocus' in $$props) $$invalidate(6, onFocus = $$props.onFocus);
	    if ('onBlur' in $$props) $$invalidate(7, onBlur = $$props.onBlur);
	  };

	  $$self.$capture_state = () => ({
	    className,
	    label,
	    value,
	    type,
	    placeholder,
	    onInput,
	    onFocus,
	    onBlur
	  });

	  $$self.$inject_state = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('label' in $$props) $$invalidate(1, label = $$props.label);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
	    if ('onInput' in $$props) $$invalidate(5, onInput = $$props.onInput);
	    if ('onFocus' in $$props) $$invalidate(6, onFocus = $$props.onFocus);
	    if ('onBlur' in $$props) $$invalidate(7, onBlur = $$props.onBlur);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [className, label, value, type, placeholder, onInput, onFocus, onBlur];
	}

	class TextInputField extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$14, create_fragment$14, safe_not_equal, {
	      className: 0,
	      label: 1,
	      value: 2,
	      type: 3,
	      placeholder: 4,
	      onInput: 5,
	      onFocus: 6,
	      onBlur: 7
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "TextInputField",
	      options,
	      id: create_fragment$14.name
	    });
	  }

	  get className() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set className(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get label() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set label(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get value() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set value(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get type() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set type(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get placeholder() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set placeholder(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onInput() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onInput(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onFocus() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onFocus(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onBlur() {
	    throw new Error("<TextInputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onBlur(value) {
	    throw new Error("<TextInputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$13 = "src/components/TextAreaField.svelte"; // (13:2) {#if label}

	function create_if_block$e(ctx) {
	  var label_1;
	  var t;
	  var label_1_for_value;
	  var block = {
	    c: function create() {
	      label_1 = element("label");
	      t = text(
	      /*label*/
	      ctx[1]);
	      attr_dev(label_1, "for", label_1_for_value =
	      /*label*/
	      ctx[1].split(' ').join('-'));
	      attr_dev(label_1, "class", "svelte-34j26e");
	      add_location(label_1, file$13, 13, 2, 345);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, label_1, anchor);
	      append_dev(label_1, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*label*/
	      2) set_data_dev(t,
	      /*label*/
	      ctx[1]);

	      if (dirty &
	      /*label*/
	      2 && label_1_for_value !== (label_1_for_value =
	      /*label*/
	      ctx[1].split(' ').join('-'))) {
	        attr_dev(label_1, "for", label_1_for_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(label_1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$e.name,
	    type: "if",
	    source: "(13:2) {#if label}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$13(ctx) {
	  var div;
	  var t;
	  var textarea;
	  var textarea_id_value;
	  var div_class_value;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*label*/
	  ctx[1] && create_if_block$e(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      if (if_block) if_block.c();
	      t = space();
	      textarea = element("textarea");
	      attr_dev(textarea, "id", textarea_id_value =
	      /*label*/
	      ctx[1] &&
	      /*label*/
	      ctx[1].split(' ').join('-'));
	      attr_dev(textarea, "name",
	      /*label*/
	      ctx[1]);
	      attr_dev(textarea, "type",
	      /*type*/
	      ctx[3]);
	      textarea.value =
	      /*value*/
	      ctx[2];
	      attr_dev(textarea, "placeholder",
	      /*placeholder*/
	      ctx[4]);
	      attr_dev(textarea, "rows",
	      /*rows*/
	      ctx[5]);
	      attr_dev(textarea, "class", "svelte-34j26e");
	      add_location(textarea, file$13, 15, 2, 411);
	      attr_dev(div, "class", div_class_value = "kai-text-area " +
	      /*className*/
	      ctx[0] + " svelte-34j26e");
	      add_location(div, file$13, 11, 0, 289);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if (if_block) if_block.m(div, null);
	      append_dev(div, t);
	      append_dev(div, textarea);

	      if (!mounted) {
	        dispose = [listen_dev(textarea, "input", function () {
	          if (is_function(
	          /*onInput*/
	          ctx[6]))
	            /*onInput*/
	            ctx[6].apply(this, arguments);
	        }, false, false, false), listen_dev(textarea, "focus", function () {
	          if (is_function(
	          /*onFocus*/
	          ctx[7]))
	            /*onFocus*/
	            ctx[7].apply(this, arguments);
	        }, false, false, false), listen_dev(textarea, "blur", function () {
	          if (is_function(
	          /*onBlur*/
	          ctx[8]))
	            /*onBlur*/
	            ctx[8].apply(this, arguments);
	        }, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;

	      if (
	      /*label*/
	      ctx[1]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$e(ctx);
	          if_block.c();
	          if_block.m(div, t);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if (dirty &
	      /*label*/
	      2 && textarea_id_value !== (textarea_id_value =
	      /*label*/
	      ctx[1] &&
	      /*label*/
	      ctx[1].split(' ').join('-'))) {
	        attr_dev(textarea, "id", textarea_id_value);
	      }

	      if (dirty &
	      /*label*/
	      2) {
	        attr_dev(textarea, "name",
	        /*label*/
	        ctx[1]);
	      }

	      if (dirty &
	      /*type*/
	      8) {
	        attr_dev(textarea, "type",
	        /*type*/
	        ctx[3]);
	      }

	      if (dirty &
	      /*value*/
	      4) {
	        prop_dev(textarea, "value",
	        /*value*/
	        ctx[2]);
	      }

	      if (dirty &
	      /*placeholder*/
	      16) {
	        attr_dev(textarea, "placeholder",
	        /*placeholder*/
	        ctx[4]);
	      }

	      if (dirty &
	      /*rows*/
	      32) {
	        attr_dev(textarea, "rows",
	        /*rows*/
	        ctx[5]);
	      }

	      if (dirty &
	      /*className*/
	      1 && div_class_value !== (div_class_value = "kai-text-area " +
	      /*className*/
	      ctx[0] + " svelte-34j26e")) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$13.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$13($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('TextAreaField', slots, []);
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? '' : _$$props$className;
	  var _$$props$label = $$props.label,
	      label = _$$props$label === void 0 ? undefined : _$$props$label;
	  var _$$props$value = $$props.value,
	      value = _$$props$value === void 0 ? '' : _$$props$value;
	  var _$$props$type = $$props.type,
	      type = _$$props$type === void 0 ? 'text' : _$$props$type;
	  var _$$props$placeholder = $$props.placeholder,
	      placeholder = _$$props$placeholder === void 0 ? '' : _$$props$placeholder;
	  var _$$props$rows = $$props.rows,
	      rows = _$$props$rows === void 0 ? 2 : _$$props$rows;
	  var _$$props$onInput = $$props.onInput,
	      onInput = _$$props$onInput === void 0 ? evt => {} : _$$props$onInput;
	  var _$$props$onFocus = $$props.onFocus,
	      onFocus = _$$props$onFocus === void 0 ? evt => {} : _$$props$onFocus;
	  var _$$props$onBlur = $$props.onBlur,
	      onBlur = _$$props$onBlur === void 0 ? evt => {} : _$$props$onBlur;
	  var writable_props = ['className', 'label', 'value', 'type', 'placeholder', 'rows', 'onInput', 'onFocus', 'onBlur'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextAreaField> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('label' in $$props) $$invalidate(1, label = $$props.label);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
	    if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
	    if ('onInput' in $$props) $$invalidate(6, onInput = $$props.onInput);
	    if ('onFocus' in $$props) $$invalidate(7, onFocus = $$props.onFocus);
	    if ('onBlur' in $$props) $$invalidate(8, onBlur = $$props.onBlur);
	  };

	  $$self.$capture_state = () => ({
	    className,
	    label,
	    value,
	    type,
	    placeholder,
	    rows,
	    onInput,
	    onFocus,
	    onBlur
	  });

	  $$self.$inject_state = $$props => {
	    if ('className' in $$props) $$invalidate(0, className = $$props.className);
	    if ('label' in $$props) $$invalidate(1, label = $$props.label);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
	    if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
	    if ('onInput' in $$props) $$invalidate(6, onInput = $$props.onInput);
	    if ('onFocus' in $$props) $$invalidate(7, onFocus = $$props.onFocus);
	    if ('onBlur' in $$props) $$invalidate(8, onBlur = $$props.onBlur);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [className, label, value, type, placeholder, rows, onInput, onFocus, onBlur];
	}

	class TextAreaField extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$13, create_fragment$13, safe_not_equal, {
	      className: 0,
	      label: 1,
	      value: 2,
	      type: 3,
	      placeholder: 4,
	      rows: 5,
	      onInput: 6,
	      onFocus: 7,
	      onBlur: 8
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "TextAreaField",
	      options,
	      id: create_fragment$13.name
	    });
	  }

	  get className() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set className(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get label() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set label(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get value() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set value(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get type() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set type(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get placeholder() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set placeholder(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get rows() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set rows(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onInput() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onInput(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onFocus() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onFocus(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onBlur() {
	    throw new Error("<TextAreaField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onBlur(value) {
	    throw new Error("<TextAreaField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$12 = "src/components/TextInputDialog.svelte";

	function create_fragment$12(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var textinputfield;
	  var current;
	  textinputfield = new TextInputField({
	    props: {
	      label: undefined,
	      placeholder:
	      /*placeholder*/
	      ctx[1],
	      value:
	      /*value*/
	      ctx[2],
	      type:
	      /*type*/
	      ctx[3],
	      onInput:
	      /*onInput*/
	      ctx[5],
	      onFocus: onFocus$1
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");
	      create_component(textinputfield.$$.fragment);
	      attr_dev(div0, "class", "kai-dialog-header svelte-dleobf");
	      add_location(div0, file$12, 98, 4, 2796);
	      attr_dev(div1, "class", "kai-dialog-body svelte-dleobf");
	      add_location(div1, file$12, 99, 4, 2845);
	      attr_dev(div2, "class", "kai-dialog-content svelte-dleobf");
	      add_location(div2, file$12, 97, 2, 2759);
	      attr_dev(div3, "class", "kai-dialog svelte-dleobf");
	      add_location(div3, file$12, 96, 0, 2712);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);
	      mount_component(textinputfield, div1, null);
	      /*div3_binding*/

	      ctx[16](div3);
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);
	      var textinputfield_changes = {};
	      if (dirty &
	      /*placeholder*/
	      2) textinputfield_changes.placeholder =
	      /*placeholder*/
	      ctx[1];
	      if (dirty &
	      /*value*/
	      4) textinputfield_changes.value =
	      /*value*/
	      ctx[2];
	      if (dirty &
	      /*type*/
	      8) textinputfield_changes.type =
	      /*type*/
	      ctx[3];
	      textinputfield.$set(textinputfield_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(textinputfield.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(textinputfield.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_component(textinputfield);
	      /*div3_binding*/

	      ctx[16](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$12.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function onFocus$1(evt) {
	  evt.target.focus();
	  evt.target.selectionStart = evt.target.selectionEnd = evt.target.value.length || evt.target.value.length;
	}

	function instance$12($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('TextInputDialog', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'TextInputDialog' : _$$props$title;
	  var _$$props$placeholder = $$props.placeholder,
	      placeholder = _$$props$placeholder === void 0 ? '' : _$$props$placeholder;
	  var _$$props$value = $$props.value,
	      value = _$$props$value === void 0 ? '' : _$$props$value;
	  var _$$props$type = $$props.type,
	      type = _$$props$type === void 0 ? 'text' : _$$props$type;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, value) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, value) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, value) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, value) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? value => {} : _$$props$onClosed;
	  var nodeRef;
	  var inputDOM;
	  var softwareKey;
	  var returnValue = '';

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    arrowUpListener(evt) {
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      //evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      //evt.preventDefault();
	      evt.stopPropagation();
	    },

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, returnValue);
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, returnValue);
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt, returnValue);
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, returnValue);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function onInput(evt) {
	    returnValue = evt.target.value;
	  }

	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    returnValue = value;
	    inputDOM = nodeRef.getElementsByTagName('INPUT')[0];
	    inputDOM.focus();
	    onOpened();
	  });
	  onDestroy(() => {
	    inputDOM.blur();
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed(returnValue);
	  });
	  var writable_props = ['title', 'placeholder', 'value', 'type', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInputDialog> was created with unknown prop '${key}'`);
	  });

	  function div3_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(4, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('softKeyLeftText' in $$props) $$invalidate(6, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(7, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(8, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(9, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(10, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(11, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(12, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(13, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(14, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    TextInputField,
	    title,
	    placeholder,
	    value,
	    type,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    nodeRef,
	    inputDOM,
	    softwareKey,
	    returnValue,
	    setTitleText,
	    navOptions,
	    navInstance,
	    onInput,
	    onFocus: onFocus$1
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('softKeyLeftText' in $$props) $$invalidate(6, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(7, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(8, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(9, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(10, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(11, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(12, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(13, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(14, onClosed = $$props.onClosed);
	    if ('nodeRef' in $$props) $$invalidate(4, nodeRef = $$props.nodeRef);
	    if ('inputDOM' in $$props) inputDOM = $$props.inputDOM;
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('returnValue' in $$props) returnValue = $$props.returnValue;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, placeholder, value, type, nodeRef, onInput, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText, div3_binding];
	}

	class TextInputDialog extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$12, create_fragment$12, safe_not_equal, {
	      title: 0,
	      placeholder: 1,
	      value: 2,
	      type: 3,
	      softKeyLeftText: 6,
	      softKeyCenterText: 7,
	      softKeyRightText: 8,
	      onEnter: 9,
	      onBackspace: 10,
	      onSoftkeyLeft: 11,
	      onSoftkeyRight: 12,
	      onOpened: 13,
	      onClosed: 14,
	      setTitleText: 15
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "TextInputDialog",
	      options,
	      id: create_fragment$12.name
	    });
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get placeholder() {
	    return this.$$.ctx[1];
	  }

	  set placeholder(placeholder) {
	    this.$$set({
	      placeholder
	    });
	    flush();
	  }

	  get value() {
	    return this.$$.ctx[2];
	  }

	  set value(value) {
	    this.$$set({
	      value
	    });
	    flush();
	  }

	  get type() {
	    return this.$$.ctx[3];
	  }

	  set type(type) {
	    this.$$set({
	      type
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[6];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[7];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[8];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[9];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[10];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[11];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[12];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[13];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[14];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[15];
	  }

	  set setTitleText(value) {
	    throw new Error("<TextInputDialog>: Cannot set read-only property 'setTitleText'");
	  }

	}

	var file$11 = "src/components/TextAreaDialog.svelte";

	function create_fragment$11(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var textareafield;
	  var current;
	  textareafield = new TextAreaField({
	    props: {
	      label: undefined,
	      placeholder:
	      /*placeholder*/
	      ctx[1],
	      rows:
	      /*rows*/
	      ctx[4],
	      value:
	      /*value*/
	      ctx[2],
	      type:
	      /*type*/
	      ctx[3],
	      onInput:
	      /*onInput*/
	      ctx[6],
	      onFocus
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");
	      create_component(textareafield.$$.fragment);
	      attr_dev(div0, "class", "kai-dialog-header svelte-dleobf");
	      add_location(div0, file$11, 97, 4, 2733);
	      attr_dev(div1, "class", "kai-dialog-body svelte-dleobf");
	      add_location(div1, file$11, 98, 4, 2782);
	      attr_dev(div2, "class", "kai-dialog-content svelte-dleobf");
	      add_location(div2, file$11, 96, 2, 2696);
	      attr_dev(div3, "class", "kai-dialog svelte-dleobf");
	      add_location(div3, file$11, 95, 0, 2650);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);
	      mount_component(textareafield, div1, null);
	      /*div3_binding*/

	      ctx[17](div3);
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);
	      var textareafield_changes = {};
	      if (dirty &
	      /*placeholder*/
	      2) textareafield_changes.placeholder =
	      /*placeholder*/
	      ctx[1];
	      if (dirty &
	      /*rows*/
	      16) textareafield_changes.rows =
	      /*rows*/
	      ctx[4];
	      if (dirty &
	      /*value*/
	      4) textareafield_changes.value =
	      /*value*/
	      ctx[2];
	      if (dirty &
	      /*type*/
	      8) textareafield_changes.type =
	      /*type*/
	      ctx[3];
	      textareafield.$set(textareafield_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(textareafield.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(textareafield.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_component(textareafield);
	      /*div3_binding*/

	      ctx[17](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$11.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function onFocus(evt) {
	  evt.target.focus();
	  evt.target.selectionStart = evt.target.selectionEnd = evt.target.value.length || evt.target.value.length;
	}

	function instance$11($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('TextAreaDialog', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'TextInputDialog' : _$$props$title;
	  var _$$props$placeholder = $$props.placeholder,
	      placeholder = _$$props$placeholder === void 0 ? '' : _$$props$placeholder;
	  var _$$props$value = $$props.value,
	      value = _$$props$value === void 0 ? '' : _$$props$value;
	  var _$$props$type = $$props.type,
	      type = _$$props$type === void 0 ? 'text' : _$$props$type;
	  var _$$props$rows = $$props.rows,
	      rows = _$$props$rows === void 0 ? 2 : _$$props$rows;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, value) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, value) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, value) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, value) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? value => {} : _$$props$onClosed;
	  var nodeRef;
	  var inputDOM;
	  var softwareKey;
	  var returnValue = '';

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    arrowUpListener(evt) {
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      evt.stopPropagation();
	    },

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, returnValue);
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, returnValue);
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt, returnValue);
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, returnValue);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function onInput(evt) {
	    returnValue = evt.target.value;
	  }

	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    returnValue = value;
	    inputDOM = nodeRef.getElementsByTagName('TEXTAREA')[0];
	    setTimeout(() => {
	      inputDOM.focus();
	    }, 200);
	    onOpened();
	  });
	  onDestroy(() => {
	    inputDOM.blur();
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed(returnValue);
	  });
	  var writable_props = ['title', 'placeholder', 'value', 'type', 'rows', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextAreaDialog> was created with unknown prop '${key}'`);
	  });

	  function div3_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(5, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
	    if ('softKeyLeftText' in $$props) $$invalidate(7, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(8, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(9, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(10, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(11, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(12, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(13, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(14, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(15, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    TextAreaField,
	    title,
	    placeholder,
	    value,
	    type,
	    rows,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    nodeRef,
	    inputDOM,
	    softwareKey,
	    returnValue,
	    setTitleText,
	    navOptions,
	    navInstance,
	    onInput,
	    onFocus
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
	    if ('value' in $$props) $$invalidate(2, value = $$props.value);
	    if ('type' in $$props) $$invalidate(3, type = $$props.type);
	    if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
	    if ('softKeyLeftText' in $$props) $$invalidate(7, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(8, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(9, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(10, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(11, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(12, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(13, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(14, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(15, onClosed = $$props.onClosed);
	    if ('nodeRef' in $$props) $$invalidate(5, nodeRef = $$props.nodeRef);
	    if ('inputDOM' in $$props) inputDOM = $$props.inputDOM;
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('returnValue' in $$props) returnValue = $$props.returnValue;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, placeholder, value, type, rows, nodeRef, onInput, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText, div3_binding];
	}

	class TextAreaDialog extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$11, create_fragment$11, safe_not_equal, {
	      title: 0,
	      placeholder: 1,
	      value: 2,
	      type: 3,
	      rows: 4,
	      softKeyLeftText: 7,
	      softKeyCenterText: 8,
	      softKeyRightText: 9,
	      onEnter: 10,
	      onBackspace: 11,
	      onSoftkeyLeft: 12,
	      onSoftkeyRight: 13,
	      onOpened: 14,
	      onClosed: 15,
	      setTitleText: 16
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "TextAreaDialog",
	      options,
	      id: create_fragment$11.name
	    });
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get placeholder() {
	    return this.$$.ctx[1];
	  }

	  set placeholder(placeholder) {
	    this.$$set({
	      placeholder
	    });
	    flush();
	  }

	  get value() {
	    return this.$$.ctx[2];
	  }

	  set value(value) {
	    this.$$set({
	      value
	    });
	    flush();
	  }

	  get type() {
	    return this.$$.ctx[3];
	  }

	  set type(type) {
	    this.$$set({
	      type
	    });
	    flush();
	  }

	  get rows() {
	    return this.$$.ctx[4];
	  }

	  set rows(rows) {
	    this.$$set({
	      rows
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[7];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[8];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[9];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[10];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[11];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[12];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[13];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[14];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[15];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[16];
	  }

	  set setTitleText(value) {
	    throw new Error("<TextAreaDialog>: Cannot set read-only property 'setTitleText'");
	  }

	}

	function cubicOut(t) {
	  var f = t - 1.0;
	  return f * f * f + 1.0;
	}

	function fade(node) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$delay = _ref2.delay,
	      delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
	      _ref2$duration = _ref2.duration,
	      duration = _ref2$duration === void 0 ? 400 : _ref2$duration,
	      _ref2$easing = _ref2.easing,
	      easing = _ref2$easing === void 0 ? identity : _ref2$easing;

	  var o = +getComputedStyle(node).opacity;
	  return {
	    delay,
	    duration,
	    easing,
	    css: t => `opacity: ${t * o}`
	  };
	}

	function fly(node) {
	  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref3$delay = _ref3.delay,
	      delay = _ref3$delay === void 0 ? 0 : _ref3$delay,
	      _ref3$duration = _ref3.duration,
	      duration = _ref3$duration === void 0 ? 400 : _ref3$duration,
	      _ref3$easing = _ref3.easing,
	      easing = _ref3$easing === void 0 ? cubicOut : _ref3$easing,
	      _ref3$x = _ref3.x,
	      x = _ref3$x === void 0 ? 0 : _ref3$x,
	      _ref3$y = _ref3.y,
	      y = _ref3$y === void 0 ? 0 : _ref3$y,
	      _ref3$opacity = _ref3.opacity,
	      opacity = _ref3$opacity === void 0 ? 0 : _ref3$opacity;

	  var style = getComputedStyle(node);
	  var target_opacity = +style.opacity;
	  var transform = style.transform === 'none' ? '' : style.transform;
	  var od = target_opacity * (1 - opacity);
	  return {
	    delay,
	    duration,
	    easing,
	    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
	  };
	}

	function flip(node, _ref) {
	  var from = _ref.from,
	      to = _ref.to;
	  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var style = getComputedStyle(node);
	  var transform = style.transform === 'none' ? '' : style.transform;

	  var _style$transformOrigi = style.transformOrigin.split(' ').map(parseFloat),
	      _style$transformOrigi2 = _slicedToArray(_style$transformOrigi, 2),
	      ox = _style$transformOrigi2[0],
	      oy = _style$transformOrigi2[1];

	  var dx = from.left + from.width * ox / to.width - (to.left + ox);
	  var dy = from.top + from.height * oy / to.height - (to.top + oy);
	  var _params$delay = params.delay,
	      delay = _params$delay === void 0 ? 0 : _params$delay,
	      _params$duration = params.duration,
	      duration = _params$duration === void 0 ? d => Math.sqrt(d) * 120 : _params$duration,
	      _params$easing = params.easing,
	      easing = _params$easing === void 0 ? cubicOut : _params$easing;
	  return {
	    delay,
	    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
	    easing,
	    css: (t, u) => {
	      var x = u * dx;
	      var y = u * dy;
	      var sx = t + u * from.width / to.width;
	      var sy = t + u * from.height / to.height;
	      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
	    }
	  };
	}

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var defaults = {
	  duration: 4000,
	  initial: 1,
	  next: 0,
	  pausable: false,
	  dismissable: true,
	  reversed: false,
	  intro: {
	    x: 256
	  },
	  theme: {}
	};

	var createToast = () => {
	  var _writable = writable([]),
	      subscribe = _writable.subscribe,
	      update = _writable.update;

	  var count = 0;
	  var options = {};

	  var _obj = obj => obj instanceof Object;

	  var push = function push(msg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var param = _objectSpread({
	      target: 'default'
	    }, _obj(msg) ? msg : _objectSpread(_objectSpread({}, opts), {}, {
	      msg
	    }));

	    var conf = options[param.target] || {};

	    var entry = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaults), conf), param), {}, {
	      theme: _objectSpread(_objectSpread({}, conf.theme), param.theme),
	      id: ++count
	    });

	    update(n => entry.reversed ? [...n, entry] : [entry, ...n]);
	    return count;
	  };

	  var pop = id => {
	    update(n => {
	      if (!n.length || id === 0) return [];
	      if (_obj(id)) return n.filter(i => id(i));
	      var target = id || Math.max(...n.map(i => i.id));
	      return n.filter(i => i.id !== target);
	    });
	  };

	  var set = function set(id) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var param = _obj(id) ? _objectSpread({}, id) : _objectSpread(_objectSpread({}, opts), {}, {
	      id
	    });
	    update(n => {
	      var idx = n.findIndex(i => i.id === param.id);

	      if (idx > -1) {
	        n[idx] = _objectSpread(_objectSpread({}, n[idx]), param);
	      }

	      return n;
	    });
	  };

	  var _init = function _init() {
	    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    options[target] = opts;
	    return options;
	  };

	  return {
	    subscribe,
	    push,
	    pop,
	    set,
	    _init
	  };
	};

	var toast = createToast();

	function is_date(obj) {
	  return Object.prototype.toString.call(obj) === '[object Date]';
	}

	function get_interpolator(a, b) {
	  if (a === b || a !== a) return () => a;
	  var type = typeof a;

	  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
	    throw new Error('Cannot interpolate values of different type');
	  }

	  if (Array.isArray(a)) {
	    var arr = b.map((bi, i) => {
	      return get_interpolator(a[i], bi);
	    });
	    return t => arr.map(fn => fn(t));
	  }

	  if (type === 'object') {
	    if (!a || !b) throw new Error('Object cannot be null');

	    if (is_date(a) && is_date(b)) {
	      a = a.getTime();
	      b = b.getTime();
	      var delta = b - a;
	      return t => new Date(a + t * delta);
	    }

	    var keys = Object.keys(b);
	    var interpolators = {};
	    keys.forEach(key => {
	      interpolators[key] = get_interpolator(a[key], b[key]);
	    });
	    return t => {
	      var result = {};
	      keys.forEach(key => {
	        result[key] = interpolators[key](t);
	      });
	      return result;
	    };
	  }

	  if (type === 'number') {
	    var _delta = b - a;

	    return t => a + t * _delta;
	  }

	  throw new Error(`Cannot interpolate ${type} values`);
	}

	function tweened(value) {
	  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var store = writable(value);
	  var task;
	  var target_value = value;

	  function set(new_value, opts) {
	    if (value == null) {
	      store.set(value = new_value);
	      return Promise.resolve();
	    }

	    target_value = new_value;
	    var previous_task = task;
	    var started = false;

	    var _assign = assign(assign({}, defaults), opts),
	        _assign$delay = _assign.delay,
	        delay = _assign$delay === void 0 ? 0 : _assign$delay,
	        _assign$duration = _assign.duration,
	        duration = _assign$duration === void 0 ? 400 : _assign$duration,
	        _assign$easing = _assign.easing,
	        easing = _assign$easing === void 0 ? identity : _assign$easing,
	        _assign$interpolate = _assign.interpolate,
	        interpolate = _assign$interpolate === void 0 ? get_interpolator : _assign$interpolate;

	    if (duration === 0) {
	      if (previous_task) {
	        previous_task.abort();
	        previous_task = null;
	      }

	      store.set(value = target_value);
	      return Promise.resolve();
	    }

	    var start = now() + delay;
	    var fn;
	    task = loop(now => {
	      if (now < start) return true;

	      if (!started) {
	        fn = interpolate(value, new_value);
	        if (typeof duration === 'function') duration = duration(value, new_value);
	        started = true;
	      }

	      if (previous_task) {
	        previous_task.abort();
	        previous_task = null;
	      }

	      var elapsed = now - start;

	      if (elapsed > duration) {
	        store.set(value = new_value);
	        return false;
	      } // @ts-ignore


	      store.set(value = fn(easing(elapsed / duration)));
	      return true;
	    });
	    return task.promise;
	  }

	  return {
	    set,
	    update: (fn, opts) => set(fn(target_value, value), opts),
	    subscribe: store.subscribe
	  };
	}

	var file$10 = "node_modules/@zerodevx/svelte-toast/src/ToastItem.svelte"; // (133:4) {:else}

	function create_else_block$5(ctx) {
	  var html_tag;
	  var raw_value =
	  /*item*/
	  ctx[0].msg + "";
	  var html_anchor;
	  var block = {
	    c: function create() {
	      html_tag = new HtmlTag();
	      html_anchor = empty();
	      html_tag.a = html_anchor;
	    },
	    m: function mount(target, anchor) {
	      html_tag.m(raw_value, target, anchor);
	      insert_dev(target, html_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*item*/
	      1 && raw_value !== (raw_value =
	      /*item*/
	      ctx[0].msg + "")) html_tag.p(raw_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(html_anchor);
	      if (detaching) html_tag.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$5.name,
	    type: "else",
	    source: "(133:4) {:else}",
	    ctx
	  });
	  return block;
	} // (131:4) {#if item.component}


	function create_if_block_1$9(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_instance_spread_levels = [
	  /*getProps*/
	  ctx[6]()];
	  var switch_value =
	  /*item*/
	  ctx[0].component.src;

	  function switch_props(ctx) {
	    var switch_instance_props = {};

	    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
	      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
	    }

	    return {
	      props: switch_instance_props,
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props());
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = dirty &
	      /*getProps*/
	      64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
	      /*getProps*/
	      ctx[6]())]) : {};

	      if (switch_value !== (switch_value =
	      /*item*/
	      ctx[0].component.src)) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$9.name,
	    type: "if",
	    source: "(131:4) {#if item.component}",
	    ctx
	  });
	  return block;
	} // (137:2) {#if item.dismissable}


	function create_if_block$d(ctx) {
	  var div;
	  var mounted;
	  var dispose;
	  var block = {
	    c: function create() {
	      div = element("div");
	      div.textContent = "";
	      attr_dev(div, "class", "_toastBtn pe svelte-j9nwjb");
	      attr_dev(div, "role", "button");
	      attr_dev(div, "tabindex", "-1");
	      add_location(div, file$10, 137, 4, 3576);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);

	      if (!mounted) {
	        dispose = listen_dev(div, "click",
	        /*close*/
	        ctx[3], false, false, false);
	        mounted = true;
	      }
	    },
	    p: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$d.name,
	    type: "if",
	    source: "(137:2) {#if item.dismissable}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$10(ctx) {
	  var div1;
	  var div0;
	  var current_block_type_index;
	  var if_block0;
	  var t0;
	  var t1;
	  var progress_1;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block_creators = [create_if_block_1$9, create_else_block$5];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*item*/
	    ctx[0].component) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  var if_block1 =
	  /*item*/
	  ctx[0].dismissable && create_if_block$d(ctx);
	  var block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      progress_1 = element("progress");
	      attr_dev(div0, "role", "status");
	      attr_dev(div0, "class", "_toastMsg svelte-j9nwjb");
	      toggle_class(div0, "pe",
	      /*item*/
	      ctx[0].component);
	      add_location(div0, file$10, 129, 2, 3335);
	      attr_dev(progress_1, "class", "_toastBar svelte-j9nwjb");
	      progress_1.value =
	      /*$progress*/
	      ctx[1];
	      add_location(progress_1, file$10, 139, 2, 3665);
	      attr_dev(div1, "class", "_toastItem svelte-j9nwjb");
	      toggle_class(div1, "pe",
	      /*item*/
	      ctx[0].pausable);
	      add_location(div1, file$10, 128, 0, 3238);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      if_blocks[current_block_type_index].m(div0, null);
	      append_dev(div1, t0);
	      if (if_block1) if_block1.m(div1, null);
	      append_dev(div1, t1);
	      append_dev(div1, progress_1);
	      current = true;

	      if (!mounted) {
	        dispose = [listen_dev(div1, "mouseenter",
	        /*pause*/
	        ctx[4], false, false, false), listen_dev(div1, "mouseleave",
	        /*resume*/
	        ctx[5], false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block0 = if_blocks[current_block_type_index];

	        if (!if_block0) {
	          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block0.c();
	        } else {
	          if_block0.p(ctx, dirty);
	        }

	        transition_in(if_block0, 1);
	        if_block0.m(div0, null);
	      }

	      if (dirty &
	      /*item*/
	      1) {
	        toggle_class(div0, "pe",
	        /*item*/
	        ctx[0].component);
	      }

	      if (
	      /*item*/
	      ctx[0].dismissable) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block$d(ctx);
	          if_block1.c();
	          if_block1.m(div1, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (!current || dirty &
	      /*$progress*/
	      2) {
	        prop_dev(progress_1, "value",
	        /*$progress*/
	        ctx[1]);
	      }

	      if (dirty &
	      /*item*/
	      1) {
	        toggle_class(div1, "pe",
	        /*item*/
	        ctx[0].pausable);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block0);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block0);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div1);
	      if_blocks[current_block_type_index].d();
	      if (if_block1) if_block1.d();
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$10.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$10($$self, $$props, $$invalidate) {
	  var $progress;
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('ToastItem', slots, []);
	  var item = $$props.item;
	  var progress = tweened(item.initial, {
	    duration: item.duration,
	    easing: identity
	  });
	  validate_store(progress, 'progress');
	  component_subscribe($$self, progress, value => $$invalidate(1, $progress = value));

	  var close = () => toast.pop(item.id);

	  var autoclose = () => {
	    if ($progress === 1 || $progress === 0) {
	      close();
	    }
	  };

	  var next = item.initial;
	  var prev = next;
	  var paused = false;

	  var pause = () => {
	    if (item.pausable && !paused && $progress !== next) {
	      progress.set($progress, {
	        duration: 0
	      });
	      paused = true;
	    }
	  };

	  var resume = () => {
	    if (paused) {
	      var d = item.duration;
	      var duration = d - d * (($progress - prev) / (next - prev));
	      progress.set(next, {
	        duration
	      }).then(autoclose);
	      paused = false;
	    }
	  };

	  var getProps = () => {
	    var _item$component = item.component,
	        _item$component$props = _item$component.props,
	        props = _item$component$props === void 0 ? {} : _item$component$props,
	        sendIdTo = _item$component.sendIdTo;

	    if (sendIdTo) {
	      props[sendIdTo] = item.id;
	    }

	    return props;
	  };

	  onDestroy(() => {
	    if (typeof item.onpop === 'function') {
	      item.onpop(item.id);
	    }
	  });
	  var writable_props = ['item'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToastItem> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('item' in $$props) $$invalidate(0, item = $$props.item);
	  };

	  $$self.$capture_state = () => ({
	    onDestroy,
	    tweened,
	    linear: identity,
	    toast,
	    item,
	    progress,
	    close,
	    autoclose,
	    next,
	    prev,
	    paused,
	    pause,
	    resume,
	    getProps,
	    $progress
	  });

	  $$self.$inject_state = $$props => {
	    if ('item' in $$props) $$invalidate(0, item = $$props.item);
	    if ('next' in $$props) $$invalidate(7, next = $$props.next);
	    if ('prev' in $$props) prev = $$props.prev;
	    if ('paused' in $$props) paused = $$props.paused;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  $$self.$$.update = () => {
	    if ($$self.$$.dirty &
	    /*item*/
	    1) {
	      // `progress` has been renamed to `next`; shim included for backward compatibility, to remove in next major
	      if (typeof item.progress !== 'undefined') {
	        $$invalidate(0, item.next = item.progress, item);
	      }
	    }

	    if ($$self.$$.dirty &
	    /*next, item, $progress*/
	    131) {
	      if (next !== item.next) {
	        $$invalidate(7, next = item.next);
	        prev = $progress;
	        paused = false;
	        progress.set(next).then(autoclose);
	      }
	    }
	  };

	  return [item, $progress, progress, close, pause, resume, getProps, next];
	}

	class ToastItem extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$10, create_fragment$10, safe_not_equal, {
	      item: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ToastItem",
	      options,
	      id: create_fragment$10.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*item*/
	    ctx[0] === undefined && !('item' in props)) {
	      console.warn("<ToastItem> was created without expected prop 'item'");
	    }
	  }

	  get item() {
	    throw new Error("<ToastItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set item(value) {
	    throw new Error("<ToastItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Object_1$1 = globals.Object;
	var file$$ = "node_modules/@zerodevx/svelte-toast/src/SvelteToast.svelte";

	function get_each_context$5(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[5] = list[i];
	  return child_ctx;
	} // (34:2) {#each items as item (item.id)}


	function create_each_block$5(key_1, ctx) {
	  var li;
	  var toastitem;
	  var t;
	  var li_style_value;
	  var li_intro;
	  var li_outro;
	  var rect;
	  var stop_animation = noop;
	  var current;
	  toastitem = new ToastItem({
	    props: {
	      item:
	      /*item*/
	      ctx[5]
	    },
	    $$inline: true
	  });
	  var block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      li = element("li");
	      create_component(toastitem.$$.fragment);
	      t = space();
	      attr_dev(li, "style", li_style_value =
	      /*getCss*/
	      ctx[1](
	      /*item*/
	      ctx[5].theme));
	      add_location(li, file$$, 34, 4, 815);
	      this.first = li;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, li, anchor);
	      mount_component(toastitem, li, null);
	      append_dev(li, t);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      var toastitem_changes = {};
	      if (dirty &
	      /*items*/
	      1) toastitem_changes.item =
	      /*item*/
	      ctx[5];
	      toastitem.$set(toastitem_changes);

	      if (!current || dirty &
	      /*items*/
	      1 && li_style_value !== (li_style_value =
	      /*getCss*/
	      ctx[1](
	      /*item*/
	      ctx[5].theme))) {
	        attr_dev(li, "style", li_style_value);
	      }
	    },
	    r: function measure() {
	      rect = li.getBoundingClientRect();
	    },
	    f: function fix() {
	      fix_position(li);
	      stop_animation();
	      add_transform(li, rect);
	    },
	    a: function animate() {
	      stop_animation();
	      stop_animation = create_animation(li, rect, flip, {
	        duration: 200
	      });
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(toastitem.$$.fragment, local);
	      add_render_callback(() => {
	        if (li_outro) li_outro.end(1);
	        li_intro = create_in_transition(li, fly,
	        /*item*/
	        ctx[5].intro);
	        li_intro.start();
	      });
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(toastitem.$$.fragment, local);
	      if (li_intro) li_intro.invalidate();
	      li_outro = create_out_transition(li, fade, {});
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(li);
	      destroy_component(toastitem);
	      if (detaching && li_outro) li_outro.end();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$5.name,
	    type: "each",
	    source: "(34:2) {#each items as item (item.id)}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$$(ctx) {
	  var ul;
	  var each_blocks = [];
	  var each_1_lookup = new Map();
	  var current;
	  var each_value =
	  /*items*/
	  ctx[0];
	  validate_each_argument(each_value);

	  var get_key = ctx =>
	  /*item*/
	  ctx[5].id;

	  validate_each_keys(ctx, each_value, get_each_context$5, get_key);

	  for (var i = 0; i < each_value.length; i += 1) {
	    var child_ctx = get_each_context$5(ctx, each_value, i);
	    var key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	  }

	  var block = {
	    c: function create() {
	      ul = element("ul");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(ul, "class", "_toastContainer svelte-7xr3c1");
	      add_location(ul, file$$, 32, 0, 748);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, ul, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(ul, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*getCss, items*/
	      3) {
	        each_value =
	        /*items*/
	        ctx[0];
	        validate_each_argument(each_value);
	        group_outros();

	        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].r();
	        }

	        validate_each_keys(ctx, each_value, get_each_context$5, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block$5, null, get_each_context$5);

	        for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	          each_blocks[_i4].a();
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {
	        transition_in(each_blocks[_i5]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {
	        transition_out(each_blocks[_i6]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(ul);

	      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
	        each_blocks[_i7].d();
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$$.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$$($$self, $$props, $$invalidate) {
	  var $toast;
	  validate_store(toast, 'toast');
	  component_subscribe($$self, toast, $$value => $$invalidate(4, $toast = $$value));
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('SvelteToast', slots, []);
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var _$$props$target = $$props.target,
	      target = _$$props$target === void 0 ? 'default' : _$$props$target;
	  var items;

	  var getCss = theme => Object.keys(theme).reduce((a, c) => `${a}${c}:${theme[c]};`, '');

	  var writable_props = ['options', 'target'];
	  Object_1$1.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SvelteToast> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('options' in $$props) $$invalidate(2, options = $$props.options);
	    if ('target' in $$props) $$invalidate(3, target = $$props.target);
	  };

	  $$self.$capture_state = () => ({
	    fade,
	    fly,
	    flip,
	    toast,
	    ToastItem,
	    options,
	    target,
	    items,
	    getCss,
	    $toast
	  });

	  $$self.$inject_state = $$props => {
	    if ('options' in $$props) $$invalidate(2, options = $$props.options);
	    if ('target' in $$props) $$invalidate(3, target = $$props.target);
	    if ('items' in $$props) $$invalidate(0, items = $$props.items);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  $$self.$$.update = () => {
	    if ($$self.$$.dirty &
	    /*target, options*/
	    12) {
	      toast._init(target, options);
	    }

	    if ($$self.$$.dirty &
	    /*$toast, target*/
	    24) {
	      $$invalidate(0, items = $toast.filter(i => i.target === target));
	    }
	  };

	  return [items, getCss, options, target, $toast];
	}

	class SvelteToast extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$$, create_fragment$$, safe_not_equal, {
	      options: 2,
	      target: 3
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "SvelteToast",
	      options,
	      id: create_fragment$$.name
	    });
	  }

	  get options() {
	    throw new Error("<SvelteToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set options(value) {
	    throw new Error("<SvelteToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get target() {
	    throw new Error("<SvelteToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set target(value) {
	    throw new Error("<SvelteToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* eslint-disable @typescript-eslint/strict-boolean-expressions */

	function parse(string, encoding, opts) {
	  var _opts$out;

	  if (opts === void 0) {
	    opts = {};
	  } // Build the character lookup table:


	  if (!encoding.codes) {
	    encoding.codes = {};

	    for (var i = 0; i < encoding.chars.length; ++i) {
	      encoding.codes[encoding.chars[i]] = i;
	    }
	  } // The string must have a whole number of bytes:


	  if (!opts.loose && string.length * encoding.bits & 7) {
	    throw new SyntaxError('Invalid padding');
	  } // Count the padding bytes:


	  var end = string.length;

	  while (string[end - 1] === '=') {
	    --end; // If we get a whole number of bytes, there is too much padding:

	    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
	      throw new SyntaxError('Invalid padding');
	    }
	  } // Allocate the output:


	  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:

	  var bits = 0; // Number of bits currently in the buffer

	  var buffer = 0; // Bits waiting to be written out, MSB first

	  var written = 0; // Next byte to write

	  for (var _i = 0; _i < end; ++_i) {
	    // Read one character from the string:
	    var value = encoding.codes[string[_i]];

	    if (value === undefined) {
	      throw new SyntaxError('Invalid character ' + string[_i]);
	    } // Append the bits to the buffer:


	    buffer = buffer << encoding.bits | value;
	    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:

	    if (bits >= 8) {
	      bits -= 8;
	      out[written++] = 0xff & buffer >> bits;
	    }
	  } // Verify that we have received just enough bits:


	  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {
	    throw new SyntaxError('Unexpected end of data');
	  }

	  return out;
	}

	function stringify(data, encoding, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var _opts = opts,
	      _opts$pad = _opts.pad,
	      pad = _opts$pad === void 0 ? true : _opts$pad;
	  var mask = (1 << encoding.bits) - 1;
	  var out = '';
	  var bits = 0; // Number of bits currently in the buffer

	  var buffer = 0; // Bits waiting to be written out, MSB first

	  for (var i = 0; i < data.length; ++i) {
	    // Slurp data into the buffer:
	    buffer = buffer << 8 | 0xff & data[i];
	    bits += 8; // Write out as much as we can:

	    while (bits > encoding.bits) {
	      bits -= encoding.bits;
	      out += encoding.chars[mask & buffer >> bits];
	    }
	  } // Partial character:


	  if (bits) {
	    out += encoding.chars[mask & buffer << encoding.bits - bits];
	  } // Add padding characters until we hit a byte boundary:


	  if (pad) {
	    while (out.length * encoding.bits & 7) {
	      out += '=';
	    }
	  }

	  return out;
	}
	/* eslint-disable @typescript-eslint/strict-boolean-expressions */


	var base16Encoding = {
	  chars: '0123456789ABCDEF',
	  bits: 4
	};
	var base32Encoding = {
	  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
	  bits: 5
	};
	var base32HexEncoding = {
	  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
	  bits: 5
	};
	var base64Encoding = {
	  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
	  bits: 6
	};
	var base64UrlEncoding = {
	  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
	  bits: 6
	};
	var base16 = {
	  parse: function parse$1(string, opts) {
	    return parse(string.toUpperCase(), base16Encoding, opts);
	  },
	  stringify: function stringify$1(data, opts) {
	    return stringify(data, base16Encoding, opts);
	  }
	};
	var base32 = {
	  parse: function parse$1(string, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);
	  },
	  stringify: function stringify$1(data, opts) {
	    return stringify(data, base32Encoding, opts);
	  }
	};
	var base32hex = {
	  parse: function parse$1(string, opts) {
	    return parse(string, base32HexEncoding, opts);
	  },
	  stringify: function stringify$1(data, opts) {
	    return stringify(data, base32HexEncoding, opts);
	  }
	};
	var base64 = {
	  parse: function parse$1(string, opts) {
	    return parse(string, base64Encoding, opts);
	  },
	  stringify: function stringify$1(data, opts) {
	    return stringify(data, base64Encoding, opts);
	  }
	};
	var base64url$1 = {
	  parse: function parse$1(string, opts) {
	    return parse(string, base64UrlEncoding, opts);
	  },
	  stringify: function stringify$1(data, opts) {
	    return stringify(data, base64UrlEncoding, opts);
	  }
	};
	var codec = {
	  parse: parse,
	  stringify: stringify
	};
	var base16_1 = base16;
	var base32_1 = base32;
	var base32hex_1 = base32hex;
	var base64_1 = base64;
	var base64url_1 = base64url$1;
	var codec_1 = codec;
	var lib = /*#__PURE__*/Object.defineProperty({
	  base16: base16_1,
	  base32: base32_1,
	  base32hex: base32hex_1,
	  base64: base64_1,
	  base64url: base64url_1,
	  codec: codec_1
	}, '__esModule', {
	  value: true
	});

	// Generated by rollup-plugin-mjs-entry
	lib.base16;
	lib.base32;
	lib.base32hex;
	lib.base64;
	var base64url = lib.base64url;
	lib.codec;

	var byteLength_1 = byteLength;
	var toByteArray_1 = toByteArray;
	var fromByteArray_1 = fromByteArray;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	} // Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications


	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens(b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4');
	  } // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42


	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;
	  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
	  return [validLen, placeHoldersLen];
	} // base64 is 4/3 + up to two characters of the original data


	function byteLength(b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}

	function _byteLength(b64, validLen, placeHoldersLen) {
	  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}

	function toByteArray(b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
	  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

	  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
	  var i;

	  for (i = 0; i < len; i += 4) {
	    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = tmp >> 16 & 0xFF;
	    arr[curByte++] = tmp >> 8 & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
	    arr[curByte++] = tmp >> 8 & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr;
	}

	function tripletToBase64(num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
	}

	function encodeChunk(uint8, start, end) {
	  var tmp;
	  var output = [];

	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }

	  return output.join('');
	}

	function fromByteArray(uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3
	  // go through the array every three bytes, we'll deal with trailing stuff later

	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
	  } // pad the end with zeros, but make sure to not forget the extra bytes


	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
	  }

	  return parts.join('');
	}

	var base64Js = {
	  byteLength: byteLength_1,
	  toByteArray: toByteArray_1,
	  fromByteArray: fromByteArray_1
	};

	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var read = function read(buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? nBytes - 1 : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];
	  i += d;
	  e = s & (1 << -nBits) - 1;
	  s >>= -nBits;
	  nBits += eLen;

	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;

	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : (s ? -1 : 1) * Infinity;
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }

	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	var write = function write(buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	  var i = isLE ? 0 : nBytes - 1;
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);

	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }

	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }

	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = e << mLen | m;
	  eLen += mLen;

	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};

	var ieee754 = {
	  read: read,
	  write: write
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */
	var buffer = createCommonjsModule(function (module, exports) {

	  var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
	  ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
	  : null;
	  exports.Buffer = Buffer;
	  exports.SlowBuffer = SlowBuffer;
	  exports.INSPECT_MAX_BYTES = 50;
	  var K_MAX_LENGTH = 0x7fffffff;
	  exports.kMaxLength = K_MAX_LENGTH;
	  /**
	   * If `Buffer.TYPED_ARRAY_SUPPORT`:
	   *   === true    Use Uint8Array implementation (fastest)
	   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
	   *               implementation (most compatible, even IE6)
	   *
	   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	   * Opera 11.6+, iOS 4.2+.
	   *
	   * We report that the browser does not support typed arrays if the are not subclassable
	   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
	   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
	   * for __proto__ and has a buggy typed array implementation.
	   */

	  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

	  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
	  }

	  function typedArraySupport() {
	    // Can typed array instances can be augmented?
	    try {
	      var arr = new Uint8Array(1);
	      var proto = {
	        foo: function foo() {
	          return 42;
	        }
	      };
	      Object.setPrototypeOf(proto, Uint8Array.prototype);
	      Object.setPrototypeOf(arr, proto);
	      return arr.foo() === 42;
	    } catch (e) {
	      return false;
	    }
	  }

	  Object.defineProperty(Buffer.prototype, 'parent', {
	    enumerable: true,
	    get: function get() {
	      if (!Buffer.isBuffer(this)) return undefined;
	      return this.buffer;
	    }
	  });
	  Object.defineProperty(Buffer.prototype, 'offset', {
	    enumerable: true,
	    get: function get() {
	      if (!Buffer.isBuffer(this)) return undefined;
	      return this.byteOffset;
	    }
	  });

	  function createBuffer(length) {
	    if (length > K_MAX_LENGTH) {
	      throw new RangeError('The value "' + length + '" is invalid for option "size"');
	    } // Return an augmented `Uint8Array` instance


	    var buf = new Uint8Array(length);
	    Object.setPrototypeOf(buf, Buffer.prototype);
	    return buf;
	  }
	  /**
	   * The Buffer constructor returns instances of `Uint8Array` that have their
	   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	   * returns a single octet.
	   *
	   * The `Uint8Array` prototype remains unmodified.
	   */


	  function Buffer(arg, encodingOrOffset, length) {
	    // Common case.
	    if (typeof arg === 'number') {
	      if (typeof encodingOrOffset === 'string') {
	        throw new TypeError('The "string" argument must be of type string. Received type number');
	      }

	      return allocUnsafe(arg);
	    }

	    return from(arg, encodingOrOffset, length);
	  }

	  Buffer.poolSize = 8192; // not used by this implementation

	  function from(value, encodingOrOffset, length) {
	    if (typeof value === 'string') {
	      return fromString(value, encodingOrOffset);
	    }

	    if (ArrayBuffer.isView(value)) {
	      return fromArrayView(value);
	    }

	    if (value == null) {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
	    }

	    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
	      return fromArrayBuffer(value, encodingOrOffset, length);
	    }

	    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
	      return fromArrayBuffer(value, encodingOrOffset, length);
	    }

	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type number');
	    }

	    var valueOf = value.valueOf && value.valueOf();

	    if (valueOf != null && valueOf !== value) {
	      return Buffer.from(valueOf, encodingOrOffset, length);
	    }

	    var b = fromObject(value);
	    if (b) return b;

	    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
	      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
	    }

	    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
	  }
	  /**
	   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	   * if value is a number.
	   * Buffer.from(str[, encoding])
	   * Buffer.from(array)
	   * Buffer.from(buffer)
	   * Buffer.from(arrayBuffer[, byteOffset[, length]])
	   **/


	  Buffer.from = function (value, encodingOrOffset, length) {
	    return from(value, encodingOrOffset, length);
	  }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
	  // https://github.com/feross/buffer/pull/148


	  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
	  Object.setPrototypeOf(Buffer, Uint8Array);

	  function assertSize(size) {
	    if (typeof size !== 'number') {
	      throw new TypeError('"size" argument must be of type number');
	    } else if (size < 0) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"');
	    }
	  }

	  function alloc(size, fill, encoding) {
	    assertSize(size);

	    if (size <= 0) {
	      return createBuffer(size);
	    }

	    if (fill !== undefined) {
	      // Only pay attention to encoding if it's a string. This
	      // prevents accidentally sending in a number that would
	      // be interpreted as a start offset.
	      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
	    }

	    return createBuffer(size);
	  }
	  /**
	   * Creates a new filled Buffer instance.
	   * alloc(size[, fill[, encoding]])
	   **/


	  Buffer.alloc = function (size, fill, encoding) {
	    return alloc(size, fill, encoding);
	  };

	  function allocUnsafe(size) {
	    assertSize(size);
	    return createBuffer(size < 0 ? 0 : checked(size) | 0);
	  }
	  /**
	   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	   * */


	  Buffer.allocUnsafe = function (size) {
	    return allocUnsafe(size);
	  };
	  /**
	   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	   */


	  Buffer.allocUnsafeSlow = function (size) {
	    return allocUnsafe(size);
	  };

	  function fromString(string, encoding) {
	    if (typeof encoding !== 'string' || encoding === '') {
	      encoding = 'utf8';
	    }

	    if (!Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding);
	    }

	    var length = byteLength(string, encoding) | 0;
	    var buf = createBuffer(length);
	    var actual = buf.write(string, encoding);

	    if (actual !== length) {
	      // Writing a hex string, for example, that contains invalid characters will
	      // cause everything after the first invalid character to be ignored. (e.g.
	      // 'abxxcd' will be treated as 'ab')
	      buf = buf.slice(0, actual);
	    }

	    return buf;
	  }

	  function fromArrayLike(array) {
	    var length = array.length < 0 ? 0 : checked(array.length) | 0;
	    var buf = createBuffer(length);

	    for (var i = 0; i < length; i += 1) {
	      buf[i] = array[i] & 255;
	    }

	    return buf;
	  }

	  function fromArrayView(arrayView) {
	    if (isInstance(arrayView, Uint8Array)) {
	      var copy = new Uint8Array(arrayView);
	      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
	    }

	    return fromArrayLike(arrayView);
	  }

	  function fromArrayBuffer(array, byteOffset, length) {
	    if (byteOffset < 0 || array.byteLength < byteOffset) {
	      throw new RangeError('"offset" is outside of buffer bounds');
	    }

	    if (array.byteLength < byteOffset + (length || 0)) {
	      throw new RangeError('"length" is outside of buffer bounds');
	    }

	    var buf;

	    if (byteOffset === undefined && length === undefined) {
	      buf = new Uint8Array(array);
	    } else if (length === undefined) {
	      buf = new Uint8Array(array, byteOffset);
	    } else {
	      buf = new Uint8Array(array, byteOffset, length);
	    } // Return an augmented `Uint8Array` instance


	    Object.setPrototypeOf(buf, Buffer.prototype);
	    return buf;
	  }

	  function fromObject(obj) {
	    if (Buffer.isBuffer(obj)) {
	      var len = checked(obj.length) | 0;
	      var buf = createBuffer(len);

	      if (buf.length === 0) {
	        return buf;
	      }

	      obj.copy(buf, 0, 0, len);
	      return buf;
	    }

	    if (obj.length !== undefined) {
	      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
	        return createBuffer(0);
	      }

	      return fromArrayLike(obj);
	    }

	    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
	      return fromArrayLike(obj.data);
	    }
	  }

	  function checked(length) {
	    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
	    // length is NaN (which is otherwise coerced to zero.)
	    if (length >= K_MAX_LENGTH) {
	      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
	    }

	    return length | 0;
	  }

	  function SlowBuffer(length) {
	    if (+length != length) {
	      // eslint-disable-line eqeqeq
	      length = 0;
	    }

	    return Buffer.alloc(+length);
	  }

	  Buffer.isBuffer = function isBuffer(b) {
	    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
	  };

	  Buffer.compare = function compare(a, b) {
	    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
	    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

	    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
	    }

	    if (a === b) return 0;
	    var x = a.length;
	    var y = b.length;

	    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	      if (a[i] !== b[i]) {
	        x = a[i];
	        y = b[i];
	        break;
	      }
	    }

	    if (x < y) return -1;
	    if (y < x) return 1;
	    return 0;
	  };

	  Buffer.isEncoding = function isEncoding(encoding) {
	    switch (String(encoding).toLowerCase()) {
	      case 'hex':
	      case 'utf8':
	      case 'utf-8':
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	      case 'base64':
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return true;

	      default:
	        return false;
	    }
	  };

	  Buffer.concat = function concat(list, length) {
	    if (!Array.isArray(list)) {
	      throw new TypeError('"list" argument must be an Array of Buffers');
	    }

	    if (list.length === 0) {
	      return Buffer.alloc(0);
	    }

	    var i;

	    if (length === undefined) {
	      length = 0;

	      for (i = 0; i < list.length; ++i) {
	        length += list[i].length;
	      }
	    }

	    var buffer = Buffer.allocUnsafe(length);
	    var pos = 0;

	    for (i = 0; i < list.length; ++i) {
	      var buf = list[i];

	      if (isInstance(buf, Uint8Array)) {
	        if (pos + buf.length > buffer.length) {
	          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
	          buf.copy(buffer, pos);
	        } else {
	          Uint8Array.prototype.set.call(buffer, buf, pos);
	        }
	      } else if (!Buffer.isBuffer(buf)) {
	        throw new TypeError('"list" argument must be an Array of Buffers');
	      } else {
	        buf.copy(buffer, pos);
	      }

	      pos += buf.length;
	    }

	    return buffer;
	  };

	  function byteLength(string, encoding) {
	    if (Buffer.isBuffer(string)) {
	      return string.length;
	    }

	    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
	      return string.byteLength;
	    }

	    if (typeof string !== 'string') {
	      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
	    }

	    var len = string.length;
	    var mustMatch = arguments.length > 2 && arguments[2] === true;
	    if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

	    var loweredCase = false;

	    for (;;) {
	      switch (encoding) {
	        case 'ascii':
	        case 'latin1':
	        case 'binary':
	          return len;

	        case 'utf8':
	        case 'utf-8':
	          return utf8ToBytes(string).length;

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return len * 2;

	        case 'hex':
	          return len >>> 1;

	        case 'base64':
	          return base64ToBytes(string).length;

	        default:
	          if (loweredCase) {
	            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
	          }

	          encoding = ('' + encoding).toLowerCase();
	          loweredCase = true;
	      }
	    }
	  }

	  Buffer.byteLength = byteLength;

	  function slowToString(encoding, start, end) {
	    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	    // property of a typed array.
	    // This behaves neither like String nor Uint8Array in that we set start/end
	    // to their upper/lower bounds if the value passed is out of range.
	    // undefined is handled specially as per ECMA-262 6th Edition,
	    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

	    if (start === undefined || start < 0) {
	      start = 0;
	    } // Return early if start > this.length. Done here to prevent potential uint32
	    // coercion fail below.


	    if (start > this.length) {
	      return '';
	    }

	    if (end === undefined || end > this.length) {
	      end = this.length;
	    }

	    if (end <= 0) {
	      return '';
	    } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


	    end >>>= 0;
	    start >>>= 0;

	    if (end <= start) {
	      return '';
	    }

	    if (!encoding) encoding = 'utf8';

	    while (true) {
	      switch (encoding) {
	        case 'hex':
	          return hexSlice(this, start, end);

	        case 'utf8':
	        case 'utf-8':
	          return utf8Slice(this, start, end);

	        case 'ascii':
	          return asciiSlice(this, start, end);

	        case 'latin1':
	        case 'binary':
	          return latin1Slice(this, start, end);

	        case 'base64':
	          return base64Slice(this, start, end);

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return utf16leSlice(this, start, end);

	        default:
	          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	          encoding = (encoding + '').toLowerCase();
	          loweredCase = true;
	      }
	    }
	  } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
	  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
	  // reliably in a browserify context because there could be multiple different
	  // copies of the 'buffer' package in use. This method works even for Buffer
	  // instances that were created from another copy of the `buffer` package.
	  // See: https://github.com/feross/buffer/issues/154


	  Buffer.prototype._isBuffer = true;

	  function swap(b, n, m) {
	    var i = b[n];
	    b[n] = b[m];
	    b[m] = i;
	  }

	  Buffer.prototype.swap16 = function swap16() {
	    var len = this.length;

	    if (len % 2 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 16-bits');
	    }

	    for (var i = 0; i < len; i += 2) {
	      swap(this, i, i + 1);
	    }

	    return this;
	  };

	  Buffer.prototype.swap32 = function swap32() {
	    var len = this.length;

	    if (len % 4 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 32-bits');
	    }

	    for (var i = 0; i < len; i += 4) {
	      swap(this, i, i + 3);
	      swap(this, i + 1, i + 2);
	    }

	    return this;
	  };

	  Buffer.prototype.swap64 = function swap64() {
	    var len = this.length;

	    if (len % 8 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 64-bits');
	    }

	    for (var i = 0; i < len; i += 8) {
	      swap(this, i, i + 7);
	      swap(this, i + 1, i + 6);
	      swap(this, i + 2, i + 5);
	      swap(this, i + 3, i + 4);
	    }

	    return this;
	  };

	  Buffer.prototype.toString = function toString() {
	    var length = this.length;
	    if (length === 0) return '';
	    if (arguments.length === 0) return utf8Slice(this, 0, length);
	    return slowToString.apply(this, arguments);
	  };

	  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

	  Buffer.prototype.equals = function equals(b) {
	    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
	    if (this === b) return true;
	    return Buffer.compare(this, b) === 0;
	  };

	  Buffer.prototype.inspect = function inspect() {
	    var str = '';
	    var max = exports.INSPECT_MAX_BYTES;
	    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
	    if (this.length > max) str += ' ... ';
	    return '<Buffer ' + str + '>';
	  };

	  if (customInspectSymbol) {
	    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
	  }

	  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
	    if (isInstance(target, Uint8Array)) {
	      target = Buffer.from(target, target.offset, target.byteLength);
	    }

	    if (!Buffer.isBuffer(target)) {
	      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
	    }

	    if (start === undefined) {
	      start = 0;
	    }

	    if (end === undefined) {
	      end = target ? target.length : 0;
	    }

	    if (thisStart === undefined) {
	      thisStart = 0;
	    }

	    if (thisEnd === undefined) {
	      thisEnd = this.length;
	    }

	    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	      throw new RangeError('out of range index');
	    }

	    if (thisStart >= thisEnd && start >= end) {
	      return 0;
	    }

	    if (thisStart >= thisEnd) {
	      return -1;
	    }

	    if (start >= end) {
	      return 1;
	    }

	    start >>>= 0;
	    end >>>= 0;
	    thisStart >>>= 0;
	    thisEnd >>>= 0;
	    if (this === target) return 0;
	    var x = thisEnd - thisStart;
	    var y = end - start;
	    var len = Math.min(x, y);
	    var thisCopy = this.slice(thisStart, thisEnd);
	    var targetCopy = target.slice(start, end);

	    for (var i = 0; i < len; ++i) {
	      if (thisCopy[i] !== targetCopy[i]) {
	        x = thisCopy[i];
	        y = targetCopy[i];
	        break;
	      }
	    }

	    if (x < y) return -1;
	    if (y < x) return 1;
	    return 0;
	  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	  //
	  // Arguments:
	  // - buffer - a Buffer to search
	  // - val - a string, Buffer, or number
	  // - byteOffset - an index into `buffer`; will be clamped to an int32
	  // - encoding - an optional encoding, relevant is val is a string
	  // - dir - true for indexOf, false for lastIndexOf


	  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
	    // Empty buffer means no match
	    if (buffer.length === 0) return -1; // Normalize byteOffset

	    if (typeof byteOffset === 'string') {
	      encoding = byteOffset;
	      byteOffset = 0;
	    } else if (byteOffset > 0x7fffffff) {
	      byteOffset = 0x7fffffff;
	    } else if (byteOffset < -0x80000000) {
	      byteOffset = -0x80000000;
	    }

	    byteOffset = +byteOffset; // Coerce to Number.

	    if (numberIsNaN(byteOffset)) {
	      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	      byteOffset = dir ? 0 : buffer.length - 1;
	    } // Normalize byteOffset: negative offsets start from the end of the buffer


	    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

	    if (byteOffset >= buffer.length) {
	      if (dir) return -1;else byteOffset = buffer.length - 1;
	    } else if (byteOffset < 0) {
	      if (dir) byteOffset = 0;else return -1;
	    } // Normalize val


	    if (typeof val === 'string') {
	      val = Buffer.from(val, encoding);
	    } // Finally, search either indexOf (if dir is true) or lastIndexOf


	    if (Buffer.isBuffer(val)) {
	      // Special case: looking for empty string/buffer always fails
	      if (val.length === 0) {
	        return -1;
	      }

	      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
	    } else if (typeof val === 'number') {
	      val = val & 0xFF; // Search for a byte value [0-255]

	      if (typeof Uint8Array.prototype.indexOf === 'function') {
	        if (dir) {
	          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
	        } else {
	          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
	        }
	      }

	      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
	    }

	    throw new TypeError('val must be string, number or Buffer');
	  }

	  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
	    var indexSize = 1;
	    var arrLength = arr.length;
	    var valLength = val.length;

	    if (encoding !== undefined) {
	      encoding = String(encoding).toLowerCase();

	      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
	        if (arr.length < 2 || val.length < 2) {
	          return -1;
	        }

	        indexSize = 2;
	        arrLength /= 2;
	        valLength /= 2;
	        byteOffset /= 2;
	      }
	    }

	    function read(buf, i) {
	      if (indexSize === 1) {
	        return buf[i];
	      } else {
	        return buf.readUInt16BE(i * indexSize);
	      }
	    }

	    var i;

	    if (dir) {
	      var foundIndex = -1;

	      for (i = byteOffset; i < arrLength; i++) {
	        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	          if (foundIndex === -1) foundIndex = i;
	          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
	        } else {
	          if (foundIndex !== -1) i -= i - foundIndex;
	          foundIndex = -1;
	        }
	      }
	    } else {
	      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

	      for (i = byteOffset; i >= 0; i--) {
	        var found = true;

	        for (var j = 0; j < valLength; j++) {
	          if (read(arr, i + j) !== read(val, j)) {
	            found = false;
	            break;
	          }
	        }

	        if (found) return i;
	      }
	    }

	    return -1;
	  }

	  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
	    return this.indexOf(val, byteOffset, encoding) !== -1;
	  };

	  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
	    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
	  };

	  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
	    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
	  };

	  function hexWrite(buf, string, offset, length) {
	    offset = Number(offset) || 0;
	    var remaining = buf.length - offset;

	    if (!length) {
	      length = remaining;
	    } else {
	      length = Number(length);

	      if (length > remaining) {
	        length = remaining;
	      }
	    }

	    var strLen = string.length;

	    if (length > strLen / 2) {
	      length = strLen / 2;
	    }

	    var i;

	    for (i = 0; i < length; ++i) {
	      var parsed = parseInt(string.substr(i * 2, 2), 16);
	      if (numberIsNaN(parsed)) return i;
	      buf[offset + i] = parsed;
	    }

	    return i;
	  }

	  function utf8Write(buf, string, offset, length) {
	    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
	  }

	  function asciiWrite(buf, string, offset, length) {
	    return blitBuffer(asciiToBytes(string), buf, offset, length);
	  }

	  function base64Write(buf, string, offset, length) {
	    return blitBuffer(base64ToBytes(string), buf, offset, length);
	  }

	  function ucs2Write(buf, string, offset, length) {
	    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
	  }

	  Buffer.prototype.write = function write(string, offset, length, encoding) {
	    // Buffer#write(string)
	    if (offset === undefined) {
	      encoding = 'utf8';
	      length = this.length;
	      offset = 0; // Buffer#write(string, encoding)
	    } else if (length === undefined && typeof offset === 'string') {
	      encoding = offset;
	      length = this.length;
	      offset = 0; // Buffer#write(string, offset[, length][, encoding])
	    } else if (isFinite(offset)) {
	      offset = offset >>> 0;

	      if (isFinite(length)) {
	        length = length >>> 0;
	        if (encoding === undefined) encoding = 'utf8';
	      } else {
	        encoding = length;
	        length = undefined;
	      }
	    } else {
	      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
	    }

	    var remaining = this.length - offset;
	    if (length === undefined || length > remaining) length = remaining;

	    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
	      throw new RangeError('Attempt to write outside buffer bounds');
	    }

	    if (!encoding) encoding = 'utf8';
	    var loweredCase = false;

	    for (;;) {
	      switch (encoding) {
	        case 'hex':
	          return hexWrite(this, string, offset, length);

	        case 'utf8':
	        case 'utf-8':
	          return utf8Write(this, string, offset, length);

	        case 'ascii':
	        case 'latin1':
	        case 'binary':
	          return asciiWrite(this, string, offset, length);

	        case 'base64':
	          // Warning: maxLength not taken into account in base64Write
	          return base64Write(this, string, offset, length);

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return ucs2Write(this, string, offset, length);

	        default:
	          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	          encoding = ('' + encoding).toLowerCase();
	          loweredCase = true;
	      }
	    }
	  };

	  Buffer.prototype.toJSON = function toJSON() {
	    return {
	      type: 'Buffer',
	      data: Array.prototype.slice.call(this._arr || this, 0)
	    };
	  };

	  function base64Slice(buf, start, end) {
	    if (start === 0 && end === buf.length) {
	      return base64Js.fromByteArray(buf);
	    } else {
	      return base64Js.fromByteArray(buf.slice(start, end));
	    }
	  }

	  function utf8Slice(buf, start, end) {
	    end = Math.min(buf.length, end);
	    var res = [];
	    var i = start;

	    while (i < end) {
	      var firstByte = buf[i];
	      var codePoint = null;
	      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

	      if (i + bytesPerSequence <= end) {
	        var secondByte = void 0,
	            thirdByte = void 0,
	            fourthByte = void 0,
	            tempCodePoint = void 0;

	        switch (bytesPerSequence) {
	          case 1:
	            if (firstByte < 0x80) {
	              codePoint = firstByte;
	            }

	            break;

	          case 2:
	            secondByte = buf[i + 1];

	            if ((secondByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

	              if (tempCodePoint > 0x7F) {
	                codePoint = tempCodePoint;
	              }
	            }

	            break;

	          case 3:
	            secondByte = buf[i + 1];
	            thirdByte = buf[i + 2];

	            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

	              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	                codePoint = tempCodePoint;
	              }
	            }

	            break;

	          case 4:
	            secondByte = buf[i + 1];
	            thirdByte = buf[i + 2];
	            fourthByte = buf[i + 3];

	            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

	              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	                codePoint = tempCodePoint;
	              }
	            }

	        }
	      }

	      if (codePoint === null) {
	        // we did not generate a valid codePoint so insert a
	        // replacement char (U+FFFD) and advance only 1 byte
	        codePoint = 0xFFFD;
	        bytesPerSequence = 1;
	      } else if (codePoint > 0xFFFF) {
	        // encode to utf16 (surrogate pair dance)
	        codePoint -= 0x10000;
	        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	        codePoint = 0xDC00 | codePoint & 0x3FF;
	      }

	      res.push(codePoint);
	      i += bytesPerSequence;
	    }

	    return decodeCodePointsArray(res);
	  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
	  // the lowest limit is Chrome, with 0x10000 args.
	  // We go 1 magnitude less, for safety


	  var MAX_ARGUMENTS_LENGTH = 0x1000;

	  function decodeCodePointsArray(codePoints) {
	    var len = codePoints.length;

	    if (len <= MAX_ARGUMENTS_LENGTH) {
	      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
	    } // Decode in chunks to avoid "call stack size exceeded".


	    var res = '';
	    var i = 0;

	    while (i < len) {
	      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
	    }

	    return res;
	  }

	  function asciiSlice(buf, start, end) {
	    var ret = '';
	    end = Math.min(buf.length, end);

	    for (var i = start; i < end; ++i) {
	      ret += String.fromCharCode(buf[i] & 0x7F);
	    }

	    return ret;
	  }

	  function latin1Slice(buf, start, end) {
	    var ret = '';
	    end = Math.min(buf.length, end);

	    for (var i = start; i < end; ++i) {
	      ret += String.fromCharCode(buf[i]);
	    }

	    return ret;
	  }

	  function hexSlice(buf, start, end) {
	    var len = buf.length;
	    if (!start || start < 0) start = 0;
	    if (!end || end < 0 || end > len) end = len;
	    var out = '';

	    for (var i = start; i < end; ++i) {
	      out += hexSliceLookupTable[buf[i]];
	    }

	    return out;
	  }

	  function utf16leSlice(buf, start, end) {
	    var bytes = buf.slice(start, end);
	    var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

	    for (var i = 0; i < bytes.length - 1; i += 2) {
	      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	    }

	    return res;
	  }

	  Buffer.prototype.slice = function slice(start, end) {
	    var len = this.length;
	    start = ~~start;
	    end = end === undefined ? len : ~~end;

	    if (start < 0) {
	      start += len;
	      if (start < 0) start = 0;
	    } else if (start > len) {
	      start = len;
	    }

	    if (end < 0) {
	      end += len;
	      if (end < 0) end = 0;
	    } else if (end > len) {
	      end = len;
	    }

	    if (end < start) end = start;
	    var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

	    Object.setPrototypeOf(newBuf, Buffer.prototype);
	    return newBuf;
	  };
	  /*
	   * Need to make sure that buffer isn't trying to write out of bounds.
	   */


	  function checkOffset(offset, ext, length) {
	    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
	    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
	  }

	  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var val = this[offset];
	    var mul = 1;
	    var i = 0;

	    while (++i < byteLength && (mul *= 0x100)) {
	      val += this[offset + i] * mul;
	    }

	    return val;
	  };

	  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      checkOffset(offset, byteLength, this.length);
	    }

	    var val = this[offset + --byteLength];
	    var mul = 1;

	    while (byteLength > 0 && (mul *= 0x100)) {
	      val += this[offset + --byteLength] * mul;
	    }

	    return val;
	  };

	  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 1, this.length);
	    return this[offset];
	  };

	  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    return this[offset] | this[offset + 1] << 8;
	  };

	  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    return this[offset] << 8 | this[offset + 1];
	  };

	  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
	  };

	  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	  };

	  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
	    offset = offset >>> 0;
	    validateNumber(offset, 'offset');
	    var first = this[offset];
	    var last = this[offset + 7];

	    if (first === undefined || last === undefined) {
	      boundsError(offset, this.length - 8);
	    }

	    var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
	    var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
	    return BigInt(lo) + (BigInt(hi) << BigInt(32));
	  });
	  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
	    offset = offset >>> 0;
	    validateNumber(offset, 'offset');
	    var first = this[offset];
	    var last = this[offset + 7];

	    if (first === undefined || last === undefined) {
	      boundsError(offset, this.length - 8);
	    }

	    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
	    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
	    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
	  });

	  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var val = this[offset];
	    var mul = 1;
	    var i = 0;

	    while (++i < byteLength && (mul *= 0x100)) {
	      val += this[offset + i] * mul;
	    }

	    mul *= 0x80;
	    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	    return val;
	  };

	  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var i = byteLength;
	    var mul = 1;
	    var val = this[offset + --i];

	    while (i > 0 && (mul *= 0x100)) {
	      val += this[offset + --i] * mul;
	    }

	    mul *= 0x80;
	    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	    return val;
	  };

	  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 1, this.length);
	    if (!(this[offset] & 0x80)) return this[offset];
	    return (0xff - this[offset] + 1) * -1;
	  };

	  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    var val = this[offset] | this[offset + 1] << 8;
	    return val & 0x8000 ? val | 0xFFFF0000 : val;
	  };

	  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    var val = this[offset + 1] | this[offset] << 8;
	    return val & 0x8000 ? val | 0xFFFF0000 : val;
	  };

	  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	  };

	  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	  };

	  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
	    offset = offset >>> 0;
	    validateNumber(offset, 'offset');
	    var first = this[offset];
	    var last = this[offset + 7];

	    if (first === undefined || last === undefined) {
	      boundsError(offset, this.length - 8);
	    }

	    var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

	    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
	  });
	  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
	    offset = offset >>> 0;
	    validateNumber(offset, 'offset');
	    var first = this[offset];
	    var last = this[offset + 7];

	    if (first === undefined || last === undefined) {
	      boundsError(offset, this.length - 8);
	    }

	    var val = (first << 24) + // Overflow
	    this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
	    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
	  });

	  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return ieee754.read(this, offset, true, 23, 4);
	  };

	  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return ieee754.read(this, offset, false, 23, 4);
	  };

	  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 8, this.length);
	    return ieee754.read(this, offset, true, 52, 8);
	  };

	  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 8, this.length);
	    return ieee754.read(this, offset, false, 52, 8);
	  };

	  function checkInt(buf, value, offset, ext, max, min) {
	    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
	    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
	    if (offset + ext > buf.length) throw new RangeError('Index out of range');
	  }

	  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	      checkInt(this, value, offset, byteLength, maxBytes, 0);
	    }

	    var mul = 1;
	    var i = 0;
	    this[offset] = value & 0xFF;

	    while (++i < byteLength && (mul *= 0x100)) {
	      this[offset + i] = value / mul & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	      checkInt(this, value, offset, byteLength, maxBytes, 0);
	    }

	    var i = byteLength - 1;
	    var mul = 1;
	    this[offset + i] = value & 0xFF;

	    while (--i >= 0 && (mul *= 0x100)) {
	      this[offset + i] = value / mul & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	    this[offset] = value & 0xff;
	    return offset + 1;
	  };

	  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    return offset + 2;
	  };

	  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	    return offset + 2;
	  };

	  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	    this[offset + 3] = value >>> 24;
	    this[offset + 2] = value >>> 16;
	    this[offset + 1] = value >>> 8;
	    this[offset] = value & 0xff;
	    return offset + 4;
	  };

	  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	    return offset + 4;
	  };

	  function wrtBigUInt64LE(buf, value, offset, min, max) {
	    checkIntBI(value, min, max, buf, offset, 7);
	    var lo = Number(value & BigInt(0xffffffff));
	    buf[offset++] = lo;
	    lo = lo >> 8;
	    buf[offset++] = lo;
	    lo = lo >> 8;
	    buf[offset++] = lo;
	    lo = lo >> 8;
	    buf[offset++] = lo;
	    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
	    buf[offset++] = hi;
	    hi = hi >> 8;
	    buf[offset++] = hi;
	    hi = hi >> 8;
	    buf[offset++] = hi;
	    hi = hi >> 8;
	    buf[offset++] = hi;
	    return offset;
	  }

	  function wrtBigUInt64BE(buf, value, offset, min, max) {
	    checkIntBI(value, min, max, buf, offset, 7);
	    var lo = Number(value & BigInt(0xffffffff));
	    buf[offset + 7] = lo;
	    lo = lo >> 8;
	    buf[offset + 6] = lo;
	    lo = lo >> 8;
	    buf[offset + 5] = lo;
	    lo = lo >> 8;
	    buf[offset + 4] = lo;
	    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
	    buf[offset + 3] = hi;
	    hi = hi >> 8;
	    buf[offset + 2] = hi;
	    hi = hi >> 8;
	    buf[offset + 1] = hi;
	    hi = hi >> 8;
	    buf[offset] = hi;
	    return offset + 8;
	  }

	  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
	  });
	  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
	  });

	  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      var limit = Math.pow(2, 8 * byteLength - 1);
	      checkInt(this, value, offset, byteLength, limit - 1, -limit);
	    }

	    var i = 0;
	    var mul = 1;
	    var sub = 0;
	    this[offset] = value & 0xFF;

	    while (++i < byteLength && (mul *= 0x100)) {
	      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	        sub = 1;
	      }

	      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      var limit = Math.pow(2, 8 * byteLength - 1);
	      checkInt(this, value, offset, byteLength, limit - 1, -limit);
	    }

	    var i = byteLength - 1;
	    var mul = 1;
	    var sub = 0;
	    this[offset + i] = value & 0xFF;

	    while (--i >= 0 && (mul *= 0x100)) {
	      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	        sub = 1;
	      }

	      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	    if (value < 0) value = 0xff + value + 1;
	    this[offset] = value & 0xff;
	    return offset + 1;
	  };

	  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    return offset + 2;
	  };

	  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	    return offset + 2;
	  };

	  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    this[offset + 2] = value >>> 16;
	    this[offset + 3] = value >>> 24;
	    return offset + 4;
	  };

	  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	    if (value < 0) value = 0xffffffff + value + 1;
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	    return offset + 4;
	  };

	  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
	  });
	  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
	  });

	  function checkIEEE754(buf, value, offset, ext, max, min) {
	    if (offset + ext > buf.length) throw new RangeError('Index out of range');
	    if (offset < 0) throw new RangeError('Index out of range');
	  }

	  function writeFloat(buf, value, offset, littleEndian, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      checkIEEE754(buf, value, offset, 4);
	    }

	    ieee754.write(buf, value, offset, littleEndian, 23, 4);
	    return offset + 4;
	  }

	  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
	    return writeFloat(this, value, offset, true, noAssert);
	  };

	  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
	    return writeFloat(this, value, offset, false, noAssert);
	  };

	  function writeDouble(buf, value, offset, littleEndian, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      checkIEEE754(buf, value, offset, 8);
	    }

	    ieee754.write(buf, value, offset, littleEndian, 52, 8);
	    return offset + 8;
	  }

	  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
	    return writeDouble(this, value, offset, true, noAssert);
	  };

	  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
	    return writeDouble(this, value, offset, false, noAssert);
	  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


	  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
	    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
	    if (!start) start = 0;
	    if (!end && end !== 0) end = this.length;
	    if (targetStart >= target.length) targetStart = target.length;
	    if (!targetStart) targetStart = 0;
	    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

	    if (end === start) return 0;
	    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

	    if (targetStart < 0) {
	      throw new RangeError('targetStart out of bounds');
	    }

	    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
	    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

	    if (end > this.length) end = this.length;

	    if (target.length - targetStart < end - start) {
	      end = target.length - targetStart + start;
	    }

	    var len = end - start;

	    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
	      // Use built-in when available, missing from IE11
	      this.copyWithin(targetStart, start, end);
	    } else {
	      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
	    }

	    return len;
	  }; // Usage:
	  //    buffer.fill(number[, offset[, end]])
	  //    buffer.fill(buffer[, offset[, end]])
	  //    buffer.fill(string[, offset[, end]][, encoding])


	  Buffer.prototype.fill = function fill(val, start, end, encoding) {
	    // Handle string cases:
	    if (typeof val === 'string') {
	      if (typeof start === 'string') {
	        encoding = start;
	        start = 0;
	        end = this.length;
	      } else if (typeof end === 'string') {
	        encoding = end;
	        end = this.length;
	      }

	      if (encoding !== undefined && typeof encoding !== 'string') {
	        throw new TypeError('encoding must be a string');
	      }

	      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	        throw new TypeError('Unknown encoding: ' + encoding);
	      }

	      if (val.length === 1) {
	        var code = val.charCodeAt(0);

	        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
	          // Fast path: If `val` fits into a single byte, use that numeric value.
	          val = code;
	        }
	      }
	    } else if (typeof val === 'number') {
	      val = val & 255;
	    } else if (typeof val === 'boolean') {
	      val = Number(val);
	    } // Invalid ranges are not set to a default, so can range check early.


	    if (start < 0 || this.length < start || this.length < end) {
	      throw new RangeError('Out of range index');
	    }

	    if (end <= start) {
	      return this;
	    }

	    start = start >>> 0;
	    end = end === undefined ? this.length : end >>> 0;
	    if (!val) val = 0;
	    var i;

	    if (typeof val === 'number') {
	      for (i = start; i < end; ++i) {
	        this[i] = val;
	      }
	    } else {
	      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
	      var len = bytes.length;

	      if (len === 0) {
	        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
	      }

	      for (i = 0; i < end - start; ++i) {
	        this[i + start] = bytes[i % len];
	      }
	    }

	    return this;
	  }; // CUSTOM ERRORS
	  // =============
	  // Simplified versions from Node, changed for Buffer-only usage


	  var errors = {};

	  function E(sym, getMessage, Base) {
	    errors[sym] = class NodeError extends Base {
	      constructor() {
	        super();
	        Object.defineProperty(this, 'message', {
	          value: getMessage.apply(this, arguments),
	          writable: true,
	          configurable: true
	        }); // Add the error code to the name to include it in the stack trace.

	        this.name = `${this.name} [${sym}]`; // Access the stack to generate the error message including the error code
	        // from the name.

	        this.stack; // eslint-disable-line no-unused-expressions
	        // Reset the name to the actual name.

	        delete this.name;
	      }

	      get code() {
	        return sym;
	      }

	      set code(value) {
	        Object.defineProperty(this, 'code', {
	          configurable: true,
	          enumerable: true,
	          value,
	          writable: true
	        });
	      }

	      toString() {
	        return `${this.name} [${sym}]: ${this.message}`;
	      }

	    };
	  }

	  E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
	    if (name) {
	      return `${name} is outside of buffer bounds`;
	    }

	    return 'Attempt to access memory outside buffer bounds';
	  }, RangeError);
	  E('ERR_INVALID_ARG_TYPE', function (name, actual) {
	    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
	  }, TypeError);
	  E('ERR_OUT_OF_RANGE', function (str, range, input) {
	    var msg = `The value of "${str}" is out of range.`;
	    var received = input;

	    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
	      received = addNumericalSeparator(String(input));
	    } else if (typeof input === 'bigint') {
	      received = String(input);

	      if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
	        received = addNumericalSeparator(received);
	      }

	      received += 'n';
	    }

	    msg += ` It must be ${range}. Received ${received}`;
	    return msg;
	  }, RangeError);

	  function addNumericalSeparator(val) {
	    var res = '';
	    var i = val.length;
	    var start = val[0] === '-' ? 1 : 0;

	    for (; i >= start + 4; i -= 3) {
	      res = `_${val.slice(i - 3, i)}${res}`;
	    }

	    return `${val.slice(0, i)}${res}`;
	  } // CHECK FUNCTIONS
	  // ===============


	  function checkBounds(buf, offset, byteLength) {
	    validateNumber(offset, 'offset');

	    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
	      boundsError(offset, buf.length - (byteLength + 1));
	    }
	  }

	  function checkIntBI(value, min, max, buf, offset, byteLength) {
	    if (value > max || value < min) {
	      var n = typeof min === 'bigint' ? 'n' : '';
	      var range;

	      if (byteLength > 3) {
	        if (min === 0 || min === BigInt(0)) {
	          range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
	        } else {
	          range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
	        }
	      } else {
	        range = `>= ${min}${n} and <= ${max}${n}`;
	      }

	      throw new errors.ERR_OUT_OF_RANGE('value', range, value);
	    }

	    checkBounds(buf, offset, byteLength);
	  }

	  function validateNumber(value, name) {
	    if (typeof value !== 'number') {
	      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
	    }
	  }

	  function boundsError(value, length, type) {
	    if (Math.floor(value) !== value) {
	      validateNumber(value, type);
	      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
	    }

	    if (length < 0) {
	      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
	    }

	    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
	  } // HELPER FUNCTIONS
	  // ================


	  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

	  function base64clean(str) {
	    // Node takes equal signs as end of the Base64 encoding
	    str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

	    str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

	    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

	    while (str.length % 4 !== 0) {
	      str = str + '=';
	    }

	    return str;
	  }

	  function utf8ToBytes(string, units) {
	    units = units || Infinity;
	    var codePoint;
	    var length = string.length;
	    var leadSurrogate = null;
	    var bytes = [];

	    for (var i = 0; i < length; ++i) {
	      codePoint = string.charCodeAt(i); // is surrogate component

	      if (codePoint > 0xD7FF && codePoint < 0xE000) {
	        // last char was a lead
	        if (!leadSurrogate) {
	          // no lead yet
	          if (codePoint > 0xDBFF) {
	            // unexpected trail
	            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	            continue;
	          } else if (i + 1 === length) {
	            // unpaired lead
	            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	            continue;
	          } // valid lead


	          leadSurrogate = codePoint;
	          continue;
	        } // 2 leads in a row


	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          leadSurrogate = codePoint;
	          continue;
	        } // valid surrogate pair


	        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	      } else if (leadSurrogate) {
	        // valid bmp char, but last char was a lead
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	      }

	      leadSurrogate = null; // encode utf8

	      if (codePoint < 0x80) {
	        if ((units -= 1) < 0) break;
	        bytes.push(codePoint);
	      } else if (codePoint < 0x800) {
	        if ((units -= 2) < 0) break;
	        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
	      } else if (codePoint < 0x10000) {
	        if ((units -= 3) < 0) break;
	        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	      } else if (codePoint < 0x110000) {
	        if ((units -= 4) < 0) break;
	        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	      } else {
	        throw new Error('Invalid code point');
	      }
	    }

	    return bytes;
	  }

	  function asciiToBytes(str) {
	    var byteArray = [];

	    for (var i = 0; i < str.length; ++i) {
	      // Node's code seems to be doing this and not & 0x7F..
	      byteArray.push(str.charCodeAt(i) & 0xFF);
	    }

	    return byteArray;
	  }

	  function utf16leToBytes(str, units) {
	    var c, hi, lo;
	    var byteArray = [];

	    for (var i = 0; i < str.length; ++i) {
	      if ((units -= 2) < 0) break;
	      c = str.charCodeAt(i);
	      hi = c >> 8;
	      lo = c % 256;
	      byteArray.push(lo);
	      byteArray.push(hi);
	    }

	    return byteArray;
	  }

	  function base64ToBytes(str) {
	    return base64Js.toByteArray(base64clean(str));
	  }

	  function blitBuffer(src, dst, offset, length) {
	    var i;

	    for (i = 0; i < length; ++i) {
	      if (i + offset >= dst.length || i >= src.length) break;
	      dst[i + offset] = src[i];
	    }

	    return i;
	  } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
	  // the `instanceof` check but they should be treated as of that type.
	  // See: https://github.com/feross/buffer/issues/166


	  function isInstance(obj, type) {
	    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
	  }

	  function numberIsNaN(obj) {
	    // For IE11 support
	    return obj !== obj; // eslint-disable-line no-self-compare
	  } // Create lookup table for `toString('hex')`
	  // See: https://github.com/feross/buffer/issues/219


	  var hexSliceLookupTable = function () {
	    var alphabet = '0123456789abcdef';
	    var table = new Array(256);

	    for (var i = 0; i < 16; ++i) {
	      var i16 = i * 16;

	      for (var j = 0; j < 16; ++j) {
	        table[i16 + j] = alphabet[i] + alphabet[j];
	      }
	    }

	    return table;
	  }(); // Return not function with Error if BigInt not supported


	  function defineBigIntMethod(fn) {
	    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
	  }

	  function BufferBigIntNotDefined() {
	    throw new Error('BigInt not supported');
	  }
	});

	function parseUserAgent(a) {
	  var model = navigator.appCodeName;

	  try {
	    var idx = a.indexOf('Mobile;');

	    if (idx != -1) {
	      var m = a.substring(idx + 8);
	      var idx2 = m.indexOf(')');
	      m = m.substring(0, idx2);
	      if (m != '') model = m;
	    }
	  } catch (err) {}

	  var version = "1.0";

	  try {
	    if (a.indexOf('KAIOS/') > -1) {
	      version = a.substring(a.indexOf('KAIOS/'));
	    } else if (a.indexOf('Firefox/') > -1) {
	      version = a.substring(a.indexOf('Firefox/'));
	    } else if (a.indexOf('Gecko/') > -1) {
	      version = a.substring(a.indexOf('Gecko/'));
	    } else if (a.indexOf('rv:') > -1) {
	      var _idx = a.indexOf('rv:');

	      if (_idx != -1) {
	        var v = a.substring(_idx);

	        var _idx2 = v.indexOf(')');

	        v = v.substring(0, _idx2);
	        if (v != '') version = v;
	      }
	    }
	  } catch (err) {}

	  return {
	    deviceModel: model,
	    systemVersion: version,
	    appVersion: "1.0.0"
	  };
	}

	var TelegramKeyHash = {
	  api_id: 1403915,
	  api_hash: '1291d66d65b509ed6d5fce437185a8cc'
	};

	var APP_VERSION = "1.1.0";
	var UA = parseUserAgent(navigator.userAgent);
	UA['appVersion'] = APP_VERSION;
	var current = window.localStorage.getItem('APP_VERSION');

	if (current == null || current !== APP_VERSION) {
	  window.localStorage.setItem('APP_VERSION', APP_VERSION);
	  window.localStorage.removeItem('GramJs:apiCache');
	}

	var _telegram = telegram,
	    Api = _telegram.Api,
	    TelegramClient = _telegram.TelegramClient,
	    AuthKey = _telegram.AuthKey;
	var StoreSession = telegram.sessions.StoreSession;
	var session = new StoreSession("gramjs");
	var client = new TelegramClient(session, TelegramKeyHash.api_id, TelegramKeyHash.api_hash, {
	  maxConcurrentDownloads: 1,
	  deviceModel: UA.deviceModel,
	  systemVersion: UA.systemVersion,
	  appVersion: UA.appVersion
	});
	client.setLogLevel('none'); // Duplicate same instance in authorizedWebWorker and sw.js

	var cachedDatabase = idb.openDB('telekram', 5, {
	  upgrade: (db, oldVersion, newVersion) => {
	    var tables = ['profilePhotos', 'chatPreferences', 'mediaAttachments', 'offlineWebpages', 'appPreferences'];
	    tables.forEach(n => {
	      if (!db.objectStoreNames.contains(n)) db.createObjectStore(n);
	    });
	  }
	});

	if ('mediaDevices' in navigator) {
	  navigator.mediaDevices.getUserMedia({
	    audio: false,
	    video: true
	  }).then(stream => {
	    stream.getTracks().forEach(track => {
	      track.stop();
	    });
	  });
	}

	if ('serviceWorker' in navigator) {
	  navigator.serviceWorker.register('/sw.js?v=1').then(swReg => {
	    if (navigator.serviceWorker.controller) {
	      navigator.serviceWorker.controller.postMessage({
	        type: 1,
	        visibilityState: document.visibilityState
	      });
	      navigator.serviceWorker.addEventListener('message', event => {
	        console.log("[SW]addEventListener:", event.data);
	      });
	    }
	  }).catch(error => {
	    console.error('Service Worker', error);
	  });
	} else {
	  console.warn('Service Worker not supported');
	}

	if ('mozSetMessageHandler' in navigator) {
	  navigator.mozSetMessageHandler('serviceworker-notification', activityRequest => {
	    if (window.navigator.mozApps) {
	      var request = window.navigator.mozApps.getSelf();

	      request.onsuccess = () => {
	        if (request.result) {
	          request.result.launch();
	        }
	      };
	    } else {
	      window.open(document.location.origin, '_blank');
	    }
	  });
	}

	document.addEventListener("visibilitychange", () => {
	  console.log('visibilitychange', document.visibilityState);
	  navigator.serviceWorker.controller.postMessage({
	    type: 1,
	    visibilityState: document.visibilityState
	  });
	});

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	// Copyright Joyent, Inc. and other Node contributors.

	var R = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
	  return Function.prototype.apply.call(target, receiver, args);
	};
	var ReflectOwnKeys;

	if (R && typeof R.ownKeys === 'function') {
	  ReflectOwnKeys = R.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}

	var events = EventEmitter;
	var once_1 = once; // Backwards-compat with node 0.10.x

	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.

	var defaultMaxListeners = 10;

	function checkListener(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function get() {
	    return defaultMaxListeners;
	  },
	  set: function set(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }

	    defaultMaxListeners = arg;
	  }
	});

	EventEmitter.init = function () {
	  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	}; // Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.


	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }

	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners(that) {
	  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners(this);
	};

	EventEmitter.prototype.emit = function emit(type) {
	  var args = [];

	  for (var i = 1; i < arguments.length; i++) {
	    args.push(arguments[i]);
	  }

	  var doError = type === 'error';
	  var events = this._events;
	  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

	  if (doError) {
	    var er;
	    if (args.length > 0) er = args[0];

	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    } // At least give some kind of context to the user


	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];
	  if (handler === undefined) return false;

	  if (typeof handler === 'function') {
	    ReflectApply(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);

	    for (var i = 0; i < len; ++i) {
	      ReflectApply(listeners[i], this, args);
	    }
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;
	  checkListener(listener);
	  events = target._events;

	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object

	      events = target._events;
	    }

	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    } // Check for listener leak


	    m = _getMaxListeners(target);

	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true; // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax

	      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning(w);
	    }
	  }

	  return target;
	}

	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener = function prependListener(type, listener) {
	  return _addListener(this, type, listener, true);
	};

	function onceWrapper() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0) return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap(target, type, listener) {
	  var state = {
	    fired: false,
	    wrapFn: undefined,
	    target: target,
	    type: type,
	    listener: listener
	  };
	  var wrapped = onceWrapper.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  checkListener(listener);
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
	  checkListener(listener);
	  this.prependListener(type, _onceWrap(this, type, listener));
	  return this;
	}; // Emits a 'removeListener' event if and only if the listener was removed.


	EventEmitter.prototype.removeListener = function removeListener(type, listener) {
	  var list, events, position, i, originalListener;
	  checkListener(listener);
	  events = this._events;
	  if (events === undefined) return this;
	  list = events[type];
	  if (list === undefined) return this;

	  if (list === listener || list.listener === listener) {
	    if (--this._eventsCount === 0) this._events = Object.create(null);else {
	      delete events[type];
	      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
	    }
	  } else if (typeof list !== 'function') {
	    position = -1;

	    for (i = list.length - 1; i >= 0; i--) {
	      if (list[i] === listener || list[i].listener === listener) {
	        originalListener = list[i].listener;
	        position = i;
	        break;
	      }
	    }

	    if (position < 0) return this;
	    if (position === 0) list.shift();else {
	      spliceOne(list, position);
	    }
	    if (list.length === 1) events[type] = list[0];
	    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
	  }

	  return this;
	};

	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

	EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
	  var listeners, events, i;
	  events = this._events;
	  if (events === undefined) return this; // not listening for removeListener, no need to emit

	  if (events.removeListener === undefined) {
	    if (arguments.length === 0) {
	      this._events = Object.create(null);
	      this._eventsCount = 0;
	    } else if (events[type] !== undefined) {
	      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
	    }

	    return this;
	  } // emit removeListener for all listeners on all events


	  if (arguments.length === 0) {
	    var keys = Object.keys(events);
	    var key;

	    for (i = 0; i < keys.length; ++i) {
	      key = keys[i];
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }

	    this.removeAllListeners('removeListener');
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	    return this;
	  }

	  listeners = events[type];

	  if (typeof listeners === 'function') {
	    this.removeListener(type, listeners);
	  } else if (listeners !== undefined) {
	    // LIFO order
	    for (i = listeners.length - 1; i >= 0; i--) {
	      this.removeListener(type, listeners[i]);
	    }
	  }

	  return this;
	};

	function _listeners(target, type, unwrap) {
	  var events = target._events;
	  if (events === undefined) return [];
	  var evlistener = events[type];
	  if (evlistener === undefined) return [];
	  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
	  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}

	EventEmitter.prototype.listeners = function listeners(type) {
	  return _listeners(this, type, true);
	};

	EventEmitter.prototype.rawListeners = function rawListeners(type) {
	  return _listeners(this, type, false);
	};

	EventEmitter.listenerCount = function (emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;

	function listenerCount(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};

	function arrayClone(arr, n) {
	  var copy = new Array(n);

	  for (var i = 0; i < n; ++i) {
	    copy[i] = arr[i];
	  }

	  return copy;
	}

	function spliceOne(list, index) {
	  for (; index + 1 < list.length; index++) {
	    list[index] = list[index + 1];
	  }

	  list.pop();
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);

	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }

	  return ret;
	}

	function once(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }

	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener(emitter, name, resolver, {
	      once: true
	    });

	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter(emitter, errorListener, {
	        once: true
	      });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }

	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}
	events.once = once_1;

	var shouldGetDialogs = writable(false);
	var connectionStatus = writable(false);
	var authorizationStatus = writable(false);
	var authorizedUser = writable([]);
	var dialogList = writable([]);
	var cachedThumbnails = writable({});
	var downloadedMediaEmitter = new events();
	var dispatchMessageToClient = new events();
	var dispatchMessageToWorker = new events();
	downloadedMediaEmitter.setMaxListeners(1000);
	dispatchMessageToClient.setMaxListeners(1000);
	dispatchMessageToWorker.setMaxListeners(1000);
	client.addEventHandler(evt => {
	  switch (evt.className) {
	    case "UpdateNotifySettings":
	    case "UpdateFolderPeers":
	    case "UpdateNewMessage":
	    case "UpdateEditMessage":
	    case "UpdateDeleteMessages":
	    case "UpdateNewChannelMessage":
	    case "UpdateEditChannelMessage":
	    case "UpdateDeleteChannelMessages":
	    case "UpdateShortMessage":
	    case "UpdateReadHistoryInbox":
	    case "UpdateReadHistoryOutbox":
	    case "UpdateReadMessagesContents":
	    case "UpdateReadChannelInbox":
	    case "UpdateReadChannelOutbox":
	    case "UpdateReadFeaturedStickers":
	    case "UpdateReadChannelDiscussionInbox":
	    case "UpdateReadChannelDiscussionOutbox":
	    case "UpdateMessagePoll":
	    case "Updates":
	      getDialogs();

	      if (['UpdateNewMessage', 'UpdateNewChannelMessage'].indexOf(evt.className) > -1) {
	        client.invoke(new Api.messages.ReceivedMessages({
	          maxId: evt.message.id
	        }));
	      }

	      break;

	    case "UpdatesTooLong":
	      isUserAuthorized();
	      break;

	    default:
	      console.log('client.addEventHandler:', evt);
	  }

	  if (evt.state) {
	    if (evt.state === 1) connectionStatus.update(n => true);else if (evt.state === -1) connectionStatus.update(n => false);
	  }
	});
	function initilize() {
	  var tm = setTimeout(() => {
	    alert("Please re-launch the app");
	    window.close();
	  }, 60000);
	  return client.connect().then(() => {
	    connectionStatus.update(n => true);
	    isUserAuthorized();
	  }).catch(err => {
	    connectionStatus.update(n => false);
	  }).finally(() => {
	    clearTimeout(tm);
	  });
	}
	initilize();
	function fetchUser() {
	  return _fetchUser.apply(this, arguments);
	}

	function _fetchUser() {
	  _fetchUser = _asyncToGenerator(function* () {
	    var result = yield client.invoke(new Api.users.GetUsers({
	      id: [new Api.InputPeerSelf()]
	    }));
	    authorizedUser.update(n => result);
	  });
	  return _fetchUser.apply(this, arguments);
	}

	function isUserAuthorized() {
	  return _isUserAuthorized.apply(this, arguments);
	}

	function _isUserAuthorized() {
	  _isUserAuthorized = _asyncToGenerator(function* () {
	    try {
	      var authorized = yield client.isUserAuthorized();
	      authorizationStatus.update(n => authorized);

	      if (authorized) {
	        yield fetchUser();
	        getDialogs();

	        if (window['authenticationWebWorker']) {
	          window['authenticationWebWorker'].postMessage({
	            type: -100
	          });
	          window['authenticationWebWorker'].terminate();
	        }

	        window['authorizedWebWorker'] = authorizedWebWorker();

	        window['authorizedWebWorker'].onmessage = /*#__PURE__*/function () {
	          var _ref = _asyncToGenerator(function* (e) {
	            switch (e.data.type) {
	              case -1:
	                console.error(e.data.params);
	                break;

	              case 0:
	                console.log('Connected to authorizedWebWorker');
	                break;

	              case 1:
	                // downloadedMediaEmitter.update(n => e.data);
	                downloadedMediaEmitter.emit('message', e.data);
	                break;

	              case 2:
	                var base64 = yield bufferToBase64(e.data.result);
	                (yield cachedDatabase).put('profilePhotos', base64, e.data.hash.photoId);
	                updateThumbCached(e.data.hash.photoId, base64);
	                break;
	            }
	          });

	          return function (_x10) {
	            return _ref.apply(this, arguments);
	          };
	        }();

	        try {
	          var pushSubscription = yield (yield cachedDatabase).get('appPreferences', 'pushSubscription');

	          if (pushSubscription == null) {
	            try {
	              yield unsubscribePush();
	            } catch (err) {}

	            pushSubscription = yield subscribePush();
	            pushSubscription = pushSubscription.toJSON();
	            delete pushSubscription['expirationTime'];
	            var result = yield registerDevice(client, pushSubscription); // console.log('registerDevice result:', result);
	          } else {
	            var updatedPushSubscription = yield (yield cachedDatabase).get('appPreferences', 'updatedPushSubscription');

	            if (updatedPushSubscription != null) {
	              var _result = yield unregisterDevice(client, pushSubscription); // console.log('unregisterDevice result:', result);


	              _result = yield registerDevice(client, updatedPushSubscription); // console.log('registerDevice result:', result);

	              (yield cachedDatabase).delete('appPreferences', 'updatedPushSubscription');
	            }
	          }
	        } catch (err) {
	          console.error(err);
	        }
	      } else {
	        yield (yield cachedDatabase).delete('appPreferences', 'pushSubscription');
	        yield (yield cachedDatabase).delete('appPreferences', 'updatedPushSubscription');
	        yield client.disconnect();

	        if (window['authorizedWebWorker']) {
	          window['authorizedWebWorker'].postMessage({
	            type: -100
	          });
	          window['authorizedWebWorker'].terminate();
	        }

	        window['authenticationWebWorker'] = authenticationWebWorker();

	        window['authenticationWebWorker'].onmessage = e => {
	          // console.log('authenticationWebWorker:', e.data.type, e.data.params.state, e.data.params.className, e.data.params.data);
	          switch (e.data.type) {
	            case -1:
	            case 0:
	            case 1:
	            case 2:
	            case -2:
	            case 3:
	            case -3:
	            case 4:
	            case -4:
	            case 5:
	            case -5:
	            case 6:
	            case -6:
	            case 7:
	            case -7:
	              dispatchMessageToClient.emit('message', e.data);
	              break;
	          }
	        };

	        dispatchMessageToWorker.addListener('message', data => {
	          window['authenticationWebWorker'].postMessage(data);
	        });
	      }
	    } catch (err) {
	      console.log(err);
	    }
	  });
	  return _isUserAuthorized.apply(this, arguments);
	}

	function getDialogs() {
	  return _getDialogs.apply(this, arguments);
	}

	function _getDialogs() {
	  _getDialogs = _asyncToGenerator(function* () {
	    try {
	      var _start = new Date().getTime();

	      var user = yield getAuthorizedUser();
	      var chats = yield client.getDialogs({
	        offsetPeer: new Api.InputPeerSelf(),
	        limit: 100,
	        excludePinned: true,
	        folderId: 0
	      });
	      var httpTasks = [];
	      var websocketTasks = [];
	      var chatPreferencesTask = {};
	      chats.forEach((chat, index) => {
	        chat.__isSavedMessages = false;

	        if (chat.id.value === user[0].id.value) {
	          chat.name = 'Saved Messages';
	          chat.entity.__isSavedMessages = true;
	        }

	        chat.entity.__muted = false;

	        if (chat.dialog.notifySettings.muteUntil != null) {
	          chat.entity.__muted = chat.dialog.notifySettings.muteUntil;
	        }

	        if (chatPreferencesTask[chat.entity.id.value.toString()] == null) {
	          chatPreferencesTask[chat.entity.id.value.toString()] = {};
	        }

	        chatPreferencesTask[chat.entity.id.value.toString()]['muted'] = chat.dialog.notifySettings.muteUntil || false;
	        chatPreferencesTask[chat.entity.id.value.toString()]['scrollAt'] = chat.message.id;
	        chat.iconRef = chat.id.toString();

	        if (!(chat.entity.username == null && chat.entity.phone == null) && chat.entity.photo != null && chat.entity.photo.className !== 'ChatPhotoEmpty') {
	          chat.iconRef = chat.entity.photo.photoId.toString();
	          httpTasks.push({
	            url: `https://api.codetabs.com/v1/proxy/?quest=https://t.me/${chat.entity.phone === "42777" ? 'telegram' : chat.entity.username}`,
	            photoId: chat.entity.photo.photoId.toString(),
	            chat: chat
	          });
	        } else if (chat.entity.photo != null && chat.entity.photo.className !== 'ChatPhotoEmpty') {
	          chat.iconRef = chat.entity.photo.photoId.toString();
	          websocketTasks.push({
	            photoId: chat.entity.photo.photoId.toString(),
	            chat: chat
	          });
	        }

	        var letters = chat.name.split(' ').map(text => {
	          return text[0];
	        });
	      });
	      dialogList.update(n => chats);
	      console.log(`getDialogs: ${new Date().getTime() - _start}ms`);
	      runTask(httpTasks, websocketTasks, chatPreferencesTask);
	      return chats;
	    } catch (err) {
	      console.log(err);
	    }
	  });
	  return _getDialogs.apply(this, arguments);
	}

	function getDialogList() {
	  return get_store_value(dialogList);
	}
	function getCachedThumbnails() {
	  return get_store_value(cachedThumbnails);
	}
	function getAuthorizedUser() {
	  return get_store_value(authorizedUser);
	} // [NON-BLOCKING]

	function runTask(_x, _x2) {
	  return _runTask.apply(this, arguments);
	}

	function _runTask() {
	  _runTask = _asyncToGenerator(function* (httpTasks, websocketTasks) {
	    var chatPreferencesTask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    // const lbl = `chatPreferencesTask ${Object.keys(chatPreferencesTask).length}`;
	    // console.time(lbl);
	    for (var chatId in chatPreferencesTask) {
	      try {
	        var pref = yield (yield cachedDatabase).get('chatPreferences', chatId);
	        if (pref == null) pref = {};
	        pref['muted'] = chatPreferencesTask[chatId]['muted'];

	        if (pref['scrollAt'] == null) {
	          pref['scrollAt'] = chatPreferencesTask[chatId]['scrollAt'];
	        }

	        yield (yield cachedDatabase).put('chatPreferences', pref, chatId);
	      } catch (err) {
	        console.log('chatPreferencesTask:', err);
	      }
	    } // console.timeEnd(lbl);
	    // const lbl2 = `httpTasks ${httpTasks.length}`
	    // console.time(lbl2);


	    var skipHttpTasks = [];
	    httpTasks.forEach( /*#__PURE__*/function () {
	      var _ref2 = _asyncToGenerator(function* (task, index) {
	        if (skipHttpTasks.indexOf(task.photoId.toString()) > -1) {
	          return;
	        }

	        skipHttpTasks.push(task.photoId.toString());

	        try {
	          var cache = yield (yield cachedDatabase).get('profilePhotos', task.photoId);

	          if (cache != null) {
	            updateThumbCached(task.photoId, cache);
	          } else {
	            var html = new DOMParser().parseFromString(yield (yield fetch(task.url)).text(), 'text/html');
	            var images = html.getElementsByClassName('tgme_page_photo_image');

	            if (images.length === 0) {
	              throw 'No profile picture: tgme_page_photo_image';
	            } else {
	              var img = images[0];
	              var blob = yield (yield fetch(img.src)).blob();
	              var base64 = yield blobToBase64(blob);
	              yield (yield cachedDatabase).put('profilePhotos', base64, task.photoId);
	              cache = base64;
	              updateThumbCached(task.photoId, cache);
	            }
	          }

	          ;
	        } catch (err) {
	          console.log('httpTasks:', err);

	          if (window['authorizedWebWorker']) {
	            window['authorizedWebWorker'].postMessage({
	              type: 2,
	              params: {
	                photoId: task.photoId.toString(),
	                chatId: task.chat.entity ? task.chat.entity.id.toString() : task.chat.id.toString(),
	                origin: task.origin ? {
	                  chatId: task.origin.chat.id.toString(),
	                  messageId: task.origin.message.id
	                } : null
	              }
	            });
	          }
	        }
	      });

	      return function (_x11, _x12) {
	        return _ref2.apply(this, arguments);
	      };
	    }()); // console.timeEnd(lbl2);
	    // const lbl3 = `websocketTasks ${websocketTasks.length}`
	    // console.time(lbl3);

	    var skipWebsocketTasks = [];
	    websocketTasks.forEach( /*#__PURE__*/function () {
	      var _ref3 = _asyncToGenerator(function* (task) {
	        if (skipWebsocketTasks.indexOf(task.photoId.toString()) > -1) {
	          return;
	        }

	        skipWebsocketTasks.push(task.photoId.toString());

	        try {
	          var cache = yield (yield cachedDatabase).get('profilePhotos', task.photoId.toString());

	          if (cache != null) {
	            updateThumbCached(task.photoId, cache);
	          } else {
	            if (window['authorizedWebWorker']) {
	              window['authorizedWebWorker'].postMessage({
	                type: 2,
	                params: {
	                  photoId: task.photoId.toString(),
	                  chatId: task.chat.entity ? task.chat.entity.id.toString() : task.chat.id.toString(),
	                  origin: task.origin ? {
	                    chatId: task.origin.chat.id.toString(),
	                    messageId: task.origin.message.id
	                  } : null
	                }
	              });
	            }
	          }
	        } catch (err) {
	          console.log('websocketTasks:', err);
	        }
	      });

	      return function (_x13) {
	        return _ref3.apply(this, arguments);
	      };
	    }()); // console.timeEnd(lbl3);
	  });
	  return _runTask.apply(this, arguments);
	}

	function updateThumbCached(_x3, _x4) {
	  return _updateThumbCached.apply(this, arguments);
	}

	function _updateThumbCached() {
	  _updateThumbCached = _asyncToGenerator(function* (ref, base64) {
	    var cached = yield get_store_value(cachedThumbnails);
	    cached[ref] = base64;
	    cachedThumbnails.update(n => cached);
	  });
	  return _updateThumbCached.apply(this, arguments);
	}

	function bufferToBase64(buffer) {
	  return new Promise((resolve, reject) => {
	    var reader = new FileReader();

	    reader.onloadend = () => {
	      resolve(reader.result);
	    };

	    reader.onerror = err => {
	      reject(err);
	    };

	    reader.readAsDataURL(new Blob([new Uint8Array(buffer, 0, buffer.length)], {
	      type: 'image/jpeg'
	    }));
	  });
	}

	function blobToBase64(blob) {
	  return new Promise((resolve, reject) => {
	    var reader = new FileReader();

	    reader.onloadend = () => {
	      resolve(reader.result);
	    };

	    reader.onerror = err => {
	      reject(err);
	    };

	    reader.readAsDataURL(blob);
	  });
	}

	function authorizedWebWorker() {
	  if (window['authorizedWebWorker']) window['authorizedWebWorker'].terminate();
	  var script = `
    importScripts('${window.location.origin}/js/polyfill.min.js');
    importScripts('${window.location.origin}/js/telegram.js');
    importScripts('${window.location.origin}/js/idb.js');

    const UA = ${JSON.stringify(UA)};

    const cachedDatabase = idb.openDB('telekram', 5, {
      upgrade: (db, oldVersion, newVersion) => {
        const tables = ['profilePhotos', 'chatPreferences', 'mediaAttachments', 'offlineWebpages', 'appPreferences'];
        tables.forEach(n => {
          if (!db.objectStoreNames.contains(n))
            db.createObjectStore(n);
        });
      },
    });

    let clients;
    let chats = {};
    let queuedTask = [];
    let downloadMediaTask = [];
    let downloadProfilePhotoTask = [];
    let ready = false;

    function getDialogs() {
      client.getDialogs({
        offsetPeer: new telegram.Api.InputPeerSelf(),
        limit: 100,
        excludePinned: true,
        folderId: 0,
      })
      .then((result) => {
        for (var x in result) {
          if (result[x].id && result[x].id.value) {
            const id = result[x].id.value.toString();
            chats[id] = result[x];
          }
        }
      })
      .catch(err => {
        self.postMessage({ type: -1, params: err });
      })
      .finally(() => {
        ready = true;
      });
    }

    function executeDownloadMediaTask() {
      if (downloadMediaTask.length <= 0)
        return;
      const task = downloadMediaTask[0];
      queuedTask.push(task.fileId);
      // console.log(chats[task.chatId], task.chatId, task.messageId);
      const hash = task.fileId;
      let bytes;
      client.getMessages(chats[task.chatId].entity, { limit: 1, ids: task.messageId })
      .then((msg) => {
        return client.downloadMedia(msg[0].media, {
          progressCallback: (received, total) => {
            self.postMessage({ type: 1, hash: hash, progress: { received: received.toJSNumber(), total: total.toJSNumber() } });
          }
        });
      })
      .then((_bytes) => {
        bytes = _bytes;
        return cachedDatabase;
      })
      .then(db => {
        return db.put('mediaAttachments', bytes, task.fileId);
      })
      .then(fileId => {
        self.postMessage({ type: 1, hash: hash, done: fileId });
      })
      .catch(err => {
        self.postMessage({ type: 1, hash: hash, error: err });
      })
      .finally(() => {
        queuedTask.splice(queuedTask.indexOf(task.fileId), 1);
        setTimeout(() => {
          downloadMediaTask.splice(0, 1);
          executeDownloadMediaTask();
        }, 1500);
      });
    }

    function executeDownloadProfilePhotoTask() {
      if (ready === false || (client.connected === false && downloadProfilePhotoTask.length > 0)) {
        setTimeout(() => {
          executeDownloadProfilePhotoTask();
        }, 3000)
        return;
      }
      if (downloadProfilePhotoTask.length <= 0)
        return;
      const task = downloadProfilePhotoTask[0];
      // console.log(task.chatId, task.photoId, task.origin, chats[task.origin.chatId]);
      client.downloadProfilePhoto(telegram.helpers.returnBigInt(task.chatId), { isBig: true })
      .then((buffer) => {
        self.postMessage({ type: 2, hash: task, result: buffer });
      })
      .catch(err => {
        // console.log(task.chatId, chats[task.chatId], Object.keys(chats).length) // TODO, check private channel
        if (task.origin && chats[task.origin.chatId]) {
          client.getMessages(chats[task.origin.chatId], {ids:[task.origin.messageId]})
          .then((messages) => {
            // console.log(messages[0].sender);
            return client.downloadProfilePhoto(messages[0].sender);
          })
          .then((_buffer) => {
            // console.log('Success:', task.origin.chatId, task.origin.messageId);
            self.postMessage({ type: 2, hash: task, result: _buffer });
          })
          .catch((_err) => {
            // console.log('Fail:', task.origin.chatId, task.origin.messageId);
            self.postMessage({ type: -1, params: _err });
          })
          .finally(() => {
            setTimeout(() => {
              downloadProfilePhotoTask.splice(0, 1);
              executeDownloadProfilePhotoTask();
            }, 1500);
          });
        } else {
          self.postMessage({ type: -1, params: err });
          setTimeout(() => {
            downloadProfilePhotoTask.splice(0, 1);
            executeDownloadProfilePhotoTask();
          }, 1500);
        }
      });

    }

    self.onmessage = function(e) {
      switch (e.data.type) {
        case -100:
          client.disconnect()
          .then(() => {
            self.postMessage({ type: -100, params: {} });
          }).catch(() => {
            self.postMessage({ type: -1, params: err });
          });
          break;
        case 0:
          const session = new telegram.sessions.MemorySession();
          if (e.data.params) {
            session.setDC(e.data.params.dcId, e.data.params.serverAddress, e.data.params.port);
            if (e.data.params.authKey)
              session.setAuthKey(new telegram.AuthKey(e.data.params.authKey._key, e.data.params.authKey._hash), e.data.params.dcId);
          }
          client = new telegram.TelegramClient(session, ${TelegramKeyHash.api_id}, '${TelegramKeyHash.api_hash}', {
            maxConcurrentDownloads: 1,
            deviceModel: UA.deviceModel,
            systemVersion: UA.systemVersion,
            appVersion: UA.appVersion,
          });
          client.addEventHandler((evt) => {
            // console.log('authorizedWebWorker.client.addEventHandler:', evt.className);
          });
          client.connect()
          .then(() => {
            getDialogs();
            self.postMessage({ type: 0, params: {} });
          })
          .catch(err => {
            self.postMessage({ type: -1, params: err });
          });
          break;
        case 1:
          // const chatId = telegram.helpers.returnBigInt(e.data.params.chatId);
          if (chats[e.data.params.chatId] && queuedTask.indexOf(e.data.params.fileId) === -1) {
            self.postMessage({ type: 1, hash: e.data.params.fileId, init: 1 });
            downloadMediaTask.push(e.data.params);
            if (downloadMediaTask.length === 1)
              executeDownloadMediaTask();
          } else if (queuedTask.indexOf(e.data.params.fileId) > -1) {
            self.postMessage({ type: 1, hash: e.data.params.fileId, init: 1 });
          } else {
            self.postMessage({ type: 1, hash: e.data.params.fileId, init: -1 });
          }
          break;
        case 2:
          // const chatId = telegram.helpers.returnBigInt(e.data.params.chatId);
          downloadProfilePhotoTask.push(e.data.params);
          if (downloadProfilePhotoTask.length === 1)
            executeDownloadProfilePhotoTask();
          break;
      }
    }
  `;
	  var blob = new Blob([script], {
	    type: 'application/javascript'
	  });
	  var worker = new Worker(URL.createObjectURL(blob));
	  worker.postMessage({
	    type: 0,
	    params: {
	      dcId: session.dcId,
	      serverAddress: session.serverAddress,
	      port: session.port,
	      authKey: session.getAuthKey(session.dcId)
	    }
	  });
	  return worker;
	}

	function authenticationWebWorker() {
	  if (window['authenticationWebWorker']) window['authenticationWebWorker'].terminate();
	  /*
	   * 0    connect
	   * -100 disconnect
	   * -1   common errors
	   * 1    client.addEventHandler
	   * N    success N, error -N and N must >= 2
	   */

	  var script = `
    importScripts('${window.location.origin}/js/polyfill.min.js');
    importScripts('${window.location.origin}/js/telegram.js');

    const UA = ${JSON.stringify(UA)};

    let _importLoginToken;
    let clients;
    let session;

    self.onmessage = function(e) {
      switch (e.data.type) {
        case -100:
          client.disconnect()
          .then(() => {
            self.postMessage({ type: -100, params: {} });
          }).catch(() => {
            self.postMessage({ type: -1, params: err });
          });
          break;
        case 0:
          session = new telegram.sessions.MemorySession();
          if (e.data.params && e.data.params.dcId && e.data.params.serverAddress && e.data.params.port) {
            session.setDC(e.data.params.dcId, e.data.params.serverAddress, e.data.params.port);
            if (e.data.params.authKey)
              session.setAuthKey(new telegram.AuthKey(e.data.params.authKey._key, e.data.params.authKey._hash), e.data.params.dcId);
          }
          client = new telegram.TelegramClient(session, ${TelegramKeyHash.api_id}, '${TelegramKeyHash.api_hash}', {
            maxConcurrentDownloads: 1,
            deviceModel: UA.deviceModel,
            systemVersion: UA.systemVersion,
            appVersion: UA.appVersion,
          });
          client.addEventHandler((evt) => {
            try {
              self.postMessage({ type: 1, params: { state: evt.state, className: evt.className, data: evt.toJSON() }});
            } catch (err) {
              self.postMessage({ type: 1, params: { state: evt.state, className: evt.className }});
            }
          });
          client.connect()
          .then(() => {
            self.postMessage({ type: 0, params: {} });
          })
          .catch(err => {
            self.postMessage({ type: -1, params: err });
          });
          break;
        case 2:
          client.invoke(
            new telegram.Api.auth.SendCode({
              phoneNumber: e.data.params.phoneNumber,
              apiId: e.data.params.apiId,
              apiHash: e.data.params.apiHash,
              settings: new telegram.Api.CodeSettings(e.data.params.settings),
            })
          )
          .then((result) => {
            self.postMessage({ type: 2, params: result });
          })
          .catch((err) => {
            self.postMessage({ type: -2, params: err.errorMessage });
          });
          break;
        case 3:
          client.invoke(
            new telegram.Api.auth.SignIn({
              phoneNumber: e.data.params.phoneNumber,
              phoneCodeHash: e.data.params.phoneCodeHash,
              phoneCode: e.data.params.phoneCode,
            })
          )
          .then((result) => {
            const sess = {
              dcId: session.dcId,
              serverAddress: session.serverAddress,
              port: session.port,
              authKey: session.getAuthKey(session.dcId)
            }
            self.postMessage({ type: 3, params: { result: result.toJSON(), session: sess } });
          })
          .catch((err) => {
            self.postMessage({ type: -3, params: err.errorMessage });
          });
          break;
        case 4:
          client.signInWithPassword(
            {
              apiId: e.data.params.apiId,
              apiHash: e.data.params.apiHash,
            },
            {
              password: (hint) => {
                return Promise.resolve(e.data.params.password);
              },
              onError: (err) => {
                self.postMessage({ type: -4, params: err.errorMessage || err.toString() });
                return true;
              }
            }
          )
          .then((result) => {
            const sess = {
              dcId: session.dcId,
              serverAddress: session.serverAddress,
              port: session.port,
              authKey: session.getAuthKey(session.dcId)
            }
            self.postMessage({ type: 4, params: { result: result.toJSON(), session: sess } });
          })
          .catch((err) => {
            self.postMessage({ type: -4, params: err.errorMessage || err.toString() });
          });
          break;
        case 5:
          client.invoke(
            new telegram.Api.auth.ExportLoginToken({
              apiId: e.data.params.apiId,
              apiHash: e.data.params.apiHash,
              exceptIds: e.data.params.exceptIds,
            })
          )
          .then((result) => {
            self.postMessage({ type: 5, params: result });
          })
          .catch((err) => {
            self.postMessage({ type: -5, params: err.errorMessage });
          });
          break;
        case 6:
          client.invoke(
            new telegram.Api.auth.ExportLoginToken({
              apiId: e.data.params.apiId,
              apiHash: e.data.params.apiHash,
              exceptIds: e.data.params.exceptIds,
            })
          )
          .then((result) => {
            const sess = {
              dcId: session.dcId,
              serverAddress: session.serverAddress,
              port: session.port,
              authKey: session.getAuthKey(session.dcId)
            }
            _importLoginToken = result.token || null;
            self.postMessage({ type: 6, params: { result: result.toJSON(), session: sess } });
          })
          .catch((err) => {
            self.postMessage({ type: -6, params: err.errorMessage }); // TODO DEBUG
          });
          break;
        case 7:
          client.invoke(
            new telegram.Api.auth.ImportLoginToken({
              token: _importLoginToken,
            })
          )
          .then((result) => {
            _importLoginToken = null;
            const sess = {
              dcId: session.dcId,
              serverAddress: session.serverAddress,
              port: session.port,
              authKey: session.getAuthKey(session.dcId)
            }
            self.postMessage({ type: 7, params: { result: result.toJSON(), session: sess } });
          })
          .catch((err) => {
            self.postMessage({ type: -7, params: err.errorMessage });
          });
          break;
      }
    }
  `;
	  var blob = new Blob([script], {
	    type: 'application/javascript'
	  });
	  var worker = new Worker(URL.createObjectURL(blob));
	  worker.postMessage({
	    type: 0,
	    params: {
	      dcId: session.dcId,
	      serverAddress: session.serverAddress,
	      port: session.port,
	      authKey: session.getAuthKey(session.dcId)
	    }
	  });
	  return worker;
	}

	document.addEventListener("visibilitychange", () => {
	  try {
	    if (document.visibilityState === 'visible') {
	      client.invoke(new Api.account.UpdateStatus({
	        offline: false
	      }));
	    } else {
	      client.invoke(new Api.account.UpdateStatus({
	        offline: true
	      }));
	    }
	  } catch (err) {}
	});
	function subscribePush() {
	  return new Promise((resolve, reject) => {
	    Notification.requestPermission().then(result => {
	      if (result === 'granted') return navigator.serviceWorker.ready;
	      return Promise.reject('Denied');
	    }).then(reg => {
	      return reg.pushManager.subscribe({
	        userVisibleOnly: true
	      });
	    }).then(subscription => {
	      if (subscription) resolve(subscription);else reject(subscription);
	    }).catch(err => {
	      reject(err);
	    });
	  });
	}
	function unsubscribePush() {
	  return new Promise((resolve, reject) => {
	    getPushSubscription().then(subscription => {
	      if (!subscription) reject('Please subscribe');else return subscription.unsubscribe();
	    }).then(result => {
	      resolve(result);
	    }).catch(err => {
	      reject(err);
	    });
	  });
	}
	function getPushSubscription() {
	  return new Promise((resolve, reject) => {
	    navigator.serviceWorker.ready.then(reg => {
	      return reg.pushManager.getSubscription();
	    }).then(subscription => {
	      if (!subscription) reject('Please subscribe');else resolve(subscription);
	    }).catch(err => {
	      reject(err);
	    });
	  });
	}
	function registerDevice(_x5, _x6) {
	  return _registerDevice.apply(this, arguments);
	}

	function _registerDevice() {
	  _registerDevice = _asyncToGenerator(function* (client, subscription) {
	    var result = yield client.invoke(new Api.account.RegisterDevice({
	      tokenType: 10,
	      token: JSON.stringify(subscription),
	      otherUids: [],
	      appSandbox: false,
	      secret: client.session.getAuthKey().getKey()
	    }));
	    (yield cachedDatabase).put('appPreferences', subscription, 'pushSubscription');
	    return result;
	  });
	  return _registerDevice.apply(this, arguments);
	}

	function unregisterDevice(_x7, _x8) {
	  return _unregisterDevice.apply(this, arguments);
	}

	function _unregisterDevice() {
	  _unregisterDevice = _asyncToGenerator(function* (client, subscription) {
	    var result = yield client.invoke(new Api.account.UnregisterDevice({
	      tokenType: 10,
	      token: JSON.stringify(subscription),
	      otherUids: []
	    }));
	    (yield cachedDatabase).delete('appPreferences', 'pushSubscription');
	    return result;
	  });
	  return _unregisterDevice.apply(this, arguments);
	}

	function manuallySubscribePushNotification(_x9) {
	  return _manuallySubscribePushNotification.apply(this, arguments);
	}

	function _manuallySubscribePushNotification() {
	  _manuallySubscribePushNotification = _asyncToGenerator(function* (client) {
	    try {
	      (yield cachedDatabase).delete('appPreferences', 'updatedPushSubscription');
	      var pushSubscription = yield (yield cachedDatabase).get('appPreferences', 'pushSubscription');

	      if (pushSubscription == null) {
	        yield unregisterDevice(client, pushSubscription);
	      }

	      try {
	        yield unsubscribePush();
	      } catch (err) {}

	      pushSubscription = yield subscribePush();
	      pushSubscription = pushSubscription.toJSON();
	      delete pushSubscription['expirationTime'];
	      yield registerDevice(client, pushSubscription);
	      return Promise.resolve(true);
	    } catch (err) {
	      return Promise.reject(err);
	    }
	  });
	  return _manuallySubscribePushNotification.apply(this, arguments);
	}

	var console_1$d = globals.console;
	var file$_ = "src/widgets/QRModal.svelte";

	function create_fragment$_(ctx) {
	  var div4;
	  var div3;
	  var div0;
	  var t0;
	  var t1;
	  var div2;
	  var div1;
	  var block = {
	    c: function create() {
	      div4 = element("div");
	      div3 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div2 = element("div");
	      div1 = element("div");
	      attr_dev(div0, "class", "kai-dialog-header svelte-1bpnhjc");
	      add_location(div0, file$_, 93, 4, 2801);
	      attr_dev(div1, "id", "qr-container");
	      add_location(div1, file$_, 95, 6, 2886);
	      attr_dev(div2, "class", "kai-dialog-body svelte-1bpnhjc");
	      add_location(div2, file$_, 94, 4, 2850);
	      attr_dev(div3, "class", "kai-dialog-content svelte-1bpnhjc");
	      add_location(div3, file$_, 92, 2, 2764);
	      attr_dev(div4, "class", "kai-dialog svelte-1bpnhjc");
	      add_location(div4, file$_, 91, 0, 2737);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div4, anchor);
	      append_dev(div4, div3);
	      append_dev(div3, div0);
	      append_dev(div0, t0);
	      append_dev(div3, t1);
	      append_dev(div3, div2);
	      append_dev(div2, div1);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div4);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$_.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$_($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('QRModal', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Log-In via QR Code' : _$$props$title;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? evt => {} : _$$props$onBackspace;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  var softwareKey;
	  var qrcode;
	  var regenerate = null;
	  var navOptions = {
	    softkeyRightListener(evt) {
	      onBackspace(evt);
	    },

	    backspaceListener(evt) {
	      onBackspace(evt);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function handleWebWorkerMessage(data) {
	    switch (data.type) {
	      case 5:
	        console.log('exportLoginToken:', data.params);

	        if (regenerate != null) {
	          clearTimeout(regenerate);
	          regenerate = null;
	        }

	        if (qrcode) {
	          qrcode.clear();
	        }

	        var container = document.getElementById('qr-container');
	        container.textContent = '';
	        var _data = `tg://login?token=${btoa(String.fromCharCode.apply(null, data.params.token))}`;
	        qrcode = new QRCode(container, {
	          text: _data,
	          width: 200,
	          height: 200,
	          colorDark: "#000000",
	          colorLight: "#ffffff",
	          correctLevel: QRCode.CorrectLevel.H
	        });
	        regenerate = setTimeout(() => {
	          exportLoginToken();
	        }, 31000);
	        break;

	      case -5:
	        console.error('exportLoginToken:', data.params);
	        break;
	    }
	  }

	  function exportLoginToken() {
	    var params = {
	      type: 5,
	      params: {
	        apiId: TelegramKeyHash.api_id,
	        apiHash: TelegramKeyHash.api_hash,
	        exceptIds: []
	      }
	    };
	    dispatchMessageToWorker.emit('message', params);
	  }

	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: false,
	        leftText: '',
	        centerText: '',
	        rightText: 'Cancel'
	      }
	    });
	    onOpened();
	    dispatchMessageToClient.addListener('message', handleWebWorkerMessage);
	    exportLoginToken();
	  });
	  onDestroy(() => {
	    if (regenerate != null) {
	      clearTimeout(regenerate);
	    }

	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed();
	    dispatchMessageToClient.removeListener('message', handleWebWorkerMessage);
	  });
	  var writable_props = ['title', 'onBackspace', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$d.warn(`<QRModal> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('onBackspace' in $$props) $$invalidate(1, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(2, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(3, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    TelegramKeyHash,
	    dispatchMessageToClient,
	    dispatchMessageToWorker,
	    title,
	    onBackspace,
	    onOpened,
	    onClosed,
	    softwareKey,
	    qrcode,
	    regenerate,
	    navOptions,
	    navInstance,
	    handleWebWorkerMessage,
	    exportLoginToken
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('onBackspace' in $$props) $$invalidate(1, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(2, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(3, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('qrcode' in $$props) qrcode = $$props.qrcode;
	    if ('regenerate' in $$props) regenerate = $$props.regenerate;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, onBackspace, onOpened, onClosed];
	}

	class QRModal extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$_, create_fragment$_, safe_not_equal, {
	      title: 0,
	      onBackspace: 1,
	      onOpened: 2,
	      onClosed: 3
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "QRModal",
	      options,
	      id: create_fragment$_.name
	    });
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[1];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[2];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[3];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	}

	var jsQR = createCommonjsModule(function (module, exports) {
	  (function webpackUniversalModuleDefinition(root, factory) {
	    module.exports = factory();
	  })(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
	    return (
	      /******/
	      function (modules) {
	        // webpackBootstrap

	        /******/
	        // The module cache

	        /******/
	        var installedModules = {};
	        /******/

	        /******/
	        // The require function

	        /******/

	        function __webpack_require__(moduleId) {
	          /******/

	          /******/
	          // Check if module is in cache

	          /******/
	          if (installedModules[moduleId]) {
	            /******/
	            return installedModules[moduleId].exports;
	            /******/
	          }
	          /******/
	          // Create a new module (and put it into the cache)

	          /******/


	          var module = installedModules[moduleId] = {
	            /******/
	            i: moduleId,

	            /******/
	            l: false,

	            /******/
	            exports: {}
	            /******/

	          };
	          /******/

	          /******/
	          // Execute the module function

	          /******/

	          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	          /******/

	          /******/
	          // Flag the module as loaded

	          /******/

	          module.l = true;
	          /******/

	          /******/
	          // Return the exports of the module

	          /******/

	          return module.exports;
	          /******/
	        }
	        /******/

	        /******/

	        /******/
	        // expose the modules object (__webpack_modules__)

	        /******/


	        __webpack_require__.m = modules;
	        /******/

	        /******/
	        // expose the module cache

	        /******/

	        __webpack_require__.c = installedModules;
	        /******/

	        /******/
	        // define getter function for harmony exports

	        /******/

	        __webpack_require__.d = function (exports, name, getter) {
	          /******/
	          if (!__webpack_require__.o(exports, name)) {
	            /******/
	            Object.defineProperty(exports, name, {
	              /******/
	              configurable: false,

	              /******/
	              enumerable: true,

	              /******/
	              get: getter
	              /******/

	            });
	            /******/
	          }
	          /******/

	        };
	        /******/

	        /******/
	        // getDefaultExport function for compatibility with non-harmony modules

	        /******/


	        __webpack_require__.n = function (module) {
	          /******/
	          var getter = module && module.__esModule ?
	          /******/
	          function getDefault() {
	            return module['default'];
	          } :
	          /******/
	          function getModuleExports() {
	            return module;
	          };
	          /******/

	          __webpack_require__.d(getter, 'a', getter);
	          /******/


	          return getter;
	          /******/
	        };
	        /******/

	        /******/
	        // Object.prototype.hasOwnProperty.call

	        /******/


	        __webpack_require__.o = function (object, property) {
	          return Object.prototype.hasOwnProperty.call(object, property);
	        };
	        /******/

	        /******/
	        // __webpack_public_path__

	        /******/


	        __webpack_require__.p = "";
	        /******/

	        /******/
	        // Load entry module and return exports

	        /******/

	        return __webpack_require__(__webpack_require__.s = 3);
	        /******/
	      }
	      /************************************************************************/

	      /******/
	      ([
	      /* 0 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var BitMatrix =
	        /** @class */
	        function () {
	          function BitMatrix(data, width) {
	            this.width = width;
	            this.height = data.length / width;
	            this.data = data;
	          }

	          BitMatrix.createEmpty = function (width, height) {
	            return new BitMatrix(new Uint8ClampedArray(width * height), width);
	          };

	          BitMatrix.prototype.get = function (x, y) {
	            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
	              return false;
	            }

	            return !!this.data[y * this.width + x];
	          };

	          BitMatrix.prototype.set = function (x, y, v) {
	            this.data[y * this.width + x] = v ? 1 : 0;
	          };

	          BitMatrix.prototype.setRegion = function (left, top, width, height, v) {
	            for (var y = top; y < top + height; y++) {
	              for (var x = left; x < left + width; x++) {
	                this.set(x, y, !!v);
	              }
	            }
	          };

	          return BitMatrix;
	        }();

	        exports.BitMatrix = BitMatrix;
	        /***/
	      },
	      /* 1 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var GenericGFPoly_1 = __webpack_require__(2);

	        function addOrSubtractGF(a, b) {
	          return a ^ b; // tslint:disable-line:no-bitwise
	        }

	        exports.addOrSubtractGF = addOrSubtractGF;

	        var GenericGF =
	        /** @class */
	        function () {
	          function GenericGF(primitive, size, genBase) {
	            this.primitive = primitive;
	            this.size = size;
	            this.generatorBase = genBase;
	            this.expTable = new Array(this.size);
	            this.logTable = new Array(this.size);
	            var x = 1;

	            for (var i = 0; i < this.size; i++) {
	              this.expTable[i] = x;
	              x = x * 2;

	              if (x >= this.size) {
	                x = (x ^ this.primitive) & this.size - 1; // tslint:disable-line:no-bitwise
	              }
	            }

	            for (var i = 0; i < this.size - 1; i++) {
	              this.logTable[this.expTable[i]] = i;
	            }

	            this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
	            this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
	          }

	          GenericGF.prototype.multiply = function (a, b) {
	            if (a === 0 || b === 0) {
	              return 0;
	            }

	            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
	          };

	          GenericGF.prototype.inverse = function (a) {
	            if (a === 0) {
	              throw new Error("Can't invert 0");
	            }

	            return this.expTable[this.size - this.logTable[a] - 1];
	          };

	          GenericGF.prototype.buildMonomial = function (degree, coefficient) {
	            if (degree < 0) {
	              throw new Error("Invalid monomial degree less than 0");
	            }

	            if (coefficient === 0) {
	              return this.zero;
	            }

	            var coefficients = new Uint8ClampedArray(degree + 1);
	            coefficients[0] = coefficient;
	            return new GenericGFPoly_1.default(this, coefficients);
	          };

	          GenericGF.prototype.log = function (a) {
	            if (a === 0) {
	              throw new Error("Can't take log(0)");
	            }

	            return this.logTable[a];
	          };

	          GenericGF.prototype.exp = function (a) {
	            return this.expTable[a];
	          };

	          return GenericGF;
	        }();

	        exports.default = GenericGF;
	        /***/
	      },
	      /* 2 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var GenericGF_1 = __webpack_require__(1);

	        var GenericGFPoly =
	        /** @class */
	        function () {
	          function GenericGFPoly(field, coefficients) {
	            if (coefficients.length === 0) {
	              throw new Error("No coefficients.");
	            }

	            this.field = field;
	            var coefficientsLength = coefficients.length;

	            if (coefficientsLength > 1 && coefficients[0] === 0) {
	              // Leading term must be non-zero for anything except the constant polynomial "0"
	              var firstNonZero = 1;

	              while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
	                firstNonZero++;
	              }

	              if (firstNonZero === coefficientsLength) {
	                this.coefficients = field.zero.coefficients;
	              } else {
	                this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);

	                for (var i = 0; i < this.coefficients.length; i++) {
	                  this.coefficients[i] = coefficients[firstNonZero + i];
	                }
	              }
	            } else {
	              this.coefficients = coefficients;
	            }
	          }

	          GenericGFPoly.prototype.degree = function () {
	            return this.coefficients.length - 1;
	          };

	          GenericGFPoly.prototype.isZero = function () {
	            return this.coefficients[0] === 0;
	          };

	          GenericGFPoly.prototype.getCoefficient = function (degree) {
	            return this.coefficients[this.coefficients.length - 1 - degree];
	          };

	          GenericGFPoly.prototype.addOrSubtract = function (other) {
	            var _a;

	            if (this.isZero()) {
	              return other;
	            }

	            if (other.isZero()) {
	              return this;
	            }

	            var smallerCoefficients = this.coefficients;
	            var largerCoefficients = other.coefficients;

	            if (smallerCoefficients.length > largerCoefficients.length) {
	              _a = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a[0], largerCoefficients = _a[1];
	            }

	            var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
	            var lengthDiff = largerCoefficients.length - smallerCoefficients.length;

	            for (var i = 0; i < lengthDiff; i++) {
	              sumDiff[i] = largerCoefficients[i];
	            }

	            for (var i = lengthDiff; i < largerCoefficients.length; i++) {
	              sumDiff[i] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
	            }

	            return new GenericGFPoly(this.field, sumDiff);
	          };

	          GenericGFPoly.prototype.multiply = function (scalar) {
	            if (scalar === 0) {
	              return this.field.zero;
	            }

	            if (scalar === 1) {
	              return this;
	            }

	            var size = this.coefficients.length;
	            var product = new Uint8ClampedArray(size);

	            for (var i = 0; i < size; i++) {
	              product[i] = this.field.multiply(this.coefficients[i], scalar);
	            }

	            return new GenericGFPoly(this.field, product);
	          };

	          GenericGFPoly.prototype.multiplyPoly = function (other) {
	            if (this.isZero() || other.isZero()) {
	              return this.field.zero;
	            }

	            var aCoefficients = this.coefficients;
	            var aLength = aCoefficients.length;
	            var bCoefficients = other.coefficients;
	            var bLength = bCoefficients.length;
	            var product = new Uint8ClampedArray(aLength + bLength - 1);

	            for (var i = 0; i < aLength; i++) {
	              var aCoeff = aCoefficients[i];

	              for (var j = 0; j < bLength; j++) {
	                product[i + j] = GenericGF_1.addOrSubtractGF(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
	              }
	            }

	            return new GenericGFPoly(this.field, product);
	          };

	          GenericGFPoly.prototype.multiplyByMonomial = function (degree, coefficient) {
	            if (degree < 0) {
	              throw new Error("Invalid degree less than 0");
	            }

	            if (coefficient === 0) {
	              return this.field.zero;
	            }

	            var size = this.coefficients.length;
	            var product = new Uint8ClampedArray(size + degree);

	            for (var i = 0; i < size; i++) {
	              product[i] = this.field.multiply(this.coefficients[i], coefficient);
	            }

	            return new GenericGFPoly(this.field, product);
	          };

	          GenericGFPoly.prototype.evaluateAt = function (a) {
	            var result = 0;

	            if (a === 0) {
	              // Just return the x^0 coefficient
	              return this.getCoefficient(0);
	            }

	            var size = this.coefficients.length;

	            if (a === 1) {
	              // Just the sum of the coefficients
	              this.coefficients.forEach(function (coefficient) {
	                result = GenericGF_1.addOrSubtractGF(result, coefficient);
	              });
	              return result;
	            }

	            result = this.coefficients[0];

	            for (var i = 1; i < size; i++) {
	              result = GenericGF_1.addOrSubtractGF(this.field.multiply(a, result), this.coefficients[i]);
	            }

	            return result;
	          };

	          return GenericGFPoly;
	        }();

	        exports.default = GenericGFPoly;
	        /***/
	      },
	      /* 3 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var binarizer_1 = __webpack_require__(4);

	        var decoder_1 = __webpack_require__(5);

	        var extractor_1 = __webpack_require__(11);

	        var locator_1 = __webpack_require__(12);

	        function scan(matrix) {
	          var locations = locator_1.locate(matrix);

	          if (!locations) {
	            return null;
	          }

	          for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
	            var location_1 = locations_1[_i];
	            var extracted = extractor_1.extract(matrix, location_1);
	            var decoded = decoder_1.decode(extracted.matrix);

	            if (decoded) {
	              return {
	                binaryData: decoded.bytes,
	                data: decoded.text,
	                chunks: decoded.chunks,
	                version: decoded.version,
	                location: {
	                  topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
	                  topLeftCorner: extracted.mappingFunction(0, 0),
	                  bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
	                  bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
	                  topRightFinderPattern: location_1.topRight,
	                  topLeftFinderPattern: location_1.topLeft,
	                  bottomLeftFinderPattern: location_1.bottomLeft,
	                  bottomRightAlignmentPattern: location_1.alignmentPattern
	                }
	              };
	            }
	          }

	          return null;
	        }

	        var defaultOptions = {
	          inversionAttempts: "attemptBoth"
	        };

	        function jsQR(data, width, height, providedOptions) {
	          if (providedOptions === void 0) {
	            providedOptions = {};
	          }

	          var options = defaultOptions;
	          Object.keys(options || {}).forEach(function (opt) {
	            options[opt] = providedOptions[opt] || options[opt];
	          });
	          var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
	          var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";

	          var _a = binarizer_1.binarize(data, width, height, shouldInvert),
	              binarized = _a.binarized,
	              inverted = _a.inverted;

	          var result = scan(tryInvertedFirst ? inverted : binarized);

	          if (!result && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
	            result = scan(tryInvertedFirst ? binarized : inverted);
	          }

	          return result;
	        }

	        jsQR.default = jsQR;
	        exports.default = jsQR;
	        /***/
	      },
	      /* 4 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var BitMatrix_1 = __webpack_require__(0);

	        var REGION_SIZE = 8;
	        var MIN_DYNAMIC_RANGE = 24;

	        function numBetween(value, min, max) {
	          return value < min ? min : value > max ? max : value;
	        } // Like BitMatrix but accepts arbitry Uint8 values


	        var Matrix =
	        /** @class */
	        function () {
	          function Matrix(width, height) {
	            this.width = width;
	            this.data = new Uint8ClampedArray(width * height);
	          }

	          Matrix.prototype.get = function (x, y) {
	            return this.data[y * this.width + x];
	          };

	          Matrix.prototype.set = function (x, y, value) {
	            this.data[y * this.width + x] = value;
	          };

	          return Matrix;
	        }();

	        function binarize(data, width, height, returnInverted) {
	          if (data.length !== width * height * 4) {
	            throw new Error("Malformed data passed to binarizer.");
	          } // Convert image to greyscale


	          var greyscalePixels = new Matrix(width, height);

	          for (var x = 0; x < width; x++) {
	            for (var y = 0; y < height; y++) {
	              var r = data[(y * width + x) * 4 + 0];
	              var g = data[(y * width + x) * 4 + 1];
	              var b = data[(y * width + x) * 4 + 2];
	              greyscalePixels.set(x, y, 0.2126 * r + 0.7152 * g + 0.0722 * b);
	            }
	          }

	          var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
	          var verticalRegionCount = Math.ceil(height / REGION_SIZE);
	          var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);

	          for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
	            for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
	              var sum = 0;
	              var min = Infinity;
	              var max = 0;

	              for (var y = 0; y < REGION_SIZE; y++) {
	                for (var x = 0; x < REGION_SIZE; x++) {
	                  var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);
	                  sum += pixelLumosity;
	                  min = Math.min(min, pixelLumosity);
	                  max = Math.max(max, pixelLumosity);
	                }
	              }

	              var average = sum / Math.pow(REGION_SIZE, 2);

	              if (max - min <= MIN_DYNAMIC_RANGE) {
	                // If variation within the block is low, assume this is a block with only light or only
	                // dark pixels. In that case we do not want to use the average, as it would divide this
	                // low contrast area into black and white pixels, essentially creating data out of noise.
	                //
	                // Default the blackpoint for these blocks to be half the min - effectively white them out
	                average = min / 2;

	                if (verticalRegion > 0 && hortizontalRegion > 0) {
	                  // Correct the "white background" assumption for blocks that have neighbors by comparing
	                  // the pixels in this block to the previously calculated black points. This is based on
	                  // the fact that dark barcode symbology is always surrounded by some amount of light
	                  // background for which reasonable black point estimates were made. The bp estimated at
	                  // the boundaries is used for the interior.
	                  // The (min < bp) is arbitrary but works better than other heuristics that were tried.
	                  var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) + 2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) + blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;

	                  if (min < averageNeighborBlackPoint) {
	                    average = averageNeighborBlackPoint;
	                  }
	                }
	              }

	              blackPoints.set(hortizontalRegion, verticalRegion, average);
	            }
	          }

	          var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
	          var inverted = null;

	          if (returnInverted) {
	            inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
	          }

	          for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
	            for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
	              var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
	              var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
	              var sum = 0;

	              for (var xRegion = -2; xRegion <= 2; xRegion++) {
	                for (var yRegion = -2; yRegion <= 2; yRegion++) {
	                  sum += blackPoints.get(left + xRegion, top_1 + yRegion);
	                }
	              }

	              var threshold = sum / 25;

	              for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
	                for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
	                  var x = hortizontalRegion * REGION_SIZE + xRegion;
	                  var y = verticalRegion * REGION_SIZE + yRegion;
	                  var lum = greyscalePixels.get(x, y);
	                  binarized.set(x, y, lum <= threshold);

	                  if (returnInverted) {
	                    inverted.set(x, y, !(lum <= threshold));
	                  }
	                }
	              }
	            }
	          }

	          if (returnInverted) {
	            return {
	              binarized: binarized,
	              inverted: inverted
	            };
	          }

	          return {
	            binarized: binarized
	          };
	        }

	        exports.binarize = binarize;
	        /***/
	      },
	      /* 5 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var BitMatrix_1 = __webpack_require__(0);

	        var decodeData_1 = __webpack_require__(6);

	        var reedsolomon_1 = __webpack_require__(9);

	        var version_1 = __webpack_require__(10); // tslint:disable:no-bitwise


	        function numBitsDiffering(x, y) {
	          var z = x ^ y;
	          var bitCount = 0;

	          while (z) {
	            bitCount++;
	            z &= z - 1;
	          }

	          return bitCount;
	        }

	        function pushBit(bit, byte) {
	          return byte << 1 | bit;
	        } // tslint:enable:no-bitwise


	        var FORMAT_INFO_TABLE = [{
	          bits: 0x5412,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 0
	          }
	        }, {
	          bits: 0x5125,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 1
	          }
	        }, {
	          bits: 0x5E7C,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 2
	          }
	        }, {
	          bits: 0x5B4B,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 3
	          }
	        }, {
	          bits: 0x45F9,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 4
	          }
	        }, {
	          bits: 0x40CE,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 5
	          }
	        }, {
	          bits: 0x4F97,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 6
	          }
	        }, {
	          bits: 0x4AA0,
	          formatInfo: {
	            errorCorrectionLevel: 1,
	            dataMask: 7
	          }
	        }, {
	          bits: 0x77C4,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 0
	          }
	        }, {
	          bits: 0x72F3,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 1
	          }
	        }, {
	          bits: 0x7DAA,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 2
	          }
	        }, {
	          bits: 0x789D,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 3
	          }
	        }, {
	          bits: 0x662F,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 4
	          }
	        }, {
	          bits: 0x6318,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 5
	          }
	        }, {
	          bits: 0x6C41,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 6
	          }
	        }, {
	          bits: 0x6976,
	          formatInfo: {
	            errorCorrectionLevel: 0,
	            dataMask: 7
	          }
	        }, {
	          bits: 0x1689,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 0
	          }
	        }, {
	          bits: 0x13BE,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 1
	          }
	        }, {
	          bits: 0x1CE7,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 2
	          }
	        }, {
	          bits: 0x19D0,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 3
	          }
	        }, {
	          bits: 0x0762,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 4
	          }
	        }, {
	          bits: 0x0255,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 5
	          }
	        }, {
	          bits: 0x0D0C,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 6
	          }
	        }, {
	          bits: 0x083B,
	          formatInfo: {
	            errorCorrectionLevel: 3,
	            dataMask: 7
	          }
	        }, {
	          bits: 0x355F,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 0
	          }
	        }, {
	          bits: 0x3068,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 1
	          }
	        }, {
	          bits: 0x3F31,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 2
	          }
	        }, {
	          bits: 0x3A06,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 3
	          }
	        }, {
	          bits: 0x24B4,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 4
	          }
	        }, {
	          bits: 0x2183,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 5
	          }
	        }, {
	          bits: 0x2EDA,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 6
	          }
	        }, {
	          bits: 0x2BED,
	          formatInfo: {
	            errorCorrectionLevel: 2,
	            dataMask: 7
	          }
	        }];
	        var DATA_MASKS = [function (p) {
	          return (p.y + p.x) % 2 === 0;
	        }, function (p) {
	          return p.y % 2 === 0;
	        }, function (p) {
	          return p.x % 3 === 0;
	        }, function (p) {
	          return (p.y + p.x) % 3 === 0;
	        }, function (p) {
	          return (Math.floor(p.y / 2) + Math.floor(p.x / 3)) % 2 === 0;
	        }, function (p) {
	          return p.x * p.y % 2 + p.x * p.y % 3 === 0;
	        }, function (p) {
	          return (p.y * p.x % 2 + p.y * p.x % 3) % 2 === 0;
	        }, function (p) {
	          return ((p.y + p.x) % 2 + p.y * p.x % 3) % 2 === 0;
	        }];

	        function buildFunctionPatternMask(version) {
	          var dimension = 17 + 4 * version.versionNumber;
	          var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
	          matrix.setRegion(0, 0, 9, 9, true); // Top left finder pattern + separator + format

	          matrix.setRegion(dimension - 8, 0, 8, 9, true); // Top right finder pattern + separator + format

	          matrix.setRegion(0, dimension - 8, 9, 8, true); // Bottom left finder pattern + separator + format
	          // Alignment patterns

	          for (var _i = 0, _a = version.alignmentPatternCenters; _i < _a.length; _i++) {
	            var x = _a[_i];

	            for (var _b = 0, _c = version.alignmentPatternCenters; _b < _c.length; _b++) {
	              var y = _c[_b];

	              if (!(x === 6 && y === 6 || x === 6 && y === dimension - 7 || x === dimension - 7 && y === 6)) {
	                matrix.setRegion(x - 2, y - 2, 5, 5, true);
	              }
	            }
	          }

	          matrix.setRegion(6, 9, 1, dimension - 17, true); // Vertical timing pattern

	          matrix.setRegion(9, 6, dimension - 17, 1, true); // Horizontal timing pattern

	          if (version.versionNumber > 6) {
	            matrix.setRegion(dimension - 11, 0, 3, 6, true); // Version info, top right

	            matrix.setRegion(0, dimension - 11, 6, 3, true); // Version info, bottom left
	          }

	          return matrix;
	        }

	        function readCodewords(matrix, version, formatInfo) {
	          var dataMask = DATA_MASKS[formatInfo.dataMask];
	          var dimension = matrix.height;
	          var functionPatternMask = buildFunctionPatternMask(version);
	          var codewords = [];
	          var currentByte = 0;
	          var bitsRead = 0; // Read columns in pairs, from right to left

	          var readingUp = true;

	          for (var columnIndex = dimension - 1; columnIndex > 0; columnIndex -= 2) {
	            if (columnIndex === 6) {
	              // Skip whole column with vertical alignment pattern;
	              columnIndex--;
	            }

	            for (var i = 0; i < dimension; i++) {
	              var y = readingUp ? dimension - 1 - i : i;

	              for (var columnOffset = 0; columnOffset < 2; columnOffset++) {
	                var x = columnIndex - columnOffset;

	                if (!functionPatternMask.get(x, y)) {
	                  bitsRead++;
	                  var bit = matrix.get(x, y);

	                  if (dataMask({
	                    y: y,
	                    x: x
	                  })) {
	                    bit = !bit;
	                  }

	                  currentByte = pushBit(bit, currentByte);

	                  if (bitsRead === 8) {
	                    // Whole bytes
	                    codewords.push(currentByte);
	                    bitsRead = 0;
	                    currentByte = 0;
	                  }
	                }
	              }
	            }

	            readingUp = !readingUp;
	          }

	          return codewords;
	        }

	        function readVersion(matrix) {
	          var dimension = matrix.height;
	          var provisionalVersion = Math.floor((dimension - 17) / 4);

	          if (provisionalVersion <= 6) {
	            // 6 and under dont have version info in the QR code
	            return version_1.VERSIONS[provisionalVersion - 1];
	          }

	          var topRightVersionBits = 0;

	          for (var y = 5; y >= 0; y--) {
	            for (var x = dimension - 9; x >= dimension - 11; x--) {
	              topRightVersionBits = pushBit(matrix.get(x, y), topRightVersionBits);
	            }
	          }

	          var bottomLeftVersionBits = 0;

	          for (var x = 5; x >= 0; x--) {
	            for (var y = dimension - 9; y >= dimension - 11; y--) {
	              bottomLeftVersionBits = pushBit(matrix.get(x, y), bottomLeftVersionBits);
	            }
	          }

	          var bestDifference = Infinity;
	          var bestVersion;

	          for (var _i = 0, VERSIONS_1 = version_1.VERSIONS; _i < VERSIONS_1.length; _i++) {
	            var version = VERSIONS_1[_i];

	            if (version.infoBits === topRightVersionBits || version.infoBits === bottomLeftVersionBits) {
	              return version;
	            }

	            var difference = numBitsDiffering(topRightVersionBits, version.infoBits);

	            if (difference < bestDifference) {
	              bestVersion = version;
	              bestDifference = difference;
	            }

	            difference = numBitsDiffering(bottomLeftVersionBits, version.infoBits);

	            if (difference < bestDifference) {
	              bestVersion = version;
	              bestDifference = difference;
	            }
	          } // We can tolerate up to 3 bits of error since no two version info codewords will
	          // differ in less than 8 bits.


	          if (bestDifference <= 3) {
	            return bestVersion;
	          }
	        }

	        function readFormatInformation(matrix) {
	          var topLeftFormatInfoBits = 0;

	          for (var x = 0; x <= 8; x++) {
	            if (x !== 6) {
	              // Skip timing pattern bit
	              topLeftFormatInfoBits = pushBit(matrix.get(x, 8), topLeftFormatInfoBits);
	            }
	          }

	          for (var y = 7; y >= 0; y--) {
	            if (y !== 6) {
	              // Skip timing pattern bit
	              topLeftFormatInfoBits = pushBit(matrix.get(8, y), topLeftFormatInfoBits);
	            }
	          }

	          var dimension = matrix.height;
	          var topRightBottomRightFormatInfoBits = 0;

	          for (var y = dimension - 1; y >= dimension - 7; y--) {
	            // bottom left
	            topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y), topRightBottomRightFormatInfoBits);
	          }

	          for (var x = dimension - 8; x < dimension; x++) {
	            // top right
	            topRightBottomRightFormatInfoBits = pushBit(matrix.get(x, 8), topRightBottomRightFormatInfoBits);
	          }

	          var bestDifference = Infinity;
	          var bestFormatInfo = null;

	          for (var _i = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE; _i < FORMAT_INFO_TABLE_1.length; _i++) {
	            var _a = FORMAT_INFO_TABLE_1[_i],
	                bits = _a.bits,
	                formatInfo = _a.formatInfo;

	            if (bits === topLeftFormatInfoBits || bits === topRightBottomRightFormatInfoBits) {
	              return formatInfo;
	            }

	            var difference = numBitsDiffering(topLeftFormatInfoBits, bits);

	            if (difference < bestDifference) {
	              bestFormatInfo = formatInfo;
	              bestDifference = difference;
	            }

	            if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) {
	              // also try the other option
	              difference = numBitsDiffering(topRightBottomRightFormatInfoBits, bits);

	              if (difference < bestDifference) {
	                bestFormatInfo = formatInfo;
	                bestDifference = difference;
	              }
	            }
	          } // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits differing means we found a match


	          if (bestDifference <= 3) {
	            return bestFormatInfo;
	          }

	          return null;
	        }

	        function getDataBlocks(codewords, version, ecLevel) {
	          var ecInfo = version.errorCorrectionLevels[ecLevel];
	          var dataBlocks = [];
	          var totalCodewords = 0;
	          ecInfo.ecBlocks.forEach(function (block) {
	            for (var i = 0; i < block.numBlocks; i++) {
	              dataBlocks.push({
	                numDataCodewords: block.dataCodewordsPerBlock,
	                codewords: []
	              });
	              totalCodewords += block.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
	            }
	          }); // In some cases the QR code will be malformed enough that we pull off more or less than we should.
	          // If we pull off less there's nothing we can do.
	          // If we pull off more we can safely truncate

	          if (codewords.length < totalCodewords) {
	            return null;
	          }

	          codewords = codewords.slice(0, totalCodewords);
	          var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock; // Pull codewords to fill the blocks up to the minimum size

	          for (var i = 0; i < shortBlockSize; i++) {
	            for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {
	              var dataBlock = dataBlocks_1[_i];
	              dataBlock.codewords.push(codewords.shift());
	            }
	          } // If there are any large blocks, pull codewords to fill the last element of those


	          if (ecInfo.ecBlocks.length > 1) {
	            var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
	            var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;

	            for (var i = 0; i < largeBlockCount; i++) {
	              dataBlocks[smallBlockCount + i].codewords.push(codewords.shift());
	            }
	          } // Add the rest of the codewords to the blocks. These are the error correction codewords.


	          while (codewords.length > 0) {
	            for (var _a = 0, dataBlocks_2 = dataBlocks; _a < dataBlocks_2.length; _a++) {
	              var dataBlock = dataBlocks_2[_a];
	              dataBlock.codewords.push(codewords.shift());
	            }
	          }

	          return dataBlocks;
	        }

	        function decodeMatrix(matrix) {
	          var version = readVersion(matrix);

	          if (!version) {
	            return null;
	          }

	          var formatInfo = readFormatInformation(matrix);

	          if (!formatInfo) {
	            return null;
	          }

	          var codewords = readCodewords(matrix, version, formatInfo);
	          var dataBlocks = getDataBlocks(codewords, version, formatInfo.errorCorrectionLevel);

	          if (!dataBlocks) {
	            return null;
	          } // Count total number of data bytes


	          var totalBytes = dataBlocks.reduce(function (a, b) {
	            return a + b.numDataCodewords;
	          }, 0);
	          var resultBytes = new Uint8ClampedArray(totalBytes);
	          var resultIndex = 0;

	          for (var _i = 0, dataBlocks_3 = dataBlocks; _i < dataBlocks_3.length; _i++) {
	            var dataBlock = dataBlocks_3[_i];
	            var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);

	            if (!correctedBytes) {
	              return null;
	            }

	            for (var i = 0; i < dataBlock.numDataCodewords; i++) {
	              resultBytes[resultIndex++] = correctedBytes[i];
	            }
	          }

	          try {
	            return decodeData_1.decode(resultBytes, version.versionNumber);
	          } catch (_a) {
	            return null;
	          }
	        }

	        function decode(matrix) {
	          if (matrix == null) {
	            return null;
	          }

	          var result = decodeMatrix(matrix);

	          if (result) {
	            return result;
	          } // Decoding didn't work, try mirroring the QR across the topLeft -> bottomRight line.


	          for (var x = 0; x < matrix.width; x++) {
	            for (var y = x + 1; y < matrix.height; y++) {
	              if (matrix.get(x, y) !== matrix.get(y, x)) {
	                matrix.set(x, y, !matrix.get(x, y));
	                matrix.set(y, x, !matrix.get(y, x));
	              }
	            }
	          }

	          return decodeMatrix(matrix);
	        }

	        exports.decode = decode;
	        /***/
	      },
	      /* 6 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        }); // tslint:disable:no-bitwise

	        var BitStream_1 = __webpack_require__(7);

	        var shiftJISTable_1 = __webpack_require__(8);

	        var Mode;

	        (function (Mode) {
	          Mode["Numeric"] = "numeric";
	          Mode["Alphanumeric"] = "alphanumeric";
	          Mode["Byte"] = "byte";
	          Mode["Kanji"] = "kanji";
	          Mode["ECI"] = "eci";
	        })(Mode = exports.Mode || (exports.Mode = {}));

	        var ModeByte;

	        (function (ModeByte) {
	          ModeByte[ModeByte["Terminator"] = 0] = "Terminator";
	          ModeByte[ModeByte["Numeric"] = 1] = "Numeric";
	          ModeByte[ModeByte["Alphanumeric"] = 2] = "Alphanumeric";
	          ModeByte[ModeByte["Byte"] = 4] = "Byte";
	          ModeByte[ModeByte["Kanji"] = 8] = "Kanji";
	          ModeByte[ModeByte["ECI"] = 7] = "ECI"; // StructuredAppend = 0x3,
	          // FNC1FirstPosition = 0x5,
	          // FNC1SecondPosition = 0x9,
	        })(ModeByte || (ModeByte = {}));

	        function decodeNumeric(stream, size) {
	          var bytes = [];
	          var text = "";
	          var characterCountSize = [10, 12, 14][size];
	          var length = stream.readBits(characterCountSize); // Read digits in groups of 3

	          while (length >= 3) {
	            var num = stream.readBits(10);

	            if (num >= 1000) {
	              throw new Error("Invalid numeric value above 999");
	            }

	            var a = Math.floor(num / 100);
	            var b = Math.floor(num / 10) % 10;
	            var c = num % 10;
	            bytes.push(48 + a, 48 + b, 48 + c);
	            text += a.toString() + b.toString() + c.toString();
	            length -= 3;
	          } // If the number of digits aren't a multiple of 3, the remaining digits are special cased.


	          if (length === 2) {
	            var num = stream.readBits(7);

	            if (num >= 100) {
	              throw new Error("Invalid numeric value above 99");
	            }

	            var a = Math.floor(num / 10);
	            var b = num % 10;
	            bytes.push(48 + a, 48 + b);
	            text += a.toString() + b.toString();
	          } else if (length === 1) {
	            var num = stream.readBits(4);

	            if (num >= 10) {
	              throw new Error("Invalid numeric value above 9");
	            }

	            bytes.push(48 + num);
	            text += num.toString();
	          }

	          return {
	            bytes: bytes,
	            text: text
	          };
	        }

	        var AlphanumericCharacterCodes = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

	        function decodeAlphanumeric(stream, size) {
	          var bytes = [];
	          var text = "";
	          var characterCountSize = [9, 11, 13][size];
	          var length = stream.readBits(characterCountSize);

	          while (length >= 2) {
	            var v = stream.readBits(11);
	            var a = Math.floor(v / 45);
	            var b = v % 45;
	            bytes.push(AlphanumericCharacterCodes[a].charCodeAt(0), AlphanumericCharacterCodes[b].charCodeAt(0));
	            text += AlphanumericCharacterCodes[a] + AlphanumericCharacterCodes[b];
	            length -= 2;
	          }

	          if (length === 1) {
	            var a = stream.readBits(6);
	            bytes.push(AlphanumericCharacterCodes[a].charCodeAt(0));
	            text += AlphanumericCharacterCodes[a];
	          }

	          return {
	            bytes: bytes,
	            text: text
	          };
	        }

	        function decodeByte(stream, size) {
	          var bytes = [];
	          var text = "";
	          var characterCountSize = [8, 16, 16][size];
	          var length = stream.readBits(characterCountSize);

	          for (var i = 0; i < length; i++) {
	            var b = stream.readBits(8);
	            bytes.push(b);
	          }

	          try {
	            text += decodeURIComponent(bytes.map(function (b) {
	              return "%" + ("0" + b.toString(16)).substr(-2);
	            }).join(""));
	          } catch (_a) {// failed to decode
	          }

	          return {
	            bytes: bytes,
	            text: text
	          };
	        }

	        function decodeKanji(stream, size) {
	          var bytes = [];
	          var text = "";
	          var characterCountSize = [8, 10, 12][size];
	          var length = stream.readBits(characterCountSize);

	          for (var i = 0; i < length; i++) {
	            var k = stream.readBits(13);
	            var c = Math.floor(k / 0xC0) << 8 | k % 0xC0;

	            if (c < 0x1F00) {
	              c += 0x8140;
	            } else {
	              c += 0xC140;
	            }

	            bytes.push(c >> 8, c & 0xFF);
	            text += String.fromCharCode(shiftJISTable_1.shiftJISTable[c]);
	          }

	          return {
	            bytes: bytes,
	            text: text
	          };
	        }

	        function decode(data, version) {
	          var _a, _b, _c, _d;

	          var stream = new BitStream_1.BitStream(data); // There are 3 'sizes' based on the version. 1-9 is small (0), 10-26 is medium (1) and 27-40 is large (2).

	          var size = version <= 9 ? 0 : version <= 26 ? 1 : 2;
	          var result = {
	            text: "",
	            bytes: [],
	            chunks: [],
	            version: version
	          };

	          while (stream.available() >= 4) {
	            var mode = stream.readBits(4);

	            if (mode === ModeByte.Terminator) {
	              return result;
	            } else if (mode === ModeByte.ECI) {
	              if (stream.readBits(1) === 0) {
	                result.chunks.push({
	                  type: Mode.ECI,
	                  assignmentNumber: stream.readBits(7)
	                });
	              } else if (stream.readBits(1) === 0) {
	                result.chunks.push({
	                  type: Mode.ECI,
	                  assignmentNumber: stream.readBits(14)
	                });
	              } else if (stream.readBits(1) === 0) {
	                result.chunks.push({
	                  type: Mode.ECI,
	                  assignmentNumber: stream.readBits(21)
	                });
	              } else {
	                // ECI data seems corrupted
	                result.chunks.push({
	                  type: Mode.ECI,
	                  assignmentNumber: -1
	                });
	              }
	            } else if (mode === ModeByte.Numeric) {
	              var numericResult = decodeNumeric(stream, size);
	              result.text += numericResult.text;

	              (_a = result.bytes).push.apply(_a, numericResult.bytes);

	              result.chunks.push({
	                type: Mode.Numeric,
	                text: numericResult.text
	              });
	            } else if (mode === ModeByte.Alphanumeric) {
	              var alphanumericResult = decodeAlphanumeric(stream, size);
	              result.text += alphanumericResult.text;

	              (_b = result.bytes).push.apply(_b, alphanumericResult.bytes);

	              result.chunks.push({
	                type: Mode.Alphanumeric,
	                text: alphanumericResult.text
	              });
	            } else if (mode === ModeByte.Byte) {
	              var byteResult = decodeByte(stream, size);
	              result.text += byteResult.text;

	              (_c = result.bytes).push.apply(_c, byteResult.bytes);

	              result.chunks.push({
	                type: Mode.Byte,
	                bytes: byteResult.bytes,
	                text: byteResult.text
	              });
	            } else if (mode === ModeByte.Kanji) {
	              var kanjiResult = decodeKanji(stream, size);
	              result.text += kanjiResult.text;

	              (_d = result.bytes).push.apply(_d, kanjiResult.bytes);

	              result.chunks.push({
	                type: Mode.Kanji,
	                bytes: kanjiResult.bytes,
	                text: kanjiResult.text
	              });
	            }
	          } // If there is no data left, or the remaining bits are all 0, then that counts as a termination marker


	          if (stream.available() === 0 || stream.readBits(stream.available()) === 0) {
	            return result;
	          }
	        }

	        exports.decode = decode;
	        /***/
	      },
	      /* 7 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var BitStream =
	        /** @class */
	        function () {
	          function BitStream(bytes) {
	            this.byteOffset = 0;
	            this.bitOffset = 0;
	            this.bytes = bytes;
	          }

	          BitStream.prototype.readBits = function (numBits) {
	            if (numBits < 1 || numBits > 32 || numBits > this.available()) {
	              throw new Error("Cannot read " + numBits.toString() + " bits");
	            }

	            var result = 0; // First, read remainder from current byte

	            if (this.bitOffset > 0) {
	              var bitsLeft = 8 - this.bitOffset;
	              var toRead = numBits < bitsLeft ? numBits : bitsLeft;
	              var bitsToNotRead = bitsLeft - toRead;
	              var mask = 0xFF >> 8 - toRead << bitsToNotRead;
	              result = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
	              numBits -= toRead;
	              this.bitOffset += toRead;

	              if (this.bitOffset === 8) {
	                this.bitOffset = 0;
	                this.byteOffset++;
	              }
	            } // Next read whole bytes


	            if (numBits > 0) {
	              while (numBits >= 8) {
	                result = result << 8 | this.bytes[this.byteOffset] & 0xFF;
	                this.byteOffset++;
	                numBits -= 8;
	              } // Finally read a partial byte


	              if (numBits > 0) {
	                var bitsToNotRead = 8 - numBits;
	                var mask = 0xFF >> bitsToNotRead << bitsToNotRead;
	                result = result << numBits | (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
	                this.bitOffset += numBits;
	              }
	            }

	            return result;
	          };

	          BitStream.prototype.available = function () {
	            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
	          };

	          return BitStream;
	        }();

	        exports.BitStream = BitStream;
	        /***/
	      },
	      /* 8 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });
	        exports.shiftJISTable = {
	          0x20: 0x0020,
	          0x21: 0x0021,
	          0x22: 0x0022,
	          0x23: 0x0023,
	          0x24: 0x0024,
	          0x25: 0x0025,
	          0x26: 0x0026,
	          0x27: 0x0027,
	          0x28: 0x0028,
	          0x29: 0x0029,
	          0x2A: 0x002A,
	          0x2B: 0x002B,
	          0x2C: 0x002C,
	          0x2D: 0x002D,
	          0x2E: 0x002E,
	          0x2F: 0x002F,
	          0x30: 0x0030,
	          0x31: 0x0031,
	          0x32: 0x0032,
	          0x33: 0x0033,
	          0x34: 0x0034,
	          0x35: 0x0035,
	          0x36: 0x0036,
	          0x37: 0x0037,
	          0x38: 0x0038,
	          0x39: 0x0039,
	          0x3A: 0x003A,
	          0x3B: 0x003B,
	          0x3C: 0x003C,
	          0x3D: 0x003D,
	          0x3E: 0x003E,
	          0x3F: 0x003F,
	          0x40: 0x0040,
	          0x41: 0x0041,
	          0x42: 0x0042,
	          0x43: 0x0043,
	          0x44: 0x0044,
	          0x45: 0x0045,
	          0x46: 0x0046,
	          0x47: 0x0047,
	          0x48: 0x0048,
	          0x49: 0x0049,
	          0x4A: 0x004A,
	          0x4B: 0x004B,
	          0x4C: 0x004C,
	          0x4D: 0x004D,
	          0x4E: 0x004E,
	          0x4F: 0x004F,
	          0x50: 0x0050,
	          0x51: 0x0051,
	          0x52: 0x0052,
	          0x53: 0x0053,
	          0x54: 0x0054,
	          0x55: 0x0055,
	          0x56: 0x0056,
	          0x57: 0x0057,
	          0x58: 0x0058,
	          0x59: 0x0059,
	          0x5A: 0x005A,
	          0x5B: 0x005B,
	          0x5C: 0x00A5,
	          0x5D: 0x005D,
	          0x5E: 0x005E,
	          0x5F: 0x005F,
	          0x60: 0x0060,
	          0x61: 0x0061,
	          0x62: 0x0062,
	          0x63: 0x0063,
	          0x64: 0x0064,
	          0x65: 0x0065,
	          0x66: 0x0066,
	          0x67: 0x0067,
	          0x68: 0x0068,
	          0x69: 0x0069,
	          0x6A: 0x006A,
	          0x6B: 0x006B,
	          0x6C: 0x006C,
	          0x6D: 0x006D,
	          0x6E: 0x006E,
	          0x6F: 0x006F,
	          0x70: 0x0070,
	          0x71: 0x0071,
	          0x72: 0x0072,
	          0x73: 0x0073,
	          0x74: 0x0074,
	          0x75: 0x0075,
	          0x76: 0x0076,
	          0x77: 0x0077,
	          0x78: 0x0078,
	          0x79: 0x0079,
	          0x7A: 0x007A,
	          0x7B: 0x007B,
	          0x7C: 0x007C,
	          0x7D: 0x007D,
	          0x7E: 0x203E,
	          0x8140: 0x3000,
	          0x8141: 0x3001,
	          0x8142: 0x3002,
	          0x8143: 0xFF0C,
	          0x8144: 0xFF0E,
	          0x8145: 0x30FB,
	          0x8146: 0xFF1A,
	          0x8147: 0xFF1B,
	          0x8148: 0xFF1F,
	          0x8149: 0xFF01,
	          0x814A: 0x309B,
	          0x814B: 0x309C,
	          0x814C: 0x00B4,
	          0x814D: 0xFF40,
	          0x814E: 0x00A8,
	          0x814F: 0xFF3E,
	          0x8150: 0xFFE3,
	          0x8151: 0xFF3F,
	          0x8152: 0x30FD,
	          0x8153: 0x30FE,
	          0x8154: 0x309D,
	          0x8155: 0x309E,
	          0x8156: 0x3003,
	          0x8157: 0x4EDD,
	          0x8158: 0x3005,
	          0x8159: 0x3006,
	          0x815A: 0x3007,
	          0x815B: 0x30FC,
	          0x815C: 0x2015,
	          0x815D: 0x2010,
	          0x815E: 0xFF0F,
	          0x815F: 0x005C,
	          0x8160: 0x301C,
	          0x8161: 0x2016,
	          0x8162: 0xFF5C,
	          0x8163: 0x2026,
	          0x8164: 0x2025,
	          0x8165: 0x2018,
	          0x8166: 0x2019,
	          0x8167: 0x201C,
	          0x8168: 0x201D,
	          0x8169: 0xFF08,
	          0x816A: 0xFF09,
	          0x816B: 0x3014,
	          0x816C: 0x3015,
	          0x816D: 0xFF3B,
	          0x816E: 0xFF3D,
	          0x816F: 0xFF5B,
	          0x8170: 0xFF5D,
	          0x8171: 0x3008,
	          0x8172: 0x3009,
	          0x8173: 0x300A,
	          0x8174: 0x300B,
	          0x8175: 0x300C,
	          0x8176: 0x300D,
	          0x8177: 0x300E,
	          0x8178: 0x300F,
	          0x8179: 0x3010,
	          0x817A: 0x3011,
	          0x817B: 0xFF0B,
	          0x817C: 0x2212,
	          0x817D: 0x00B1,
	          0x817E: 0x00D7,
	          0x8180: 0x00F7,
	          0x8181: 0xFF1D,
	          0x8182: 0x2260,
	          0x8183: 0xFF1C,
	          0x8184: 0xFF1E,
	          0x8185: 0x2266,
	          0x8186: 0x2267,
	          0x8187: 0x221E,
	          0x8188: 0x2234,
	          0x8189: 0x2642,
	          0x818A: 0x2640,
	          0x818B: 0x00B0,
	          0x818C: 0x2032,
	          0x818D: 0x2033,
	          0x818E: 0x2103,
	          0x818F: 0xFFE5,
	          0x8190: 0xFF04,
	          0x8191: 0x00A2,
	          0x8192: 0x00A3,
	          0x8193: 0xFF05,
	          0x8194: 0xFF03,
	          0x8195: 0xFF06,
	          0x8196: 0xFF0A,
	          0x8197: 0xFF20,
	          0x8198: 0x00A7,
	          0x8199: 0x2606,
	          0x819A: 0x2605,
	          0x819B: 0x25CB,
	          0x819C: 0x25CF,
	          0x819D: 0x25CE,
	          0x819E: 0x25C7,
	          0x819F: 0x25C6,
	          0x81A0: 0x25A1,
	          0x81A1: 0x25A0,
	          0x81A2: 0x25B3,
	          0x81A3: 0x25B2,
	          0x81A4: 0x25BD,
	          0x81A5: 0x25BC,
	          0x81A6: 0x203B,
	          0x81A7: 0x3012,
	          0x81A8: 0x2192,
	          0x81A9: 0x2190,
	          0x81AA: 0x2191,
	          0x81AB: 0x2193,
	          0x81AC: 0x3013,
	          0x81B8: 0x2208,
	          0x81B9: 0x220B,
	          0x81BA: 0x2286,
	          0x81BB: 0x2287,
	          0x81BC: 0x2282,
	          0x81BD: 0x2283,
	          0x81BE: 0x222A,
	          0x81BF: 0x2229,
	          0x81C8: 0x2227,
	          0x81C9: 0x2228,
	          0x81CA: 0x00AC,
	          0x81CB: 0x21D2,
	          0x81CC: 0x21D4,
	          0x81CD: 0x2200,
	          0x81CE: 0x2203,
	          0x81DA: 0x2220,
	          0x81DB: 0x22A5,
	          0x81DC: 0x2312,
	          0x81DD: 0x2202,
	          0x81DE: 0x2207,
	          0x81DF: 0x2261,
	          0x81E0: 0x2252,
	          0x81E1: 0x226A,
	          0x81E2: 0x226B,
	          0x81E3: 0x221A,
	          0x81E4: 0x223D,
	          0x81E5: 0x221D,
	          0x81E6: 0x2235,
	          0x81E7: 0x222B,
	          0x81E8: 0x222C,
	          0x81F0: 0x212B,
	          0x81F1: 0x2030,
	          0x81F2: 0x266F,
	          0x81F3: 0x266D,
	          0x81F4: 0x266A,
	          0x81F5: 0x2020,
	          0x81F6: 0x2021,
	          0x81F7: 0x00B6,
	          0x81FC: 0x25EF,
	          0x824F: 0xFF10,
	          0x8250: 0xFF11,
	          0x8251: 0xFF12,
	          0x8252: 0xFF13,
	          0x8253: 0xFF14,
	          0x8254: 0xFF15,
	          0x8255: 0xFF16,
	          0x8256: 0xFF17,
	          0x8257: 0xFF18,
	          0x8258: 0xFF19,
	          0x8260: 0xFF21,
	          0x8261: 0xFF22,
	          0x8262: 0xFF23,
	          0x8263: 0xFF24,
	          0x8264: 0xFF25,
	          0x8265: 0xFF26,
	          0x8266: 0xFF27,
	          0x8267: 0xFF28,
	          0x8268: 0xFF29,
	          0x8269: 0xFF2A,
	          0x826A: 0xFF2B,
	          0x826B: 0xFF2C,
	          0x826C: 0xFF2D,
	          0x826D: 0xFF2E,
	          0x826E: 0xFF2F,
	          0x826F: 0xFF30,
	          0x8270: 0xFF31,
	          0x8271: 0xFF32,
	          0x8272: 0xFF33,
	          0x8273: 0xFF34,
	          0x8274: 0xFF35,
	          0x8275: 0xFF36,
	          0x8276: 0xFF37,
	          0x8277: 0xFF38,
	          0x8278: 0xFF39,
	          0x8279: 0xFF3A,
	          0x8281: 0xFF41,
	          0x8282: 0xFF42,
	          0x8283: 0xFF43,
	          0x8284: 0xFF44,
	          0x8285: 0xFF45,
	          0x8286: 0xFF46,
	          0x8287: 0xFF47,
	          0x8288: 0xFF48,
	          0x8289: 0xFF49,
	          0x828A: 0xFF4A,
	          0x828B: 0xFF4B,
	          0x828C: 0xFF4C,
	          0x828D: 0xFF4D,
	          0x828E: 0xFF4E,
	          0x828F: 0xFF4F,
	          0x8290: 0xFF50,
	          0x8291: 0xFF51,
	          0x8292: 0xFF52,
	          0x8293: 0xFF53,
	          0x8294: 0xFF54,
	          0x8295: 0xFF55,
	          0x8296: 0xFF56,
	          0x8297: 0xFF57,
	          0x8298: 0xFF58,
	          0x8299: 0xFF59,
	          0x829A: 0xFF5A,
	          0x829F: 0x3041,
	          0x82A0: 0x3042,
	          0x82A1: 0x3043,
	          0x82A2: 0x3044,
	          0x82A3: 0x3045,
	          0x82A4: 0x3046,
	          0x82A5: 0x3047,
	          0x82A6: 0x3048,
	          0x82A7: 0x3049,
	          0x82A8: 0x304A,
	          0x82A9: 0x304B,
	          0x82AA: 0x304C,
	          0x82AB: 0x304D,
	          0x82AC: 0x304E,
	          0x82AD: 0x304F,
	          0x82AE: 0x3050,
	          0x82AF: 0x3051,
	          0x82B0: 0x3052,
	          0x82B1: 0x3053,
	          0x82B2: 0x3054,
	          0x82B3: 0x3055,
	          0x82B4: 0x3056,
	          0x82B5: 0x3057,
	          0x82B6: 0x3058,
	          0x82B7: 0x3059,
	          0x82B8: 0x305A,
	          0x82B9: 0x305B,
	          0x82BA: 0x305C,
	          0x82BB: 0x305D,
	          0x82BC: 0x305E,
	          0x82BD: 0x305F,
	          0x82BE: 0x3060,
	          0x82BF: 0x3061,
	          0x82C0: 0x3062,
	          0x82C1: 0x3063,
	          0x82C2: 0x3064,
	          0x82C3: 0x3065,
	          0x82C4: 0x3066,
	          0x82C5: 0x3067,
	          0x82C6: 0x3068,
	          0x82C7: 0x3069,
	          0x82C8: 0x306A,
	          0x82C9: 0x306B,
	          0x82CA: 0x306C,
	          0x82CB: 0x306D,
	          0x82CC: 0x306E,
	          0x82CD: 0x306F,
	          0x82CE: 0x3070,
	          0x82CF: 0x3071,
	          0x82D0: 0x3072,
	          0x82D1: 0x3073,
	          0x82D2: 0x3074,
	          0x82D3: 0x3075,
	          0x82D4: 0x3076,
	          0x82D5: 0x3077,
	          0x82D6: 0x3078,
	          0x82D7: 0x3079,
	          0x82D8: 0x307A,
	          0x82D9: 0x307B,
	          0x82DA: 0x307C,
	          0x82DB: 0x307D,
	          0x82DC: 0x307E,
	          0x82DD: 0x307F,
	          0x82DE: 0x3080,
	          0x82DF: 0x3081,
	          0x82E0: 0x3082,
	          0x82E1: 0x3083,
	          0x82E2: 0x3084,
	          0x82E3: 0x3085,
	          0x82E4: 0x3086,
	          0x82E5: 0x3087,
	          0x82E6: 0x3088,
	          0x82E7: 0x3089,
	          0x82E8: 0x308A,
	          0x82E9: 0x308B,
	          0x82EA: 0x308C,
	          0x82EB: 0x308D,
	          0x82EC: 0x308E,
	          0x82ED: 0x308F,
	          0x82EE: 0x3090,
	          0x82EF: 0x3091,
	          0x82F0: 0x3092,
	          0x82F1: 0x3093,
	          0x8340: 0x30A1,
	          0x8341: 0x30A2,
	          0x8342: 0x30A3,
	          0x8343: 0x30A4,
	          0x8344: 0x30A5,
	          0x8345: 0x30A6,
	          0x8346: 0x30A7,
	          0x8347: 0x30A8,
	          0x8348: 0x30A9,
	          0x8349: 0x30AA,
	          0x834A: 0x30AB,
	          0x834B: 0x30AC,
	          0x834C: 0x30AD,
	          0x834D: 0x30AE,
	          0x834E: 0x30AF,
	          0x834F: 0x30B0,
	          0x8350: 0x30B1,
	          0x8351: 0x30B2,
	          0x8352: 0x30B3,
	          0x8353: 0x30B4,
	          0x8354: 0x30B5,
	          0x8355: 0x30B6,
	          0x8356: 0x30B7,
	          0x8357: 0x30B8,
	          0x8358: 0x30B9,
	          0x8359: 0x30BA,
	          0x835A: 0x30BB,
	          0x835B: 0x30BC,
	          0x835C: 0x30BD,
	          0x835D: 0x30BE,
	          0x835E: 0x30BF,
	          0x835F: 0x30C0,
	          0x8360: 0x30C1,
	          0x8361: 0x30C2,
	          0x8362: 0x30C3,
	          0x8363: 0x30C4,
	          0x8364: 0x30C5,
	          0x8365: 0x30C6,
	          0x8366: 0x30C7,
	          0x8367: 0x30C8,
	          0x8368: 0x30C9,
	          0x8369: 0x30CA,
	          0x836A: 0x30CB,
	          0x836B: 0x30CC,
	          0x836C: 0x30CD,
	          0x836D: 0x30CE,
	          0x836E: 0x30CF,
	          0x836F: 0x30D0,
	          0x8370: 0x30D1,
	          0x8371: 0x30D2,
	          0x8372: 0x30D3,
	          0x8373: 0x30D4,
	          0x8374: 0x30D5,
	          0x8375: 0x30D6,
	          0x8376: 0x30D7,
	          0x8377: 0x30D8,
	          0x8378: 0x30D9,
	          0x8379: 0x30DA,
	          0x837A: 0x30DB,
	          0x837B: 0x30DC,
	          0x837C: 0x30DD,
	          0x837D: 0x30DE,
	          0x837E: 0x30DF,
	          0x8380: 0x30E0,
	          0x8381: 0x30E1,
	          0x8382: 0x30E2,
	          0x8383: 0x30E3,
	          0x8384: 0x30E4,
	          0x8385: 0x30E5,
	          0x8386: 0x30E6,
	          0x8387: 0x30E7,
	          0x8388: 0x30E8,
	          0x8389: 0x30E9,
	          0x838A: 0x30EA,
	          0x838B: 0x30EB,
	          0x838C: 0x30EC,
	          0x838D: 0x30ED,
	          0x838E: 0x30EE,
	          0x838F: 0x30EF,
	          0x8390: 0x30F0,
	          0x8391: 0x30F1,
	          0x8392: 0x30F2,
	          0x8393: 0x30F3,
	          0x8394: 0x30F4,
	          0x8395: 0x30F5,
	          0x8396: 0x30F6,
	          0x839F: 0x0391,
	          0x83A0: 0x0392,
	          0x83A1: 0x0393,
	          0x83A2: 0x0394,
	          0x83A3: 0x0395,
	          0x83A4: 0x0396,
	          0x83A5: 0x0397,
	          0x83A6: 0x0398,
	          0x83A7: 0x0399,
	          0x83A8: 0x039A,
	          0x83A9: 0x039B,
	          0x83AA: 0x039C,
	          0x83AB: 0x039D,
	          0x83AC: 0x039E,
	          0x83AD: 0x039F,
	          0x83AE: 0x03A0,
	          0x83AF: 0x03A1,
	          0x83B0: 0x03A3,
	          0x83B1: 0x03A4,
	          0x83B2: 0x03A5,
	          0x83B3: 0x03A6,
	          0x83B4: 0x03A7,
	          0x83B5: 0x03A8,
	          0x83B6: 0x03A9,
	          0x83BF: 0x03B1,
	          0x83C0: 0x03B2,
	          0x83C1: 0x03B3,
	          0x83C2: 0x03B4,
	          0x83C3: 0x03B5,
	          0x83C4: 0x03B6,
	          0x83C5: 0x03B7,
	          0x83C6: 0x03B8,
	          0x83C7: 0x03B9,
	          0x83C8: 0x03BA,
	          0x83C9: 0x03BB,
	          0x83CA: 0x03BC,
	          0x83CB: 0x03BD,
	          0x83CC: 0x03BE,
	          0x83CD: 0x03BF,
	          0x83CE: 0x03C0,
	          0x83CF: 0x03C1,
	          0x83D0: 0x03C3,
	          0x83D1: 0x03C4,
	          0x83D2: 0x03C5,
	          0x83D3: 0x03C6,
	          0x83D4: 0x03C7,
	          0x83D5: 0x03C8,
	          0x83D6: 0x03C9,
	          0x8440: 0x0410,
	          0x8441: 0x0411,
	          0x8442: 0x0412,
	          0x8443: 0x0413,
	          0x8444: 0x0414,
	          0x8445: 0x0415,
	          0x8446: 0x0401,
	          0x8447: 0x0416,
	          0x8448: 0x0417,
	          0x8449: 0x0418,
	          0x844A: 0x0419,
	          0x844B: 0x041A,
	          0x844C: 0x041B,
	          0x844D: 0x041C,
	          0x844E: 0x041D,
	          0x844F: 0x041E,
	          0x8450: 0x041F,
	          0x8451: 0x0420,
	          0x8452: 0x0421,
	          0x8453: 0x0422,
	          0x8454: 0x0423,
	          0x8455: 0x0424,
	          0x8456: 0x0425,
	          0x8457: 0x0426,
	          0x8458: 0x0427,
	          0x8459: 0x0428,
	          0x845A: 0x0429,
	          0x845B: 0x042A,
	          0x845C: 0x042B,
	          0x845D: 0x042C,
	          0x845E: 0x042D,
	          0x845F: 0x042E,
	          0x8460: 0x042F,
	          0x8470: 0x0430,
	          0x8471: 0x0431,
	          0x8472: 0x0432,
	          0x8473: 0x0433,
	          0x8474: 0x0434,
	          0x8475: 0x0435,
	          0x8476: 0x0451,
	          0x8477: 0x0436,
	          0x8478: 0x0437,
	          0x8479: 0x0438,
	          0x847A: 0x0439,
	          0x847B: 0x043A,
	          0x847C: 0x043B,
	          0x847D: 0x043C,
	          0x847E: 0x043D,
	          0x8480: 0x043E,
	          0x8481: 0x043F,
	          0x8482: 0x0440,
	          0x8483: 0x0441,
	          0x8484: 0x0442,
	          0x8485: 0x0443,
	          0x8486: 0x0444,
	          0x8487: 0x0445,
	          0x8488: 0x0446,
	          0x8489: 0x0447,
	          0x848A: 0x0448,
	          0x848B: 0x0449,
	          0x848C: 0x044A,
	          0x848D: 0x044B,
	          0x848E: 0x044C,
	          0x848F: 0x044D,
	          0x8490: 0x044E,
	          0x8491: 0x044F,
	          0x849F: 0x2500,
	          0x84A0: 0x2502,
	          0x84A1: 0x250C,
	          0x84A2: 0x2510,
	          0x84A3: 0x2518,
	          0x84A4: 0x2514,
	          0x84A5: 0x251C,
	          0x84A6: 0x252C,
	          0x84A7: 0x2524,
	          0x84A8: 0x2534,
	          0x84A9: 0x253C,
	          0x84AA: 0x2501,
	          0x84AB: 0x2503,
	          0x84AC: 0x250F,
	          0x84AD: 0x2513,
	          0x84AE: 0x251B,
	          0x84AF: 0x2517,
	          0x84B0: 0x2523,
	          0x84B1: 0x2533,
	          0x84B2: 0x252B,
	          0x84B3: 0x253B,
	          0x84B4: 0x254B,
	          0x84B5: 0x2520,
	          0x84B6: 0x252F,
	          0x84B7: 0x2528,
	          0x84B8: 0x2537,
	          0x84B9: 0x253F,
	          0x84BA: 0x251D,
	          0x84BB: 0x2530,
	          0x84BC: 0x2525,
	          0x84BD: 0x2538,
	          0x84BE: 0x2542,
	          0x889F: 0x4E9C,
	          0x88A0: 0x5516,
	          0x88A1: 0x5A03,
	          0x88A2: 0x963F,
	          0x88A3: 0x54C0,
	          0x88A4: 0x611B,
	          0x88A5: 0x6328,
	          0x88A6: 0x59F6,
	          0x88A7: 0x9022,
	          0x88A8: 0x8475,
	          0x88A9: 0x831C,
	          0x88AA: 0x7A50,
	          0x88AB: 0x60AA,
	          0x88AC: 0x63E1,
	          0x88AD: 0x6E25,
	          0x88AE: 0x65ED,
	          0x88AF: 0x8466,
	          0x88B0: 0x82A6,
	          0x88B1: 0x9BF5,
	          0x88B2: 0x6893,
	          0x88B3: 0x5727,
	          0x88B4: 0x65A1,
	          0x88B5: 0x6271,
	          0x88B6: 0x5B9B,
	          0x88B7: 0x59D0,
	          0x88B8: 0x867B,
	          0x88B9: 0x98F4,
	          0x88BA: 0x7D62,
	          0x88BB: 0x7DBE,
	          0x88BC: 0x9B8E,
	          0x88BD: 0x6216,
	          0x88BE: 0x7C9F,
	          0x88BF: 0x88B7,
	          0x88C0: 0x5B89,
	          0x88C1: 0x5EB5,
	          0x88C2: 0x6309,
	          0x88C3: 0x6697,
	          0x88C4: 0x6848,
	          0x88C5: 0x95C7,
	          0x88C6: 0x978D,
	          0x88C7: 0x674F,
	          0x88C8: 0x4EE5,
	          0x88C9: 0x4F0A,
	          0x88CA: 0x4F4D,
	          0x88CB: 0x4F9D,
	          0x88CC: 0x5049,
	          0x88CD: 0x56F2,
	          0x88CE: 0x5937,
	          0x88CF: 0x59D4,
	          0x88D0: 0x5A01,
	          0x88D1: 0x5C09,
	          0x88D2: 0x60DF,
	          0x88D3: 0x610F,
	          0x88D4: 0x6170,
	          0x88D5: 0x6613,
	          0x88D6: 0x6905,
	          0x88D7: 0x70BA,
	          0x88D8: 0x754F,
	          0x88D9: 0x7570,
	          0x88DA: 0x79FB,
	          0x88DB: 0x7DAD,
	          0x88DC: 0x7DEF,
	          0x88DD: 0x80C3,
	          0x88DE: 0x840E,
	          0x88DF: 0x8863,
	          0x88E0: 0x8B02,
	          0x88E1: 0x9055,
	          0x88E2: 0x907A,
	          0x88E3: 0x533B,
	          0x88E4: 0x4E95,
	          0x88E5: 0x4EA5,
	          0x88E6: 0x57DF,
	          0x88E7: 0x80B2,
	          0x88E8: 0x90C1,
	          0x88E9: 0x78EF,
	          0x88EA: 0x4E00,
	          0x88EB: 0x58F1,
	          0x88EC: 0x6EA2,
	          0x88ED: 0x9038,
	          0x88EE: 0x7A32,
	          0x88EF: 0x8328,
	          0x88F0: 0x828B,
	          0x88F1: 0x9C2F,
	          0x88F2: 0x5141,
	          0x88F3: 0x5370,
	          0x88F4: 0x54BD,
	          0x88F5: 0x54E1,
	          0x88F6: 0x56E0,
	          0x88F7: 0x59FB,
	          0x88F8: 0x5F15,
	          0x88F9: 0x98F2,
	          0x88FA: 0x6DEB,
	          0x88FB: 0x80E4,
	          0x88FC: 0x852D,
	          0x8940: 0x9662,
	          0x8941: 0x9670,
	          0x8942: 0x96A0,
	          0x8943: 0x97FB,
	          0x8944: 0x540B,
	          0x8945: 0x53F3,
	          0x8946: 0x5B87,
	          0x8947: 0x70CF,
	          0x8948: 0x7FBD,
	          0x8949: 0x8FC2,
	          0x894A: 0x96E8,
	          0x894B: 0x536F,
	          0x894C: 0x9D5C,
	          0x894D: 0x7ABA,
	          0x894E: 0x4E11,
	          0x894F: 0x7893,
	          0x8950: 0x81FC,
	          0x8951: 0x6E26,
	          0x8952: 0x5618,
	          0x8953: 0x5504,
	          0x8954: 0x6B1D,
	          0x8955: 0x851A,
	          0x8956: 0x9C3B,
	          0x8957: 0x59E5,
	          0x8958: 0x53A9,
	          0x8959: 0x6D66,
	          0x895A: 0x74DC,
	          0x895B: 0x958F,
	          0x895C: 0x5642,
	          0x895D: 0x4E91,
	          0x895E: 0x904B,
	          0x895F: 0x96F2,
	          0x8960: 0x834F,
	          0x8961: 0x990C,
	          0x8962: 0x53E1,
	          0x8963: 0x55B6,
	          0x8964: 0x5B30,
	          0x8965: 0x5F71,
	          0x8966: 0x6620,
	          0x8967: 0x66F3,
	          0x8968: 0x6804,
	          0x8969: 0x6C38,
	          0x896A: 0x6CF3,
	          0x896B: 0x6D29,
	          0x896C: 0x745B,
	          0x896D: 0x76C8,
	          0x896E: 0x7A4E,
	          0x896F: 0x9834,
	          0x8970: 0x82F1,
	          0x8971: 0x885B,
	          0x8972: 0x8A60,
	          0x8973: 0x92ED,
	          0x8974: 0x6DB2,
	          0x8975: 0x75AB,
	          0x8976: 0x76CA,
	          0x8977: 0x99C5,
	          0x8978: 0x60A6,
	          0x8979: 0x8B01,
	          0x897A: 0x8D8A,
	          0x897B: 0x95B2,
	          0x897C: 0x698E,
	          0x897D: 0x53AD,
	          0x897E: 0x5186,
	          0x8980: 0x5712,
	          0x8981: 0x5830,
	          0x8982: 0x5944,
	          0x8983: 0x5BB4,
	          0x8984: 0x5EF6,
	          0x8985: 0x6028,
	          0x8986: 0x63A9,
	          0x8987: 0x63F4,
	          0x8988: 0x6CBF,
	          0x8989: 0x6F14,
	          0x898A: 0x708E,
	          0x898B: 0x7114,
	          0x898C: 0x7159,
	          0x898D: 0x71D5,
	          0x898E: 0x733F,
	          0x898F: 0x7E01,
	          0x8990: 0x8276,
	          0x8991: 0x82D1,
	          0x8992: 0x8597,
	          0x8993: 0x9060,
	          0x8994: 0x925B,
	          0x8995: 0x9D1B,
	          0x8996: 0x5869,
	          0x8997: 0x65BC,
	          0x8998: 0x6C5A,
	          0x8999: 0x7525,
	          0x899A: 0x51F9,
	          0x899B: 0x592E,
	          0x899C: 0x5965,
	          0x899D: 0x5F80,
	          0x899E: 0x5FDC,
	          0x899F: 0x62BC,
	          0x89A0: 0x65FA,
	          0x89A1: 0x6A2A,
	          0x89A2: 0x6B27,
	          0x89A3: 0x6BB4,
	          0x89A4: 0x738B,
	          0x89A5: 0x7FC1,
	          0x89A6: 0x8956,
	          0x89A7: 0x9D2C,
	          0x89A8: 0x9D0E,
	          0x89A9: 0x9EC4,
	          0x89AA: 0x5CA1,
	          0x89AB: 0x6C96,
	          0x89AC: 0x837B,
	          0x89AD: 0x5104,
	          0x89AE: 0x5C4B,
	          0x89AF: 0x61B6,
	          0x89B0: 0x81C6,
	          0x89B1: 0x6876,
	          0x89B2: 0x7261,
	          0x89B3: 0x4E59,
	          0x89B4: 0x4FFA,
	          0x89B5: 0x5378,
	          0x89B6: 0x6069,
	          0x89B7: 0x6E29,
	          0x89B8: 0x7A4F,
	          0x89B9: 0x97F3,
	          0x89BA: 0x4E0B,
	          0x89BB: 0x5316,
	          0x89BC: 0x4EEE,
	          0x89BD: 0x4F55,
	          0x89BE: 0x4F3D,
	          0x89BF: 0x4FA1,
	          0x89C0: 0x4F73,
	          0x89C1: 0x52A0,
	          0x89C2: 0x53EF,
	          0x89C3: 0x5609,
	          0x89C4: 0x590F,
	          0x89C5: 0x5AC1,
	          0x89C6: 0x5BB6,
	          0x89C7: 0x5BE1,
	          0x89C8: 0x79D1,
	          0x89C9: 0x6687,
	          0x89CA: 0x679C,
	          0x89CB: 0x67B6,
	          0x89CC: 0x6B4C,
	          0x89CD: 0x6CB3,
	          0x89CE: 0x706B,
	          0x89CF: 0x73C2,
	          0x89D0: 0x798D,
	          0x89D1: 0x79BE,
	          0x89D2: 0x7A3C,
	          0x89D3: 0x7B87,
	          0x89D4: 0x82B1,
	          0x89D5: 0x82DB,
	          0x89D6: 0x8304,
	          0x89D7: 0x8377,
	          0x89D8: 0x83EF,
	          0x89D9: 0x83D3,
	          0x89DA: 0x8766,
	          0x89DB: 0x8AB2,
	          0x89DC: 0x5629,
	          0x89DD: 0x8CA8,
	          0x89DE: 0x8FE6,
	          0x89DF: 0x904E,
	          0x89E0: 0x971E,
	          0x89E1: 0x868A,
	          0x89E2: 0x4FC4,
	          0x89E3: 0x5CE8,
	          0x89E4: 0x6211,
	          0x89E5: 0x7259,
	          0x89E6: 0x753B,
	          0x89E7: 0x81E5,
	          0x89E8: 0x82BD,
	          0x89E9: 0x86FE,
	          0x89EA: 0x8CC0,
	          0x89EB: 0x96C5,
	          0x89EC: 0x9913,
	          0x89ED: 0x99D5,
	          0x89EE: 0x4ECB,
	          0x89EF: 0x4F1A,
	          0x89F0: 0x89E3,
	          0x89F1: 0x56DE,
	          0x89F2: 0x584A,
	          0x89F3: 0x58CA,
	          0x89F4: 0x5EFB,
	          0x89F5: 0x5FEB,
	          0x89F6: 0x602A,
	          0x89F7: 0x6094,
	          0x89F8: 0x6062,
	          0x89F9: 0x61D0,
	          0x89FA: 0x6212,
	          0x89FB: 0x62D0,
	          0x89FC: 0x6539,
	          0x8A40: 0x9B41,
	          0x8A41: 0x6666,
	          0x8A42: 0x68B0,
	          0x8A43: 0x6D77,
	          0x8A44: 0x7070,
	          0x8A45: 0x754C,
	          0x8A46: 0x7686,
	          0x8A47: 0x7D75,
	          0x8A48: 0x82A5,
	          0x8A49: 0x87F9,
	          0x8A4A: 0x958B,
	          0x8A4B: 0x968E,
	          0x8A4C: 0x8C9D,
	          0x8A4D: 0x51F1,
	          0x8A4E: 0x52BE,
	          0x8A4F: 0x5916,
	          0x8A50: 0x54B3,
	          0x8A51: 0x5BB3,
	          0x8A52: 0x5D16,
	          0x8A53: 0x6168,
	          0x8A54: 0x6982,
	          0x8A55: 0x6DAF,
	          0x8A56: 0x788D,
	          0x8A57: 0x84CB,
	          0x8A58: 0x8857,
	          0x8A59: 0x8A72,
	          0x8A5A: 0x93A7,
	          0x8A5B: 0x9AB8,
	          0x8A5C: 0x6D6C,
	          0x8A5D: 0x99A8,
	          0x8A5E: 0x86D9,
	          0x8A5F: 0x57A3,
	          0x8A60: 0x67FF,
	          0x8A61: 0x86CE,
	          0x8A62: 0x920E,
	          0x8A63: 0x5283,
	          0x8A64: 0x5687,
	          0x8A65: 0x5404,
	          0x8A66: 0x5ED3,
	          0x8A67: 0x62E1,
	          0x8A68: 0x64B9,
	          0x8A69: 0x683C,
	          0x8A6A: 0x6838,
	          0x8A6B: 0x6BBB,
	          0x8A6C: 0x7372,
	          0x8A6D: 0x78BA,
	          0x8A6E: 0x7A6B,
	          0x8A6F: 0x899A,
	          0x8A70: 0x89D2,
	          0x8A71: 0x8D6B,
	          0x8A72: 0x8F03,
	          0x8A73: 0x90ED,
	          0x8A74: 0x95A3,
	          0x8A75: 0x9694,
	          0x8A76: 0x9769,
	          0x8A77: 0x5B66,
	          0x8A78: 0x5CB3,
	          0x8A79: 0x697D,
	          0x8A7A: 0x984D,
	          0x8A7B: 0x984E,
	          0x8A7C: 0x639B,
	          0x8A7D: 0x7B20,
	          0x8A7E: 0x6A2B,
	          0x8A80: 0x6A7F,
	          0x8A81: 0x68B6,
	          0x8A82: 0x9C0D,
	          0x8A83: 0x6F5F,
	          0x8A84: 0x5272,
	          0x8A85: 0x559D,
	          0x8A86: 0x6070,
	          0x8A87: 0x62EC,
	          0x8A88: 0x6D3B,
	          0x8A89: 0x6E07,
	          0x8A8A: 0x6ED1,
	          0x8A8B: 0x845B,
	          0x8A8C: 0x8910,
	          0x8A8D: 0x8F44,
	          0x8A8E: 0x4E14,
	          0x8A8F: 0x9C39,
	          0x8A90: 0x53F6,
	          0x8A91: 0x691B,
	          0x8A92: 0x6A3A,
	          0x8A93: 0x9784,
	          0x8A94: 0x682A,
	          0x8A95: 0x515C,
	          0x8A96: 0x7AC3,
	          0x8A97: 0x84B2,
	          0x8A98: 0x91DC,
	          0x8A99: 0x938C,
	          0x8A9A: 0x565B,
	          0x8A9B: 0x9D28,
	          0x8A9C: 0x6822,
	          0x8A9D: 0x8305,
	          0x8A9E: 0x8431,
	          0x8A9F: 0x7CA5,
	          0x8AA0: 0x5208,
	          0x8AA1: 0x82C5,
	          0x8AA2: 0x74E6,
	          0x8AA3: 0x4E7E,
	          0x8AA4: 0x4F83,
	          0x8AA5: 0x51A0,
	          0x8AA6: 0x5BD2,
	          0x8AA7: 0x520A,
	          0x8AA8: 0x52D8,
	          0x8AA9: 0x52E7,
	          0x8AAA: 0x5DFB,
	          0x8AAB: 0x559A,
	          0x8AAC: 0x582A,
	          0x8AAD: 0x59E6,
	          0x8AAE: 0x5B8C,
	          0x8AAF: 0x5B98,
	          0x8AB0: 0x5BDB,
	          0x8AB1: 0x5E72,
	          0x8AB2: 0x5E79,
	          0x8AB3: 0x60A3,
	          0x8AB4: 0x611F,
	          0x8AB5: 0x6163,
	          0x8AB6: 0x61BE,
	          0x8AB7: 0x63DB,
	          0x8AB8: 0x6562,
	          0x8AB9: 0x67D1,
	          0x8ABA: 0x6853,
	          0x8ABB: 0x68FA,
	          0x8ABC: 0x6B3E,
	          0x8ABD: 0x6B53,
	          0x8ABE: 0x6C57,
	          0x8ABF: 0x6F22,
	          0x8AC0: 0x6F97,
	          0x8AC1: 0x6F45,
	          0x8AC2: 0x74B0,
	          0x8AC3: 0x7518,
	          0x8AC4: 0x76E3,
	          0x8AC5: 0x770B,
	          0x8AC6: 0x7AFF,
	          0x8AC7: 0x7BA1,
	          0x8AC8: 0x7C21,
	          0x8AC9: 0x7DE9,
	          0x8ACA: 0x7F36,
	          0x8ACB: 0x7FF0,
	          0x8ACC: 0x809D,
	          0x8ACD: 0x8266,
	          0x8ACE: 0x839E,
	          0x8ACF: 0x89B3,
	          0x8AD0: 0x8ACC,
	          0x8AD1: 0x8CAB,
	          0x8AD2: 0x9084,
	          0x8AD3: 0x9451,
	          0x8AD4: 0x9593,
	          0x8AD5: 0x9591,
	          0x8AD6: 0x95A2,
	          0x8AD7: 0x9665,
	          0x8AD8: 0x97D3,
	          0x8AD9: 0x9928,
	          0x8ADA: 0x8218,
	          0x8ADB: 0x4E38,
	          0x8ADC: 0x542B,
	          0x8ADD: 0x5CB8,
	          0x8ADE: 0x5DCC,
	          0x8ADF: 0x73A9,
	          0x8AE0: 0x764C,
	          0x8AE1: 0x773C,
	          0x8AE2: 0x5CA9,
	          0x8AE3: 0x7FEB,
	          0x8AE4: 0x8D0B,
	          0x8AE5: 0x96C1,
	          0x8AE6: 0x9811,
	          0x8AE7: 0x9854,
	          0x8AE8: 0x9858,
	          0x8AE9: 0x4F01,
	          0x8AEA: 0x4F0E,
	          0x8AEB: 0x5371,
	          0x8AEC: 0x559C,
	          0x8AED: 0x5668,
	          0x8AEE: 0x57FA,
	          0x8AEF: 0x5947,
	          0x8AF0: 0x5B09,
	          0x8AF1: 0x5BC4,
	          0x8AF2: 0x5C90,
	          0x8AF3: 0x5E0C,
	          0x8AF4: 0x5E7E,
	          0x8AF5: 0x5FCC,
	          0x8AF6: 0x63EE,
	          0x8AF7: 0x673A,
	          0x8AF8: 0x65D7,
	          0x8AF9: 0x65E2,
	          0x8AFA: 0x671F,
	          0x8AFB: 0x68CB,
	          0x8AFC: 0x68C4,
	          0x8B40: 0x6A5F,
	          0x8B41: 0x5E30,
	          0x8B42: 0x6BC5,
	          0x8B43: 0x6C17,
	          0x8B44: 0x6C7D,
	          0x8B45: 0x757F,
	          0x8B46: 0x7948,
	          0x8B47: 0x5B63,
	          0x8B48: 0x7A00,
	          0x8B49: 0x7D00,
	          0x8B4A: 0x5FBD,
	          0x8B4B: 0x898F,
	          0x8B4C: 0x8A18,
	          0x8B4D: 0x8CB4,
	          0x8B4E: 0x8D77,
	          0x8B4F: 0x8ECC,
	          0x8B50: 0x8F1D,
	          0x8B51: 0x98E2,
	          0x8B52: 0x9A0E,
	          0x8B53: 0x9B3C,
	          0x8B54: 0x4E80,
	          0x8B55: 0x507D,
	          0x8B56: 0x5100,
	          0x8B57: 0x5993,
	          0x8B58: 0x5B9C,
	          0x8B59: 0x622F,
	          0x8B5A: 0x6280,
	          0x8B5B: 0x64EC,
	          0x8B5C: 0x6B3A,
	          0x8B5D: 0x72A0,
	          0x8B5E: 0x7591,
	          0x8B5F: 0x7947,
	          0x8B60: 0x7FA9,
	          0x8B61: 0x87FB,
	          0x8B62: 0x8ABC,
	          0x8B63: 0x8B70,
	          0x8B64: 0x63AC,
	          0x8B65: 0x83CA,
	          0x8B66: 0x97A0,
	          0x8B67: 0x5409,
	          0x8B68: 0x5403,
	          0x8B69: 0x55AB,
	          0x8B6A: 0x6854,
	          0x8B6B: 0x6A58,
	          0x8B6C: 0x8A70,
	          0x8B6D: 0x7827,
	          0x8B6E: 0x6775,
	          0x8B6F: 0x9ECD,
	          0x8B70: 0x5374,
	          0x8B71: 0x5BA2,
	          0x8B72: 0x811A,
	          0x8B73: 0x8650,
	          0x8B74: 0x9006,
	          0x8B75: 0x4E18,
	          0x8B76: 0x4E45,
	          0x8B77: 0x4EC7,
	          0x8B78: 0x4F11,
	          0x8B79: 0x53CA,
	          0x8B7A: 0x5438,
	          0x8B7B: 0x5BAE,
	          0x8B7C: 0x5F13,
	          0x8B7D: 0x6025,
	          0x8B7E: 0x6551,
	          0x8B80: 0x673D,
	          0x8B81: 0x6C42,
	          0x8B82: 0x6C72,
	          0x8B83: 0x6CE3,
	          0x8B84: 0x7078,
	          0x8B85: 0x7403,
	          0x8B86: 0x7A76,
	          0x8B87: 0x7AAE,
	          0x8B88: 0x7B08,
	          0x8B89: 0x7D1A,
	          0x8B8A: 0x7CFE,
	          0x8B8B: 0x7D66,
	          0x8B8C: 0x65E7,
	          0x8B8D: 0x725B,
	          0x8B8E: 0x53BB,
	          0x8B8F: 0x5C45,
	          0x8B90: 0x5DE8,
	          0x8B91: 0x62D2,
	          0x8B92: 0x62E0,
	          0x8B93: 0x6319,
	          0x8B94: 0x6E20,
	          0x8B95: 0x865A,
	          0x8B96: 0x8A31,
	          0x8B97: 0x8DDD,
	          0x8B98: 0x92F8,
	          0x8B99: 0x6F01,
	          0x8B9A: 0x79A6,
	          0x8B9B: 0x9B5A,
	          0x8B9C: 0x4EA8,
	          0x8B9D: 0x4EAB,
	          0x8B9E: 0x4EAC,
	          0x8B9F: 0x4F9B,
	          0x8BA0: 0x4FA0,
	          0x8BA1: 0x50D1,
	          0x8BA2: 0x5147,
	          0x8BA3: 0x7AF6,
	          0x8BA4: 0x5171,
	          0x8BA5: 0x51F6,
	          0x8BA6: 0x5354,
	          0x8BA7: 0x5321,
	          0x8BA8: 0x537F,
	          0x8BA9: 0x53EB,
	          0x8BAA: 0x55AC,
	          0x8BAB: 0x5883,
	          0x8BAC: 0x5CE1,
	          0x8BAD: 0x5F37,
	          0x8BAE: 0x5F4A,
	          0x8BAF: 0x602F,
	          0x8BB0: 0x6050,
	          0x8BB1: 0x606D,
	          0x8BB2: 0x631F,
	          0x8BB3: 0x6559,
	          0x8BB4: 0x6A4B,
	          0x8BB5: 0x6CC1,
	          0x8BB6: 0x72C2,
	          0x8BB7: 0x72ED,
	          0x8BB8: 0x77EF,
	          0x8BB9: 0x80F8,
	          0x8BBA: 0x8105,
	          0x8BBB: 0x8208,
	          0x8BBC: 0x854E,
	          0x8BBD: 0x90F7,
	          0x8BBE: 0x93E1,
	          0x8BBF: 0x97FF,
	          0x8BC0: 0x9957,
	          0x8BC1: 0x9A5A,
	          0x8BC2: 0x4EF0,
	          0x8BC3: 0x51DD,
	          0x8BC4: 0x5C2D,
	          0x8BC5: 0x6681,
	          0x8BC6: 0x696D,
	          0x8BC7: 0x5C40,
	          0x8BC8: 0x66F2,
	          0x8BC9: 0x6975,
	          0x8BCA: 0x7389,
	          0x8BCB: 0x6850,
	          0x8BCC: 0x7C81,
	          0x8BCD: 0x50C5,
	          0x8BCE: 0x52E4,
	          0x8BCF: 0x5747,
	          0x8BD0: 0x5DFE,
	          0x8BD1: 0x9326,
	          0x8BD2: 0x65A4,
	          0x8BD3: 0x6B23,
	          0x8BD4: 0x6B3D,
	          0x8BD5: 0x7434,
	          0x8BD6: 0x7981,
	          0x8BD7: 0x79BD,
	          0x8BD8: 0x7B4B,
	          0x8BD9: 0x7DCA,
	          0x8BDA: 0x82B9,
	          0x8BDB: 0x83CC,
	          0x8BDC: 0x887F,
	          0x8BDD: 0x895F,
	          0x8BDE: 0x8B39,
	          0x8BDF: 0x8FD1,
	          0x8BE0: 0x91D1,
	          0x8BE1: 0x541F,
	          0x8BE2: 0x9280,
	          0x8BE3: 0x4E5D,
	          0x8BE4: 0x5036,
	          0x8BE5: 0x53E5,
	          0x8BE6: 0x533A,
	          0x8BE7: 0x72D7,
	          0x8BE8: 0x7396,
	          0x8BE9: 0x77E9,
	          0x8BEA: 0x82E6,
	          0x8BEB: 0x8EAF,
	          0x8BEC: 0x99C6,
	          0x8BED: 0x99C8,
	          0x8BEE: 0x99D2,
	          0x8BEF: 0x5177,
	          0x8BF0: 0x611A,
	          0x8BF1: 0x865E,
	          0x8BF2: 0x55B0,
	          0x8BF3: 0x7A7A,
	          0x8BF4: 0x5076,
	          0x8BF5: 0x5BD3,
	          0x8BF6: 0x9047,
	          0x8BF7: 0x9685,
	          0x8BF8: 0x4E32,
	          0x8BF9: 0x6ADB,
	          0x8BFA: 0x91E7,
	          0x8BFB: 0x5C51,
	          0x8BFC: 0x5C48,
	          0x8C40: 0x6398,
	          0x8C41: 0x7A9F,
	          0x8C42: 0x6C93,
	          0x8C43: 0x9774,
	          0x8C44: 0x8F61,
	          0x8C45: 0x7AAA,
	          0x8C46: 0x718A,
	          0x8C47: 0x9688,
	          0x8C48: 0x7C82,
	          0x8C49: 0x6817,
	          0x8C4A: 0x7E70,
	          0x8C4B: 0x6851,
	          0x8C4C: 0x936C,
	          0x8C4D: 0x52F2,
	          0x8C4E: 0x541B,
	          0x8C4F: 0x85AB,
	          0x8C50: 0x8A13,
	          0x8C51: 0x7FA4,
	          0x8C52: 0x8ECD,
	          0x8C53: 0x90E1,
	          0x8C54: 0x5366,
	          0x8C55: 0x8888,
	          0x8C56: 0x7941,
	          0x8C57: 0x4FC2,
	          0x8C58: 0x50BE,
	          0x8C59: 0x5211,
	          0x8C5A: 0x5144,
	          0x8C5B: 0x5553,
	          0x8C5C: 0x572D,
	          0x8C5D: 0x73EA,
	          0x8C5E: 0x578B,
	          0x8C5F: 0x5951,
	          0x8C60: 0x5F62,
	          0x8C61: 0x5F84,
	          0x8C62: 0x6075,
	          0x8C63: 0x6176,
	          0x8C64: 0x6167,
	          0x8C65: 0x61A9,
	          0x8C66: 0x63B2,
	          0x8C67: 0x643A,
	          0x8C68: 0x656C,
	          0x8C69: 0x666F,
	          0x8C6A: 0x6842,
	          0x8C6B: 0x6E13,
	          0x8C6C: 0x7566,
	          0x8C6D: 0x7A3D,
	          0x8C6E: 0x7CFB,
	          0x8C6F: 0x7D4C,
	          0x8C70: 0x7D99,
	          0x8C71: 0x7E4B,
	          0x8C72: 0x7F6B,
	          0x8C73: 0x830E,
	          0x8C74: 0x834A,
	          0x8C75: 0x86CD,
	          0x8C76: 0x8A08,
	          0x8C77: 0x8A63,
	          0x8C78: 0x8B66,
	          0x8C79: 0x8EFD,
	          0x8C7A: 0x981A,
	          0x8C7B: 0x9D8F,
	          0x8C7C: 0x82B8,
	          0x8C7D: 0x8FCE,
	          0x8C7E: 0x9BE8,
	          0x8C80: 0x5287,
	          0x8C81: 0x621F,
	          0x8C82: 0x6483,
	          0x8C83: 0x6FC0,
	          0x8C84: 0x9699,
	          0x8C85: 0x6841,
	          0x8C86: 0x5091,
	          0x8C87: 0x6B20,
	          0x8C88: 0x6C7A,
	          0x8C89: 0x6F54,
	          0x8C8A: 0x7A74,
	          0x8C8B: 0x7D50,
	          0x8C8C: 0x8840,
	          0x8C8D: 0x8A23,
	          0x8C8E: 0x6708,
	          0x8C8F: 0x4EF6,
	          0x8C90: 0x5039,
	          0x8C91: 0x5026,
	          0x8C92: 0x5065,
	          0x8C93: 0x517C,
	          0x8C94: 0x5238,
	          0x8C95: 0x5263,
	          0x8C96: 0x55A7,
	          0x8C97: 0x570F,
	          0x8C98: 0x5805,
	          0x8C99: 0x5ACC,
	          0x8C9A: 0x5EFA,
	          0x8C9B: 0x61B2,
	          0x8C9C: 0x61F8,
	          0x8C9D: 0x62F3,
	          0x8C9E: 0x6372,
	          0x8C9F: 0x691C,
	          0x8CA0: 0x6A29,
	          0x8CA1: 0x727D,
	          0x8CA2: 0x72AC,
	          0x8CA3: 0x732E,
	          0x8CA4: 0x7814,
	          0x8CA5: 0x786F,
	          0x8CA6: 0x7D79,
	          0x8CA7: 0x770C,
	          0x8CA8: 0x80A9,
	          0x8CA9: 0x898B,
	          0x8CAA: 0x8B19,
	          0x8CAB: 0x8CE2,
	          0x8CAC: 0x8ED2,
	          0x8CAD: 0x9063,
	          0x8CAE: 0x9375,
	          0x8CAF: 0x967A,
	          0x8CB0: 0x9855,
	          0x8CB1: 0x9A13,
	          0x8CB2: 0x9E78,
	          0x8CB3: 0x5143,
	          0x8CB4: 0x539F,
	          0x8CB5: 0x53B3,
	          0x8CB6: 0x5E7B,
	          0x8CB7: 0x5F26,
	          0x8CB8: 0x6E1B,
	          0x8CB9: 0x6E90,
	          0x8CBA: 0x7384,
	          0x8CBB: 0x73FE,
	          0x8CBC: 0x7D43,
	          0x8CBD: 0x8237,
	          0x8CBE: 0x8A00,
	          0x8CBF: 0x8AFA,
	          0x8CC0: 0x9650,
	          0x8CC1: 0x4E4E,
	          0x8CC2: 0x500B,
	          0x8CC3: 0x53E4,
	          0x8CC4: 0x547C,
	          0x8CC5: 0x56FA,
	          0x8CC6: 0x59D1,
	          0x8CC7: 0x5B64,
	          0x8CC8: 0x5DF1,
	          0x8CC9: 0x5EAB,
	          0x8CCA: 0x5F27,
	          0x8CCB: 0x6238,
	          0x8CCC: 0x6545,
	          0x8CCD: 0x67AF,
	          0x8CCE: 0x6E56,
	          0x8CCF: 0x72D0,
	          0x8CD0: 0x7CCA,
	          0x8CD1: 0x88B4,
	          0x8CD2: 0x80A1,
	          0x8CD3: 0x80E1,
	          0x8CD4: 0x83F0,
	          0x8CD5: 0x864E,
	          0x8CD6: 0x8A87,
	          0x8CD7: 0x8DE8,
	          0x8CD8: 0x9237,
	          0x8CD9: 0x96C7,
	          0x8CDA: 0x9867,
	          0x8CDB: 0x9F13,
	          0x8CDC: 0x4E94,
	          0x8CDD: 0x4E92,
	          0x8CDE: 0x4F0D,
	          0x8CDF: 0x5348,
	          0x8CE0: 0x5449,
	          0x8CE1: 0x543E,
	          0x8CE2: 0x5A2F,
	          0x8CE3: 0x5F8C,
	          0x8CE4: 0x5FA1,
	          0x8CE5: 0x609F,
	          0x8CE6: 0x68A7,
	          0x8CE7: 0x6A8E,
	          0x8CE8: 0x745A,
	          0x8CE9: 0x7881,
	          0x8CEA: 0x8A9E,
	          0x8CEB: 0x8AA4,
	          0x8CEC: 0x8B77,
	          0x8CED: 0x9190,
	          0x8CEE: 0x4E5E,
	          0x8CEF: 0x9BC9,
	          0x8CF0: 0x4EA4,
	          0x8CF1: 0x4F7C,
	          0x8CF2: 0x4FAF,
	          0x8CF3: 0x5019,
	          0x8CF4: 0x5016,
	          0x8CF5: 0x5149,
	          0x8CF6: 0x516C,
	          0x8CF7: 0x529F,
	          0x8CF8: 0x52B9,
	          0x8CF9: 0x52FE,
	          0x8CFA: 0x539A,
	          0x8CFB: 0x53E3,
	          0x8CFC: 0x5411,
	          0x8D40: 0x540E,
	          0x8D41: 0x5589,
	          0x8D42: 0x5751,
	          0x8D43: 0x57A2,
	          0x8D44: 0x597D,
	          0x8D45: 0x5B54,
	          0x8D46: 0x5B5D,
	          0x8D47: 0x5B8F,
	          0x8D48: 0x5DE5,
	          0x8D49: 0x5DE7,
	          0x8D4A: 0x5DF7,
	          0x8D4B: 0x5E78,
	          0x8D4C: 0x5E83,
	          0x8D4D: 0x5E9A,
	          0x8D4E: 0x5EB7,
	          0x8D4F: 0x5F18,
	          0x8D50: 0x6052,
	          0x8D51: 0x614C,
	          0x8D52: 0x6297,
	          0x8D53: 0x62D8,
	          0x8D54: 0x63A7,
	          0x8D55: 0x653B,
	          0x8D56: 0x6602,
	          0x8D57: 0x6643,
	          0x8D58: 0x66F4,
	          0x8D59: 0x676D,
	          0x8D5A: 0x6821,
	          0x8D5B: 0x6897,
	          0x8D5C: 0x69CB,
	          0x8D5D: 0x6C5F,
	          0x8D5E: 0x6D2A,
	          0x8D5F: 0x6D69,
	          0x8D60: 0x6E2F,
	          0x8D61: 0x6E9D,
	          0x8D62: 0x7532,
	          0x8D63: 0x7687,
	          0x8D64: 0x786C,
	          0x8D65: 0x7A3F,
	          0x8D66: 0x7CE0,
	          0x8D67: 0x7D05,
	          0x8D68: 0x7D18,
	          0x8D69: 0x7D5E,
	          0x8D6A: 0x7DB1,
	          0x8D6B: 0x8015,
	          0x8D6C: 0x8003,
	          0x8D6D: 0x80AF,
	          0x8D6E: 0x80B1,
	          0x8D6F: 0x8154,
	          0x8D70: 0x818F,
	          0x8D71: 0x822A,
	          0x8D72: 0x8352,
	          0x8D73: 0x884C,
	          0x8D74: 0x8861,
	          0x8D75: 0x8B1B,
	          0x8D76: 0x8CA2,
	          0x8D77: 0x8CFC,
	          0x8D78: 0x90CA,
	          0x8D79: 0x9175,
	          0x8D7A: 0x9271,
	          0x8D7B: 0x783F,
	          0x8D7C: 0x92FC,
	          0x8D7D: 0x95A4,
	          0x8D7E: 0x964D,
	          0x8D80: 0x9805,
	          0x8D81: 0x9999,
	          0x8D82: 0x9AD8,
	          0x8D83: 0x9D3B,
	          0x8D84: 0x525B,
	          0x8D85: 0x52AB,
	          0x8D86: 0x53F7,
	          0x8D87: 0x5408,
	          0x8D88: 0x58D5,
	          0x8D89: 0x62F7,
	          0x8D8A: 0x6FE0,
	          0x8D8B: 0x8C6A,
	          0x8D8C: 0x8F5F,
	          0x8D8D: 0x9EB9,
	          0x8D8E: 0x514B,
	          0x8D8F: 0x523B,
	          0x8D90: 0x544A,
	          0x8D91: 0x56FD,
	          0x8D92: 0x7A40,
	          0x8D93: 0x9177,
	          0x8D94: 0x9D60,
	          0x8D95: 0x9ED2,
	          0x8D96: 0x7344,
	          0x8D97: 0x6F09,
	          0x8D98: 0x8170,
	          0x8D99: 0x7511,
	          0x8D9A: 0x5FFD,
	          0x8D9B: 0x60DA,
	          0x8D9C: 0x9AA8,
	          0x8D9D: 0x72DB,
	          0x8D9E: 0x8FBC,
	          0x8D9F: 0x6B64,
	          0x8DA0: 0x9803,
	          0x8DA1: 0x4ECA,
	          0x8DA2: 0x56F0,
	          0x8DA3: 0x5764,
	          0x8DA4: 0x58BE,
	          0x8DA5: 0x5A5A,
	          0x8DA6: 0x6068,
	          0x8DA7: 0x61C7,
	          0x8DA8: 0x660F,
	          0x8DA9: 0x6606,
	          0x8DAA: 0x6839,
	          0x8DAB: 0x68B1,
	          0x8DAC: 0x6DF7,
	          0x8DAD: 0x75D5,
	          0x8DAE: 0x7D3A,
	          0x8DAF: 0x826E,
	          0x8DB0: 0x9B42,
	          0x8DB1: 0x4E9B,
	          0x8DB2: 0x4F50,
	          0x8DB3: 0x53C9,
	          0x8DB4: 0x5506,
	          0x8DB5: 0x5D6F,
	          0x8DB6: 0x5DE6,
	          0x8DB7: 0x5DEE,
	          0x8DB8: 0x67FB,
	          0x8DB9: 0x6C99,
	          0x8DBA: 0x7473,
	          0x8DBB: 0x7802,
	          0x8DBC: 0x8A50,
	          0x8DBD: 0x9396,
	          0x8DBE: 0x88DF,
	          0x8DBF: 0x5750,
	          0x8DC0: 0x5EA7,
	          0x8DC1: 0x632B,
	          0x8DC2: 0x50B5,
	          0x8DC3: 0x50AC,
	          0x8DC4: 0x518D,
	          0x8DC5: 0x6700,
	          0x8DC6: 0x54C9,
	          0x8DC7: 0x585E,
	          0x8DC8: 0x59BB,
	          0x8DC9: 0x5BB0,
	          0x8DCA: 0x5F69,
	          0x8DCB: 0x624D,
	          0x8DCC: 0x63A1,
	          0x8DCD: 0x683D,
	          0x8DCE: 0x6B73,
	          0x8DCF: 0x6E08,
	          0x8DD0: 0x707D,
	          0x8DD1: 0x91C7,
	          0x8DD2: 0x7280,
	          0x8DD3: 0x7815,
	          0x8DD4: 0x7826,
	          0x8DD5: 0x796D,
	          0x8DD6: 0x658E,
	          0x8DD7: 0x7D30,
	          0x8DD8: 0x83DC,
	          0x8DD9: 0x88C1,
	          0x8DDA: 0x8F09,
	          0x8DDB: 0x969B,
	          0x8DDC: 0x5264,
	          0x8DDD: 0x5728,
	          0x8DDE: 0x6750,
	          0x8DDF: 0x7F6A,
	          0x8DE0: 0x8CA1,
	          0x8DE1: 0x51B4,
	          0x8DE2: 0x5742,
	          0x8DE3: 0x962A,
	          0x8DE4: 0x583A,
	          0x8DE5: 0x698A,
	          0x8DE6: 0x80B4,
	          0x8DE7: 0x54B2,
	          0x8DE8: 0x5D0E,
	          0x8DE9: 0x57FC,
	          0x8DEA: 0x7895,
	          0x8DEB: 0x9DFA,
	          0x8DEC: 0x4F5C,
	          0x8DED: 0x524A,
	          0x8DEE: 0x548B,
	          0x8DEF: 0x643E,
	          0x8DF0: 0x6628,
	          0x8DF1: 0x6714,
	          0x8DF2: 0x67F5,
	          0x8DF3: 0x7A84,
	          0x8DF4: 0x7B56,
	          0x8DF5: 0x7D22,
	          0x8DF6: 0x932F,
	          0x8DF7: 0x685C,
	          0x8DF8: 0x9BAD,
	          0x8DF9: 0x7B39,
	          0x8DFA: 0x5319,
	          0x8DFB: 0x518A,
	          0x8DFC: 0x5237,
	          0x8E40: 0x5BDF,
	          0x8E41: 0x62F6,
	          0x8E42: 0x64AE,
	          0x8E43: 0x64E6,
	          0x8E44: 0x672D,
	          0x8E45: 0x6BBA,
	          0x8E46: 0x85A9,
	          0x8E47: 0x96D1,
	          0x8E48: 0x7690,
	          0x8E49: 0x9BD6,
	          0x8E4A: 0x634C,
	          0x8E4B: 0x9306,
	          0x8E4C: 0x9BAB,
	          0x8E4D: 0x76BF,
	          0x8E4E: 0x6652,
	          0x8E4F: 0x4E09,
	          0x8E50: 0x5098,
	          0x8E51: 0x53C2,
	          0x8E52: 0x5C71,
	          0x8E53: 0x60E8,
	          0x8E54: 0x6492,
	          0x8E55: 0x6563,
	          0x8E56: 0x685F,
	          0x8E57: 0x71E6,
	          0x8E58: 0x73CA,
	          0x8E59: 0x7523,
	          0x8E5A: 0x7B97,
	          0x8E5B: 0x7E82,
	          0x8E5C: 0x8695,
	          0x8E5D: 0x8B83,
	          0x8E5E: 0x8CDB,
	          0x8E5F: 0x9178,
	          0x8E60: 0x9910,
	          0x8E61: 0x65AC,
	          0x8E62: 0x66AB,
	          0x8E63: 0x6B8B,
	          0x8E64: 0x4ED5,
	          0x8E65: 0x4ED4,
	          0x8E66: 0x4F3A,
	          0x8E67: 0x4F7F,
	          0x8E68: 0x523A,
	          0x8E69: 0x53F8,
	          0x8E6A: 0x53F2,
	          0x8E6B: 0x55E3,
	          0x8E6C: 0x56DB,
	          0x8E6D: 0x58EB,
	          0x8E6E: 0x59CB,
	          0x8E6F: 0x59C9,
	          0x8E70: 0x59FF,
	          0x8E71: 0x5B50,
	          0x8E72: 0x5C4D,
	          0x8E73: 0x5E02,
	          0x8E74: 0x5E2B,
	          0x8E75: 0x5FD7,
	          0x8E76: 0x601D,
	          0x8E77: 0x6307,
	          0x8E78: 0x652F,
	          0x8E79: 0x5B5C,
	          0x8E7A: 0x65AF,
	          0x8E7B: 0x65BD,
	          0x8E7C: 0x65E8,
	          0x8E7D: 0x679D,
	          0x8E7E: 0x6B62,
	          0x8E80: 0x6B7B,
	          0x8E81: 0x6C0F,
	          0x8E82: 0x7345,
	          0x8E83: 0x7949,
	          0x8E84: 0x79C1,
	          0x8E85: 0x7CF8,
	          0x8E86: 0x7D19,
	          0x8E87: 0x7D2B,
	          0x8E88: 0x80A2,
	          0x8E89: 0x8102,
	          0x8E8A: 0x81F3,
	          0x8E8B: 0x8996,
	          0x8E8C: 0x8A5E,
	          0x8E8D: 0x8A69,
	          0x8E8E: 0x8A66,
	          0x8E8F: 0x8A8C,
	          0x8E90: 0x8AEE,
	          0x8E91: 0x8CC7,
	          0x8E92: 0x8CDC,
	          0x8E93: 0x96CC,
	          0x8E94: 0x98FC,
	          0x8E95: 0x6B6F,
	          0x8E96: 0x4E8B,
	          0x8E97: 0x4F3C,
	          0x8E98: 0x4F8D,
	          0x8E99: 0x5150,
	          0x8E9A: 0x5B57,
	          0x8E9B: 0x5BFA,
	          0x8E9C: 0x6148,
	          0x8E9D: 0x6301,
	          0x8E9E: 0x6642,
	          0x8E9F: 0x6B21,
	          0x8EA0: 0x6ECB,
	          0x8EA1: 0x6CBB,
	          0x8EA2: 0x723E,
	          0x8EA3: 0x74BD,
	          0x8EA4: 0x75D4,
	          0x8EA5: 0x78C1,
	          0x8EA6: 0x793A,
	          0x8EA7: 0x800C,
	          0x8EA8: 0x8033,
	          0x8EA9: 0x81EA,
	          0x8EAA: 0x8494,
	          0x8EAB: 0x8F9E,
	          0x8EAC: 0x6C50,
	          0x8EAD: 0x9E7F,
	          0x8EAE: 0x5F0F,
	          0x8EAF: 0x8B58,
	          0x8EB0: 0x9D2B,
	          0x8EB1: 0x7AFA,
	          0x8EB2: 0x8EF8,
	          0x8EB3: 0x5B8D,
	          0x8EB4: 0x96EB,
	          0x8EB5: 0x4E03,
	          0x8EB6: 0x53F1,
	          0x8EB7: 0x57F7,
	          0x8EB8: 0x5931,
	          0x8EB9: 0x5AC9,
	          0x8EBA: 0x5BA4,
	          0x8EBB: 0x6089,
	          0x8EBC: 0x6E7F,
	          0x8EBD: 0x6F06,
	          0x8EBE: 0x75BE,
	          0x8EBF: 0x8CEA,
	          0x8EC0: 0x5B9F,
	          0x8EC1: 0x8500,
	          0x8EC2: 0x7BE0,
	          0x8EC3: 0x5072,
	          0x8EC4: 0x67F4,
	          0x8EC5: 0x829D,
	          0x8EC6: 0x5C61,
	          0x8EC7: 0x854A,
	          0x8EC8: 0x7E1E,
	          0x8EC9: 0x820E,
	          0x8ECA: 0x5199,
	          0x8ECB: 0x5C04,
	          0x8ECC: 0x6368,
	          0x8ECD: 0x8D66,
	          0x8ECE: 0x659C,
	          0x8ECF: 0x716E,
	          0x8ED0: 0x793E,
	          0x8ED1: 0x7D17,
	          0x8ED2: 0x8005,
	          0x8ED3: 0x8B1D,
	          0x8ED4: 0x8ECA,
	          0x8ED5: 0x906E,
	          0x8ED6: 0x86C7,
	          0x8ED7: 0x90AA,
	          0x8ED8: 0x501F,
	          0x8ED9: 0x52FA,
	          0x8EDA: 0x5C3A,
	          0x8EDB: 0x6753,
	          0x8EDC: 0x707C,
	          0x8EDD: 0x7235,
	          0x8EDE: 0x914C,
	          0x8EDF: 0x91C8,
	          0x8EE0: 0x932B,
	          0x8EE1: 0x82E5,
	          0x8EE2: 0x5BC2,
	          0x8EE3: 0x5F31,
	          0x8EE4: 0x60F9,
	          0x8EE5: 0x4E3B,
	          0x8EE6: 0x53D6,
	          0x8EE7: 0x5B88,
	          0x8EE8: 0x624B,
	          0x8EE9: 0x6731,
	          0x8EEA: 0x6B8A,
	          0x8EEB: 0x72E9,
	          0x8EEC: 0x73E0,
	          0x8EED: 0x7A2E,
	          0x8EEE: 0x816B,
	          0x8EEF: 0x8DA3,
	          0x8EF0: 0x9152,
	          0x8EF1: 0x9996,
	          0x8EF2: 0x5112,
	          0x8EF3: 0x53D7,
	          0x8EF4: 0x546A,
	          0x8EF5: 0x5BFF,
	          0x8EF6: 0x6388,
	          0x8EF7: 0x6A39,
	          0x8EF8: 0x7DAC,
	          0x8EF9: 0x9700,
	          0x8EFA: 0x56DA,
	          0x8EFB: 0x53CE,
	          0x8EFC: 0x5468,
	          0x8F40: 0x5B97,
	          0x8F41: 0x5C31,
	          0x8F42: 0x5DDE,
	          0x8F43: 0x4FEE,
	          0x8F44: 0x6101,
	          0x8F45: 0x62FE,
	          0x8F46: 0x6D32,
	          0x8F47: 0x79C0,
	          0x8F48: 0x79CB,
	          0x8F49: 0x7D42,
	          0x8F4A: 0x7E4D,
	          0x8F4B: 0x7FD2,
	          0x8F4C: 0x81ED,
	          0x8F4D: 0x821F,
	          0x8F4E: 0x8490,
	          0x8F4F: 0x8846,
	          0x8F50: 0x8972,
	          0x8F51: 0x8B90,
	          0x8F52: 0x8E74,
	          0x8F53: 0x8F2F,
	          0x8F54: 0x9031,
	          0x8F55: 0x914B,
	          0x8F56: 0x916C,
	          0x8F57: 0x96C6,
	          0x8F58: 0x919C,
	          0x8F59: 0x4EC0,
	          0x8F5A: 0x4F4F,
	          0x8F5B: 0x5145,
	          0x8F5C: 0x5341,
	          0x8F5D: 0x5F93,
	          0x8F5E: 0x620E,
	          0x8F5F: 0x67D4,
	          0x8F60: 0x6C41,
	          0x8F61: 0x6E0B,
	          0x8F62: 0x7363,
	          0x8F63: 0x7E26,
	          0x8F64: 0x91CD,
	          0x8F65: 0x9283,
	          0x8F66: 0x53D4,
	          0x8F67: 0x5919,
	          0x8F68: 0x5BBF,
	          0x8F69: 0x6DD1,
	          0x8F6A: 0x795D,
	          0x8F6B: 0x7E2E,
	          0x8F6C: 0x7C9B,
	          0x8F6D: 0x587E,
	          0x8F6E: 0x719F,
	          0x8F6F: 0x51FA,
	          0x8F70: 0x8853,
	          0x8F71: 0x8FF0,
	          0x8F72: 0x4FCA,
	          0x8F73: 0x5CFB,
	          0x8F74: 0x6625,
	          0x8F75: 0x77AC,
	          0x8F76: 0x7AE3,
	          0x8F77: 0x821C,
	          0x8F78: 0x99FF,
	          0x8F79: 0x51C6,
	          0x8F7A: 0x5FAA,
	          0x8F7B: 0x65EC,
	          0x8F7C: 0x696F,
	          0x8F7D: 0x6B89,
	          0x8F7E: 0x6DF3,
	          0x8F80: 0x6E96,
	          0x8F81: 0x6F64,
	          0x8F82: 0x76FE,
	          0x8F83: 0x7D14,
	          0x8F84: 0x5DE1,
	          0x8F85: 0x9075,
	          0x8F86: 0x9187,
	          0x8F87: 0x9806,
	          0x8F88: 0x51E6,
	          0x8F89: 0x521D,
	          0x8F8A: 0x6240,
	          0x8F8B: 0x6691,
	          0x8F8C: 0x66D9,
	          0x8F8D: 0x6E1A,
	          0x8F8E: 0x5EB6,
	          0x8F8F: 0x7DD2,
	          0x8F90: 0x7F72,
	          0x8F91: 0x66F8,
	          0x8F92: 0x85AF,
	          0x8F93: 0x85F7,
	          0x8F94: 0x8AF8,
	          0x8F95: 0x52A9,
	          0x8F96: 0x53D9,
	          0x8F97: 0x5973,
	          0x8F98: 0x5E8F,
	          0x8F99: 0x5F90,
	          0x8F9A: 0x6055,
	          0x8F9B: 0x92E4,
	          0x8F9C: 0x9664,
	          0x8F9D: 0x50B7,
	          0x8F9E: 0x511F,
	          0x8F9F: 0x52DD,
	          0x8FA0: 0x5320,
	          0x8FA1: 0x5347,
	          0x8FA2: 0x53EC,
	          0x8FA3: 0x54E8,
	          0x8FA4: 0x5546,
	          0x8FA5: 0x5531,
	          0x8FA6: 0x5617,
	          0x8FA7: 0x5968,
	          0x8FA8: 0x59BE,
	          0x8FA9: 0x5A3C,
	          0x8FAA: 0x5BB5,
	          0x8FAB: 0x5C06,
	          0x8FAC: 0x5C0F,
	          0x8FAD: 0x5C11,
	          0x8FAE: 0x5C1A,
	          0x8FAF: 0x5E84,
	          0x8FB0: 0x5E8A,
	          0x8FB1: 0x5EE0,
	          0x8FB2: 0x5F70,
	          0x8FB3: 0x627F,
	          0x8FB4: 0x6284,
	          0x8FB5: 0x62DB,
	          0x8FB6: 0x638C,
	          0x8FB7: 0x6377,
	          0x8FB8: 0x6607,
	          0x8FB9: 0x660C,
	          0x8FBA: 0x662D,
	          0x8FBB: 0x6676,
	          0x8FBC: 0x677E,
	          0x8FBD: 0x68A2,
	          0x8FBE: 0x6A1F,
	          0x8FBF: 0x6A35,
	          0x8FC0: 0x6CBC,
	          0x8FC1: 0x6D88,
	          0x8FC2: 0x6E09,
	          0x8FC3: 0x6E58,
	          0x8FC4: 0x713C,
	          0x8FC5: 0x7126,
	          0x8FC6: 0x7167,
	          0x8FC7: 0x75C7,
	          0x8FC8: 0x7701,
	          0x8FC9: 0x785D,
	          0x8FCA: 0x7901,
	          0x8FCB: 0x7965,
	          0x8FCC: 0x79F0,
	          0x8FCD: 0x7AE0,
	          0x8FCE: 0x7B11,
	          0x8FCF: 0x7CA7,
	          0x8FD0: 0x7D39,
	          0x8FD1: 0x8096,
	          0x8FD2: 0x83D6,
	          0x8FD3: 0x848B,
	          0x8FD4: 0x8549,
	          0x8FD5: 0x885D,
	          0x8FD6: 0x88F3,
	          0x8FD7: 0x8A1F,
	          0x8FD8: 0x8A3C,
	          0x8FD9: 0x8A54,
	          0x8FDA: 0x8A73,
	          0x8FDB: 0x8C61,
	          0x8FDC: 0x8CDE,
	          0x8FDD: 0x91A4,
	          0x8FDE: 0x9266,
	          0x8FDF: 0x937E,
	          0x8FE0: 0x9418,
	          0x8FE1: 0x969C,
	          0x8FE2: 0x9798,
	          0x8FE3: 0x4E0A,
	          0x8FE4: 0x4E08,
	          0x8FE5: 0x4E1E,
	          0x8FE6: 0x4E57,
	          0x8FE7: 0x5197,
	          0x8FE8: 0x5270,
	          0x8FE9: 0x57CE,
	          0x8FEA: 0x5834,
	          0x8FEB: 0x58CC,
	          0x8FEC: 0x5B22,
	          0x8FED: 0x5E38,
	          0x8FEE: 0x60C5,
	          0x8FEF: 0x64FE,
	          0x8FF0: 0x6761,
	          0x8FF1: 0x6756,
	          0x8FF2: 0x6D44,
	          0x8FF3: 0x72B6,
	          0x8FF4: 0x7573,
	          0x8FF5: 0x7A63,
	          0x8FF6: 0x84B8,
	          0x8FF7: 0x8B72,
	          0x8FF8: 0x91B8,
	          0x8FF9: 0x9320,
	          0x8FFA: 0x5631,
	          0x8FFB: 0x57F4,
	          0x8FFC: 0x98FE,
	          0x9040: 0x62ED,
	          0x9041: 0x690D,
	          0x9042: 0x6B96,
	          0x9043: 0x71ED,
	          0x9044: 0x7E54,
	          0x9045: 0x8077,
	          0x9046: 0x8272,
	          0x9047: 0x89E6,
	          0x9048: 0x98DF,
	          0x9049: 0x8755,
	          0x904A: 0x8FB1,
	          0x904B: 0x5C3B,
	          0x904C: 0x4F38,
	          0x904D: 0x4FE1,
	          0x904E: 0x4FB5,
	          0x904F: 0x5507,
	          0x9050: 0x5A20,
	          0x9051: 0x5BDD,
	          0x9052: 0x5BE9,
	          0x9053: 0x5FC3,
	          0x9054: 0x614E,
	          0x9055: 0x632F,
	          0x9056: 0x65B0,
	          0x9057: 0x664B,
	          0x9058: 0x68EE,
	          0x9059: 0x699B,
	          0x905A: 0x6D78,
	          0x905B: 0x6DF1,
	          0x905C: 0x7533,
	          0x905D: 0x75B9,
	          0x905E: 0x771F,
	          0x905F: 0x795E,
	          0x9060: 0x79E6,
	          0x9061: 0x7D33,
	          0x9062: 0x81E3,
	          0x9063: 0x82AF,
	          0x9064: 0x85AA,
	          0x9065: 0x89AA,
	          0x9066: 0x8A3A,
	          0x9067: 0x8EAB,
	          0x9068: 0x8F9B,
	          0x9069: 0x9032,
	          0x906A: 0x91DD,
	          0x906B: 0x9707,
	          0x906C: 0x4EBA,
	          0x906D: 0x4EC1,
	          0x906E: 0x5203,
	          0x906F: 0x5875,
	          0x9070: 0x58EC,
	          0x9071: 0x5C0B,
	          0x9072: 0x751A,
	          0x9073: 0x5C3D,
	          0x9074: 0x814E,
	          0x9075: 0x8A0A,
	          0x9076: 0x8FC5,
	          0x9077: 0x9663,
	          0x9078: 0x976D,
	          0x9079: 0x7B25,
	          0x907A: 0x8ACF,
	          0x907B: 0x9808,
	          0x907C: 0x9162,
	          0x907D: 0x56F3,
	          0x907E: 0x53A8,
	          0x9080: 0x9017,
	          0x9081: 0x5439,
	          0x9082: 0x5782,
	          0x9083: 0x5E25,
	          0x9084: 0x63A8,
	          0x9085: 0x6C34,
	          0x9086: 0x708A,
	          0x9087: 0x7761,
	          0x9088: 0x7C8B,
	          0x9089: 0x7FE0,
	          0x908A: 0x8870,
	          0x908B: 0x9042,
	          0x908C: 0x9154,
	          0x908D: 0x9310,
	          0x908E: 0x9318,
	          0x908F: 0x968F,
	          0x9090: 0x745E,
	          0x9091: 0x9AC4,
	          0x9092: 0x5D07,
	          0x9093: 0x5D69,
	          0x9094: 0x6570,
	          0x9095: 0x67A2,
	          0x9096: 0x8DA8,
	          0x9097: 0x96DB,
	          0x9098: 0x636E,
	          0x9099: 0x6749,
	          0x909A: 0x6919,
	          0x909B: 0x83C5,
	          0x909C: 0x9817,
	          0x909D: 0x96C0,
	          0x909E: 0x88FE,
	          0x909F: 0x6F84,
	          0x90A0: 0x647A,
	          0x90A1: 0x5BF8,
	          0x90A2: 0x4E16,
	          0x90A3: 0x702C,
	          0x90A4: 0x755D,
	          0x90A5: 0x662F,
	          0x90A6: 0x51C4,
	          0x90A7: 0x5236,
	          0x90A8: 0x52E2,
	          0x90A9: 0x59D3,
	          0x90AA: 0x5F81,
	          0x90AB: 0x6027,
	          0x90AC: 0x6210,
	          0x90AD: 0x653F,
	          0x90AE: 0x6574,
	          0x90AF: 0x661F,
	          0x90B0: 0x6674,
	          0x90B1: 0x68F2,
	          0x90B2: 0x6816,
	          0x90B3: 0x6B63,
	          0x90B4: 0x6E05,
	          0x90B5: 0x7272,
	          0x90B6: 0x751F,
	          0x90B7: 0x76DB,
	          0x90B8: 0x7CBE,
	          0x90B9: 0x8056,
	          0x90BA: 0x58F0,
	          0x90BB: 0x88FD,
	          0x90BC: 0x897F,
	          0x90BD: 0x8AA0,
	          0x90BE: 0x8A93,
	          0x90BF: 0x8ACB,
	          0x90C0: 0x901D,
	          0x90C1: 0x9192,
	          0x90C2: 0x9752,
	          0x90C3: 0x9759,
	          0x90C4: 0x6589,
	          0x90C5: 0x7A0E,
	          0x90C6: 0x8106,
	          0x90C7: 0x96BB,
	          0x90C8: 0x5E2D,
	          0x90C9: 0x60DC,
	          0x90CA: 0x621A,
	          0x90CB: 0x65A5,
	          0x90CC: 0x6614,
	          0x90CD: 0x6790,
	          0x90CE: 0x77F3,
	          0x90CF: 0x7A4D,
	          0x90D0: 0x7C4D,
	          0x90D1: 0x7E3E,
	          0x90D2: 0x810A,
	          0x90D3: 0x8CAC,
	          0x90D4: 0x8D64,
	          0x90D5: 0x8DE1,
	          0x90D6: 0x8E5F,
	          0x90D7: 0x78A9,
	          0x90D8: 0x5207,
	          0x90D9: 0x62D9,
	          0x90DA: 0x63A5,
	          0x90DB: 0x6442,
	          0x90DC: 0x6298,
	          0x90DD: 0x8A2D,
	          0x90DE: 0x7A83,
	          0x90DF: 0x7BC0,
	          0x90E0: 0x8AAC,
	          0x90E1: 0x96EA,
	          0x90E2: 0x7D76,
	          0x90E3: 0x820C,
	          0x90E4: 0x8749,
	          0x90E5: 0x4ED9,
	          0x90E6: 0x5148,
	          0x90E7: 0x5343,
	          0x90E8: 0x5360,
	          0x90E9: 0x5BA3,
	          0x90EA: 0x5C02,
	          0x90EB: 0x5C16,
	          0x90EC: 0x5DDD,
	          0x90ED: 0x6226,
	          0x90EE: 0x6247,
	          0x90EF: 0x64B0,
	          0x90F0: 0x6813,
	          0x90F1: 0x6834,
	          0x90F2: 0x6CC9,
	          0x90F3: 0x6D45,
	          0x90F4: 0x6D17,
	          0x90F5: 0x67D3,
	          0x90F6: 0x6F5C,
	          0x90F7: 0x714E,
	          0x90F8: 0x717D,
	          0x90F9: 0x65CB,
	          0x90FA: 0x7A7F,
	          0x90FB: 0x7BAD,
	          0x90FC: 0x7DDA,
	          0x9140: 0x7E4A,
	          0x9141: 0x7FA8,
	          0x9142: 0x817A,
	          0x9143: 0x821B,
	          0x9144: 0x8239,
	          0x9145: 0x85A6,
	          0x9146: 0x8A6E,
	          0x9147: 0x8CCE,
	          0x9148: 0x8DF5,
	          0x9149: 0x9078,
	          0x914A: 0x9077,
	          0x914B: 0x92AD,
	          0x914C: 0x9291,
	          0x914D: 0x9583,
	          0x914E: 0x9BAE,
	          0x914F: 0x524D,
	          0x9150: 0x5584,
	          0x9151: 0x6F38,
	          0x9152: 0x7136,
	          0x9153: 0x5168,
	          0x9154: 0x7985,
	          0x9155: 0x7E55,
	          0x9156: 0x81B3,
	          0x9157: 0x7CCE,
	          0x9158: 0x564C,
	          0x9159: 0x5851,
	          0x915A: 0x5CA8,
	          0x915B: 0x63AA,
	          0x915C: 0x66FE,
	          0x915D: 0x66FD,
	          0x915E: 0x695A,
	          0x915F: 0x72D9,
	          0x9160: 0x758F,
	          0x9161: 0x758E,
	          0x9162: 0x790E,
	          0x9163: 0x7956,
	          0x9164: 0x79DF,
	          0x9165: 0x7C97,
	          0x9166: 0x7D20,
	          0x9167: 0x7D44,
	          0x9168: 0x8607,
	          0x9169: 0x8A34,
	          0x916A: 0x963B,
	          0x916B: 0x9061,
	          0x916C: 0x9F20,
	          0x916D: 0x50E7,
	          0x916E: 0x5275,
	          0x916F: 0x53CC,
	          0x9170: 0x53E2,
	          0x9171: 0x5009,
	          0x9172: 0x55AA,
	          0x9173: 0x58EE,
	          0x9174: 0x594F,
	          0x9175: 0x723D,
	          0x9176: 0x5B8B,
	          0x9177: 0x5C64,
	          0x9178: 0x531D,
	          0x9179: 0x60E3,
	          0x917A: 0x60F3,
	          0x917B: 0x635C,
	          0x917C: 0x6383,
	          0x917D: 0x633F,
	          0x917E: 0x63BB,
	          0x9180: 0x64CD,
	          0x9181: 0x65E9,
	          0x9182: 0x66F9,
	          0x9183: 0x5DE3,
	          0x9184: 0x69CD,
	          0x9185: 0x69FD,
	          0x9186: 0x6F15,
	          0x9187: 0x71E5,
	          0x9188: 0x4E89,
	          0x9189: 0x75E9,
	          0x918A: 0x76F8,
	          0x918B: 0x7A93,
	          0x918C: 0x7CDF,
	          0x918D: 0x7DCF,
	          0x918E: 0x7D9C,
	          0x918F: 0x8061,
	          0x9190: 0x8349,
	          0x9191: 0x8358,
	          0x9192: 0x846C,
	          0x9193: 0x84BC,
	          0x9194: 0x85FB,
	          0x9195: 0x88C5,
	          0x9196: 0x8D70,
	          0x9197: 0x9001,
	          0x9198: 0x906D,
	          0x9199: 0x9397,
	          0x919A: 0x971C,
	          0x919B: 0x9A12,
	          0x919C: 0x50CF,
	          0x919D: 0x5897,
	          0x919E: 0x618E,
	          0x919F: 0x81D3,
	          0x91A0: 0x8535,
	          0x91A1: 0x8D08,
	          0x91A2: 0x9020,
	          0x91A3: 0x4FC3,
	          0x91A4: 0x5074,
	          0x91A5: 0x5247,
	          0x91A6: 0x5373,
	          0x91A7: 0x606F,
	          0x91A8: 0x6349,
	          0x91A9: 0x675F,
	          0x91AA: 0x6E2C,
	          0x91AB: 0x8DB3,
	          0x91AC: 0x901F,
	          0x91AD: 0x4FD7,
	          0x91AE: 0x5C5E,
	          0x91AF: 0x8CCA,
	          0x91B0: 0x65CF,
	          0x91B1: 0x7D9A,
	          0x91B2: 0x5352,
	          0x91B3: 0x8896,
	          0x91B4: 0x5176,
	          0x91B5: 0x63C3,
	          0x91B6: 0x5B58,
	          0x91B7: 0x5B6B,
	          0x91B8: 0x5C0A,
	          0x91B9: 0x640D,
	          0x91BA: 0x6751,
	          0x91BB: 0x905C,
	          0x91BC: 0x4ED6,
	          0x91BD: 0x591A,
	          0x91BE: 0x592A,
	          0x91BF: 0x6C70,
	          0x91C0: 0x8A51,
	          0x91C1: 0x553E,
	          0x91C2: 0x5815,
	          0x91C3: 0x59A5,
	          0x91C4: 0x60F0,
	          0x91C5: 0x6253,
	          0x91C6: 0x67C1,
	          0x91C7: 0x8235,
	          0x91C8: 0x6955,
	          0x91C9: 0x9640,
	          0x91CA: 0x99C4,
	          0x91CB: 0x9A28,
	          0x91CC: 0x4F53,
	          0x91CD: 0x5806,
	          0x91CE: 0x5BFE,
	          0x91CF: 0x8010,
	          0x91D0: 0x5CB1,
	          0x91D1: 0x5E2F,
	          0x91D2: 0x5F85,
	          0x91D3: 0x6020,
	          0x91D4: 0x614B,
	          0x91D5: 0x6234,
	          0x91D6: 0x66FF,
	          0x91D7: 0x6CF0,
	          0x91D8: 0x6EDE,
	          0x91D9: 0x80CE,
	          0x91DA: 0x817F,
	          0x91DB: 0x82D4,
	          0x91DC: 0x888B,
	          0x91DD: 0x8CB8,
	          0x91DE: 0x9000,
	          0x91DF: 0x902E,
	          0x91E0: 0x968A,
	          0x91E1: 0x9EDB,
	          0x91E2: 0x9BDB,
	          0x91E3: 0x4EE3,
	          0x91E4: 0x53F0,
	          0x91E5: 0x5927,
	          0x91E6: 0x7B2C,
	          0x91E7: 0x918D,
	          0x91E8: 0x984C,
	          0x91E9: 0x9DF9,
	          0x91EA: 0x6EDD,
	          0x91EB: 0x7027,
	          0x91EC: 0x5353,
	          0x91ED: 0x5544,
	          0x91EE: 0x5B85,
	          0x91EF: 0x6258,
	          0x91F0: 0x629E,
	          0x91F1: 0x62D3,
	          0x91F2: 0x6CA2,
	          0x91F3: 0x6FEF,
	          0x91F4: 0x7422,
	          0x91F5: 0x8A17,
	          0x91F6: 0x9438,
	          0x91F7: 0x6FC1,
	          0x91F8: 0x8AFE,
	          0x91F9: 0x8338,
	          0x91FA: 0x51E7,
	          0x91FB: 0x86F8,
	          0x91FC: 0x53EA,
	          0x9240: 0x53E9,
	          0x9241: 0x4F46,
	          0x9242: 0x9054,
	          0x9243: 0x8FB0,
	          0x9244: 0x596A,
	          0x9245: 0x8131,
	          0x9246: 0x5DFD,
	          0x9247: 0x7AEA,
	          0x9248: 0x8FBF,
	          0x9249: 0x68DA,
	          0x924A: 0x8C37,
	          0x924B: 0x72F8,
	          0x924C: 0x9C48,
	          0x924D: 0x6A3D,
	          0x924E: 0x8AB0,
	          0x924F: 0x4E39,
	          0x9250: 0x5358,
	          0x9251: 0x5606,
	          0x9252: 0x5766,
	          0x9253: 0x62C5,
	          0x9254: 0x63A2,
	          0x9255: 0x65E6,
	          0x9256: 0x6B4E,
	          0x9257: 0x6DE1,
	          0x9258: 0x6E5B,
	          0x9259: 0x70AD,
	          0x925A: 0x77ED,
	          0x925B: 0x7AEF,
	          0x925C: 0x7BAA,
	          0x925D: 0x7DBB,
	          0x925E: 0x803D,
	          0x925F: 0x80C6,
	          0x9260: 0x86CB,
	          0x9261: 0x8A95,
	          0x9262: 0x935B,
	          0x9263: 0x56E3,
	          0x9264: 0x58C7,
	          0x9265: 0x5F3E,
	          0x9266: 0x65AD,
	          0x9267: 0x6696,
	          0x9268: 0x6A80,
	          0x9269: 0x6BB5,
	          0x926A: 0x7537,
	          0x926B: 0x8AC7,
	          0x926C: 0x5024,
	          0x926D: 0x77E5,
	          0x926E: 0x5730,
	          0x926F: 0x5F1B,
	          0x9270: 0x6065,
	          0x9271: 0x667A,
	          0x9272: 0x6C60,
	          0x9273: 0x75F4,
	          0x9274: 0x7A1A,
	          0x9275: 0x7F6E,
	          0x9276: 0x81F4,
	          0x9277: 0x8718,
	          0x9278: 0x9045,
	          0x9279: 0x99B3,
	          0x927A: 0x7BC9,
	          0x927B: 0x755C,
	          0x927C: 0x7AF9,
	          0x927D: 0x7B51,
	          0x927E: 0x84C4,
	          0x9280: 0x9010,
	          0x9281: 0x79E9,
	          0x9282: 0x7A92,
	          0x9283: 0x8336,
	          0x9284: 0x5AE1,
	          0x9285: 0x7740,
	          0x9286: 0x4E2D,
	          0x9287: 0x4EF2,
	          0x9288: 0x5B99,
	          0x9289: 0x5FE0,
	          0x928A: 0x62BD,
	          0x928B: 0x663C,
	          0x928C: 0x67F1,
	          0x928D: 0x6CE8,
	          0x928E: 0x866B,
	          0x928F: 0x8877,
	          0x9290: 0x8A3B,
	          0x9291: 0x914E,
	          0x9292: 0x92F3,
	          0x9293: 0x99D0,
	          0x9294: 0x6A17,
	          0x9295: 0x7026,
	          0x9296: 0x732A,
	          0x9297: 0x82E7,
	          0x9298: 0x8457,
	          0x9299: 0x8CAF,
	          0x929A: 0x4E01,
	          0x929B: 0x5146,
	          0x929C: 0x51CB,
	          0x929D: 0x558B,
	          0x929E: 0x5BF5,
	          0x929F: 0x5E16,
	          0x92A0: 0x5E33,
	          0x92A1: 0x5E81,
	          0x92A2: 0x5F14,
	          0x92A3: 0x5F35,
	          0x92A4: 0x5F6B,
	          0x92A5: 0x5FB4,
	          0x92A6: 0x61F2,
	          0x92A7: 0x6311,
	          0x92A8: 0x66A2,
	          0x92A9: 0x671D,
	          0x92AA: 0x6F6E,
	          0x92AB: 0x7252,
	          0x92AC: 0x753A,
	          0x92AD: 0x773A,
	          0x92AE: 0x8074,
	          0x92AF: 0x8139,
	          0x92B0: 0x8178,
	          0x92B1: 0x8776,
	          0x92B2: 0x8ABF,
	          0x92B3: 0x8ADC,
	          0x92B4: 0x8D85,
	          0x92B5: 0x8DF3,
	          0x92B6: 0x929A,
	          0x92B7: 0x9577,
	          0x92B8: 0x9802,
	          0x92B9: 0x9CE5,
	          0x92BA: 0x52C5,
	          0x92BB: 0x6357,
	          0x92BC: 0x76F4,
	          0x92BD: 0x6715,
	          0x92BE: 0x6C88,
	          0x92BF: 0x73CD,
	          0x92C0: 0x8CC3,
	          0x92C1: 0x93AE,
	          0x92C2: 0x9673,
	          0x92C3: 0x6D25,
	          0x92C4: 0x589C,
	          0x92C5: 0x690E,
	          0x92C6: 0x69CC,
	          0x92C7: 0x8FFD,
	          0x92C8: 0x939A,
	          0x92C9: 0x75DB,
	          0x92CA: 0x901A,
	          0x92CB: 0x585A,
	          0x92CC: 0x6802,
	          0x92CD: 0x63B4,
	          0x92CE: 0x69FB,
	          0x92CF: 0x4F43,
	          0x92D0: 0x6F2C,
	          0x92D1: 0x67D8,
	          0x92D2: 0x8FBB,
	          0x92D3: 0x8526,
	          0x92D4: 0x7DB4,
	          0x92D5: 0x9354,
	          0x92D6: 0x693F,
	          0x92D7: 0x6F70,
	          0x92D8: 0x576A,
	          0x92D9: 0x58F7,
	          0x92DA: 0x5B2C,
	          0x92DB: 0x7D2C,
	          0x92DC: 0x722A,
	          0x92DD: 0x540A,
	          0x92DE: 0x91E3,
	          0x92DF: 0x9DB4,
	          0x92E0: 0x4EAD,
	          0x92E1: 0x4F4E,
	          0x92E2: 0x505C,
	          0x92E3: 0x5075,
	          0x92E4: 0x5243,
	          0x92E5: 0x8C9E,
	          0x92E6: 0x5448,
	          0x92E7: 0x5824,
	          0x92E8: 0x5B9A,
	          0x92E9: 0x5E1D,
	          0x92EA: 0x5E95,
	          0x92EB: 0x5EAD,
	          0x92EC: 0x5EF7,
	          0x92ED: 0x5F1F,
	          0x92EE: 0x608C,
	          0x92EF: 0x62B5,
	          0x92F0: 0x633A,
	          0x92F1: 0x63D0,
	          0x92F2: 0x68AF,
	          0x92F3: 0x6C40,
	          0x92F4: 0x7887,
	          0x92F5: 0x798E,
	          0x92F6: 0x7A0B,
	          0x92F7: 0x7DE0,
	          0x92F8: 0x8247,
	          0x92F9: 0x8A02,
	          0x92FA: 0x8AE6,
	          0x92FB: 0x8E44,
	          0x92FC: 0x9013,
	          0x9340: 0x90B8,
	          0x9341: 0x912D,
	          0x9342: 0x91D8,
	          0x9343: 0x9F0E,
	          0x9344: 0x6CE5,
	          0x9345: 0x6458,
	          0x9346: 0x64E2,
	          0x9347: 0x6575,
	          0x9348: 0x6EF4,
	          0x9349: 0x7684,
	          0x934A: 0x7B1B,
	          0x934B: 0x9069,
	          0x934C: 0x93D1,
	          0x934D: 0x6EBA,
	          0x934E: 0x54F2,
	          0x934F: 0x5FB9,
	          0x9350: 0x64A4,
	          0x9351: 0x8F4D,
	          0x9352: 0x8FED,
	          0x9353: 0x9244,
	          0x9354: 0x5178,
	          0x9355: 0x586B,
	          0x9356: 0x5929,
	          0x9357: 0x5C55,
	          0x9358: 0x5E97,
	          0x9359: 0x6DFB,
	          0x935A: 0x7E8F,
	          0x935B: 0x751C,
	          0x935C: 0x8CBC,
	          0x935D: 0x8EE2,
	          0x935E: 0x985B,
	          0x935F: 0x70B9,
	          0x9360: 0x4F1D,
	          0x9361: 0x6BBF,
	          0x9362: 0x6FB1,
	          0x9363: 0x7530,
	          0x9364: 0x96FB,
	          0x9365: 0x514E,
	          0x9366: 0x5410,
	          0x9367: 0x5835,
	          0x9368: 0x5857,
	          0x9369: 0x59AC,
	          0x936A: 0x5C60,
	          0x936B: 0x5F92,
	          0x936C: 0x6597,
	          0x936D: 0x675C,
	          0x936E: 0x6E21,
	          0x936F: 0x767B,
	          0x9370: 0x83DF,
	          0x9371: 0x8CED,
	          0x9372: 0x9014,
	          0x9373: 0x90FD,
	          0x9374: 0x934D,
	          0x9375: 0x7825,
	          0x9376: 0x783A,
	          0x9377: 0x52AA,
	          0x9378: 0x5EA6,
	          0x9379: 0x571F,
	          0x937A: 0x5974,
	          0x937B: 0x6012,
	          0x937C: 0x5012,
	          0x937D: 0x515A,
	          0x937E: 0x51AC,
	          0x9380: 0x51CD,
	          0x9381: 0x5200,
	          0x9382: 0x5510,
	          0x9383: 0x5854,
	          0x9384: 0x5858,
	          0x9385: 0x5957,
	          0x9386: 0x5B95,
	          0x9387: 0x5CF6,
	          0x9388: 0x5D8B,
	          0x9389: 0x60BC,
	          0x938A: 0x6295,
	          0x938B: 0x642D,
	          0x938C: 0x6771,
	          0x938D: 0x6843,
	          0x938E: 0x68BC,
	          0x938F: 0x68DF,
	          0x9390: 0x76D7,
	          0x9391: 0x6DD8,
	          0x9392: 0x6E6F,
	          0x9393: 0x6D9B,
	          0x9394: 0x706F,
	          0x9395: 0x71C8,
	          0x9396: 0x5F53,
	          0x9397: 0x75D8,
	          0x9398: 0x7977,
	          0x9399: 0x7B49,
	          0x939A: 0x7B54,
	          0x939B: 0x7B52,
	          0x939C: 0x7CD6,
	          0x939D: 0x7D71,
	          0x939E: 0x5230,
	          0x939F: 0x8463,
	          0x93A0: 0x8569,
	          0x93A1: 0x85E4,
	          0x93A2: 0x8A0E,
	          0x93A3: 0x8B04,
	          0x93A4: 0x8C46,
	          0x93A5: 0x8E0F,
	          0x93A6: 0x9003,
	          0x93A7: 0x900F,
	          0x93A8: 0x9419,
	          0x93A9: 0x9676,
	          0x93AA: 0x982D,
	          0x93AB: 0x9A30,
	          0x93AC: 0x95D8,
	          0x93AD: 0x50CD,
	          0x93AE: 0x52D5,
	          0x93AF: 0x540C,
	          0x93B0: 0x5802,
	          0x93B1: 0x5C0E,
	          0x93B2: 0x61A7,
	          0x93B3: 0x649E,
	          0x93B4: 0x6D1E,
	          0x93B5: 0x77B3,
	          0x93B6: 0x7AE5,
	          0x93B7: 0x80F4,
	          0x93B8: 0x8404,
	          0x93B9: 0x9053,
	          0x93BA: 0x9285,
	          0x93BB: 0x5CE0,
	          0x93BC: 0x9D07,
	          0x93BD: 0x533F,
	          0x93BE: 0x5F97,
	          0x93BF: 0x5FB3,
	          0x93C0: 0x6D9C,
	          0x93C1: 0x7279,
	          0x93C2: 0x7763,
	          0x93C3: 0x79BF,
	          0x93C4: 0x7BE4,
	          0x93C5: 0x6BD2,
	          0x93C6: 0x72EC,
	          0x93C7: 0x8AAD,
	          0x93C8: 0x6803,
	          0x93C9: 0x6A61,
	          0x93CA: 0x51F8,
	          0x93CB: 0x7A81,
	          0x93CC: 0x6934,
	          0x93CD: 0x5C4A,
	          0x93CE: 0x9CF6,
	          0x93CF: 0x82EB,
	          0x93D0: 0x5BC5,
	          0x93D1: 0x9149,
	          0x93D2: 0x701E,
	          0x93D3: 0x5678,
	          0x93D4: 0x5C6F,
	          0x93D5: 0x60C7,
	          0x93D6: 0x6566,
	          0x93D7: 0x6C8C,
	          0x93D8: 0x8C5A,
	          0x93D9: 0x9041,
	          0x93DA: 0x9813,
	          0x93DB: 0x5451,
	          0x93DC: 0x66C7,
	          0x93DD: 0x920D,
	          0x93DE: 0x5948,
	          0x93DF: 0x90A3,
	          0x93E0: 0x5185,
	          0x93E1: 0x4E4D,
	          0x93E2: 0x51EA,
	          0x93E3: 0x8599,
	          0x93E4: 0x8B0E,
	          0x93E5: 0x7058,
	          0x93E6: 0x637A,
	          0x93E7: 0x934B,
	          0x93E8: 0x6962,
	          0x93E9: 0x99B4,
	          0x93EA: 0x7E04,
	          0x93EB: 0x7577,
	          0x93EC: 0x5357,
	          0x93ED: 0x6960,
	          0x93EE: 0x8EDF,
	          0x93EF: 0x96E3,
	          0x93F0: 0x6C5D,
	          0x93F1: 0x4E8C,
	          0x93F2: 0x5C3C,
	          0x93F3: 0x5F10,
	          0x93F4: 0x8FE9,
	          0x93F5: 0x5302,
	          0x93F6: 0x8CD1,
	          0x93F7: 0x8089,
	          0x93F8: 0x8679,
	          0x93F9: 0x5EFF,
	          0x93FA: 0x65E5,
	          0x93FB: 0x4E73,
	          0x93FC: 0x5165,
	          0x9440: 0x5982,
	          0x9441: 0x5C3F,
	          0x9442: 0x97EE,
	          0x9443: 0x4EFB,
	          0x9444: 0x598A,
	          0x9445: 0x5FCD,
	          0x9446: 0x8A8D,
	          0x9447: 0x6FE1,
	          0x9448: 0x79B0,
	          0x9449: 0x7962,
	          0x944A: 0x5BE7,
	          0x944B: 0x8471,
	          0x944C: 0x732B,
	          0x944D: 0x71B1,
	          0x944E: 0x5E74,
	          0x944F: 0x5FF5,
	          0x9450: 0x637B,
	          0x9451: 0x649A,
	          0x9452: 0x71C3,
	          0x9453: 0x7C98,
	          0x9454: 0x4E43,
	          0x9455: 0x5EFC,
	          0x9456: 0x4E4B,
	          0x9457: 0x57DC,
	          0x9458: 0x56A2,
	          0x9459: 0x60A9,
	          0x945A: 0x6FC3,
	          0x945B: 0x7D0D,
	          0x945C: 0x80FD,
	          0x945D: 0x8133,
	          0x945E: 0x81BF,
	          0x945F: 0x8FB2,
	          0x9460: 0x8997,
	          0x9461: 0x86A4,
	          0x9462: 0x5DF4,
	          0x9463: 0x628A,
	          0x9464: 0x64AD,
	          0x9465: 0x8987,
	          0x9466: 0x6777,
	          0x9467: 0x6CE2,
	          0x9468: 0x6D3E,
	          0x9469: 0x7436,
	          0x946A: 0x7834,
	          0x946B: 0x5A46,
	          0x946C: 0x7F75,
	          0x946D: 0x82AD,
	          0x946E: 0x99AC,
	          0x946F: 0x4FF3,
	          0x9470: 0x5EC3,
	          0x9471: 0x62DD,
	          0x9472: 0x6392,
	          0x9473: 0x6557,
	          0x9474: 0x676F,
	          0x9475: 0x76C3,
	          0x9476: 0x724C,
	          0x9477: 0x80CC,
	          0x9478: 0x80BA,
	          0x9479: 0x8F29,
	          0x947A: 0x914D,
	          0x947B: 0x500D,
	          0x947C: 0x57F9,
	          0x947D: 0x5A92,
	          0x947E: 0x6885,
	          0x9480: 0x6973,
	          0x9481: 0x7164,
	          0x9482: 0x72FD,
	          0x9483: 0x8CB7,
	          0x9484: 0x58F2,
	          0x9485: 0x8CE0,
	          0x9486: 0x966A,
	          0x9487: 0x9019,
	          0x9488: 0x877F,
	          0x9489: 0x79E4,
	          0x948A: 0x77E7,
	          0x948B: 0x8429,
	          0x948C: 0x4F2F,
	          0x948D: 0x5265,
	          0x948E: 0x535A,
	          0x948F: 0x62CD,
	          0x9490: 0x67CF,
	          0x9491: 0x6CCA,
	          0x9492: 0x767D,
	          0x9493: 0x7B94,
	          0x9494: 0x7C95,
	          0x9495: 0x8236,
	          0x9496: 0x8584,
	          0x9497: 0x8FEB,
	          0x9498: 0x66DD,
	          0x9499: 0x6F20,
	          0x949A: 0x7206,
	          0x949B: 0x7E1B,
	          0x949C: 0x83AB,
	          0x949D: 0x99C1,
	          0x949E: 0x9EA6,
	          0x949F: 0x51FD,
	          0x94A0: 0x7BB1,
	          0x94A1: 0x7872,
	          0x94A2: 0x7BB8,
	          0x94A3: 0x8087,
	          0x94A4: 0x7B48,
	          0x94A5: 0x6AE8,
	          0x94A6: 0x5E61,
	          0x94A7: 0x808C,
	          0x94A8: 0x7551,
	          0x94A9: 0x7560,
	          0x94AA: 0x516B,
	          0x94AB: 0x9262,
	          0x94AC: 0x6E8C,
	          0x94AD: 0x767A,
	          0x94AE: 0x9197,
	          0x94AF: 0x9AEA,
	          0x94B0: 0x4F10,
	          0x94B1: 0x7F70,
	          0x94B2: 0x629C,
	          0x94B3: 0x7B4F,
	          0x94B4: 0x95A5,
	          0x94B5: 0x9CE9,
	          0x94B6: 0x567A,
	          0x94B7: 0x5859,
	          0x94B8: 0x86E4,
	          0x94B9: 0x96BC,
	          0x94BA: 0x4F34,
	          0x94BB: 0x5224,
	          0x94BC: 0x534A,
	          0x94BD: 0x53CD,
	          0x94BE: 0x53DB,
	          0x94BF: 0x5E06,
	          0x94C0: 0x642C,
	          0x94C1: 0x6591,
	          0x94C2: 0x677F,
	          0x94C3: 0x6C3E,
	          0x94C4: 0x6C4E,
	          0x94C5: 0x7248,
	          0x94C6: 0x72AF,
	          0x94C7: 0x73ED,
	          0x94C8: 0x7554,
	          0x94C9: 0x7E41,
	          0x94CA: 0x822C,
	          0x94CB: 0x85E9,
	          0x94CC: 0x8CA9,
	          0x94CD: 0x7BC4,
	          0x94CE: 0x91C6,
	          0x94CF: 0x7169,
	          0x94D0: 0x9812,
	          0x94D1: 0x98EF,
	          0x94D2: 0x633D,
	          0x94D3: 0x6669,
	          0x94D4: 0x756A,
	          0x94D5: 0x76E4,
	          0x94D6: 0x78D0,
	          0x94D7: 0x8543,
	          0x94D8: 0x86EE,
	          0x94D9: 0x532A,
	          0x94DA: 0x5351,
	          0x94DB: 0x5426,
	          0x94DC: 0x5983,
	          0x94DD: 0x5E87,
	          0x94DE: 0x5F7C,
	          0x94DF: 0x60B2,
	          0x94E0: 0x6249,
	          0x94E1: 0x6279,
	          0x94E2: 0x62AB,
	          0x94E3: 0x6590,
	          0x94E4: 0x6BD4,
	          0x94E5: 0x6CCC,
	          0x94E6: 0x75B2,
	          0x94E7: 0x76AE,
	          0x94E8: 0x7891,
	          0x94E9: 0x79D8,
	          0x94EA: 0x7DCB,
	          0x94EB: 0x7F77,
	          0x94EC: 0x80A5,
	          0x94ED: 0x88AB,
	          0x94EE: 0x8AB9,
	          0x94EF: 0x8CBB,
	          0x94F0: 0x907F,
	          0x94F1: 0x975E,
	          0x94F2: 0x98DB,
	          0x94F3: 0x6A0B,
	          0x94F4: 0x7C38,
	          0x94F5: 0x5099,
	          0x94F6: 0x5C3E,
	          0x94F7: 0x5FAE,
	          0x94F8: 0x6787,
	          0x94F9: 0x6BD8,
	          0x94FA: 0x7435,
	          0x94FB: 0x7709,
	          0x94FC: 0x7F8E,
	          0x9540: 0x9F3B,
	          0x9541: 0x67CA,
	          0x9542: 0x7A17,
	          0x9543: 0x5339,
	          0x9544: 0x758B,
	          0x9545: 0x9AED,
	          0x9546: 0x5F66,
	          0x9547: 0x819D,
	          0x9548: 0x83F1,
	          0x9549: 0x8098,
	          0x954A: 0x5F3C,
	          0x954B: 0x5FC5,
	          0x954C: 0x7562,
	          0x954D: 0x7B46,
	          0x954E: 0x903C,
	          0x954F: 0x6867,
	          0x9550: 0x59EB,
	          0x9551: 0x5A9B,
	          0x9552: 0x7D10,
	          0x9553: 0x767E,
	          0x9554: 0x8B2C,
	          0x9555: 0x4FF5,
	          0x9556: 0x5F6A,
	          0x9557: 0x6A19,
	          0x9558: 0x6C37,
	          0x9559: 0x6F02,
	          0x955A: 0x74E2,
	          0x955B: 0x7968,
	          0x955C: 0x8868,
	          0x955D: 0x8A55,
	          0x955E: 0x8C79,
	          0x955F: 0x5EDF,
	          0x9560: 0x63CF,
	          0x9561: 0x75C5,
	          0x9562: 0x79D2,
	          0x9563: 0x82D7,
	          0x9564: 0x9328,
	          0x9565: 0x92F2,
	          0x9566: 0x849C,
	          0x9567: 0x86ED,
	          0x9568: 0x9C2D,
	          0x9569: 0x54C1,
	          0x956A: 0x5F6C,
	          0x956B: 0x658C,
	          0x956C: 0x6D5C,
	          0x956D: 0x7015,
	          0x956E: 0x8CA7,
	          0x956F: 0x8CD3,
	          0x9570: 0x983B,
	          0x9571: 0x654F,
	          0x9572: 0x74F6,
	          0x9573: 0x4E0D,
	          0x9574: 0x4ED8,
	          0x9575: 0x57E0,
	          0x9576: 0x592B,
	          0x9577: 0x5A66,
	          0x9578: 0x5BCC,
	          0x9579: 0x51A8,
	          0x957A: 0x5E03,
	          0x957B: 0x5E9C,
	          0x957C: 0x6016,
	          0x957D: 0x6276,
	          0x957E: 0x6577,
	          0x9580: 0x65A7,
	          0x9581: 0x666E,
	          0x9582: 0x6D6E,
	          0x9583: 0x7236,
	          0x9584: 0x7B26,
	          0x9585: 0x8150,
	          0x9586: 0x819A,
	          0x9587: 0x8299,
	          0x9588: 0x8B5C,
	          0x9589: 0x8CA0,
	          0x958A: 0x8CE6,
	          0x958B: 0x8D74,
	          0x958C: 0x961C,
	          0x958D: 0x9644,
	          0x958E: 0x4FAE,
	          0x958F: 0x64AB,
	          0x9590: 0x6B66,
	          0x9591: 0x821E,
	          0x9592: 0x8461,
	          0x9593: 0x856A,
	          0x9594: 0x90E8,
	          0x9595: 0x5C01,
	          0x9596: 0x6953,
	          0x9597: 0x98A8,
	          0x9598: 0x847A,
	          0x9599: 0x8557,
	          0x959A: 0x4F0F,
	          0x959B: 0x526F,
	          0x959C: 0x5FA9,
	          0x959D: 0x5E45,
	          0x959E: 0x670D,
	          0x959F: 0x798F,
	          0x95A0: 0x8179,
	          0x95A1: 0x8907,
	          0x95A2: 0x8986,
	          0x95A3: 0x6DF5,
	          0x95A4: 0x5F17,
	          0x95A5: 0x6255,
	          0x95A6: 0x6CB8,
	          0x95A7: 0x4ECF,
	          0x95A8: 0x7269,
	          0x95A9: 0x9B92,
	          0x95AA: 0x5206,
	          0x95AB: 0x543B,
	          0x95AC: 0x5674,
	          0x95AD: 0x58B3,
	          0x95AE: 0x61A4,
	          0x95AF: 0x626E,
	          0x95B0: 0x711A,
	          0x95B1: 0x596E,
	          0x95B2: 0x7C89,
	          0x95B3: 0x7CDE,
	          0x95B4: 0x7D1B,
	          0x95B5: 0x96F0,
	          0x95B6: 0x6587,
	          0x95B7: 0x805E,
	          0x95B8: 0x4E19,
	          0x95B9: 0x4F75,
	          0x95BA: 0x5175,
	          0x95BB: 0x5840,
	          0x95BC: 0x5E63,
	          0x95BD: 0x5E73,
	          0x95BE: 0x5F0A,
	          0x95BF: 0x67C4,
	          0x95C0: 0x4E26,
	          0x95C1: 0x853D,
	          0x95C2: 0x9589,
	          0x95C3: 0x965B,
	          0x95C4: 0x7C73,
	          0x95C5: 0x9801,
	          0x95C6: 0x50FB,
	          0x95C7: 0x58C1,
	          0x95C8: 0x7656,
	          0x95C9: 0x78A7,
	          0x95CA: 0x5225,
	          0x95CB: 0x77A5,
	          0x95CC: 0x8511,
	          0x95CD: 0x7B86,
	          0x95CE: 0x504F,
	          0x95CF: 0x5909,
	          0x95D0: 0x7247,
	          0x95D1: 0x7BC7,
	          0x95D2: 0x7DE8,
	          0x95D3: 0x8FBA,
	          0x95D4: 0x8FD4,
	          0x95D5: 0x904D,
	          0x95D6: 0x4FBF,
	          0x95D7: 0x52C9,
	          0x95D8: 0x5A29,
	          0x95D9: 0x5F01,
	          0x95DA: 0x97AD,
	          0x95DB: 0x4FDD,
	          0x95DC: 0x8217,
	          0x95DD: 0x92EA,
	          0x95DE: 0x5703,
	          0x95DF: 0x6355,
	          0x95E0: 0x6B69,
	          0x95E1: 0x752B,
	          0x95E2: 0x88DC,
	          0x95E3: 0x8F14,
	          0x95E4: 0x7A42,
	          0x95E5: 0x52DF,
	          0x95E6: 0x5893,
	          0x95E7: 0x6155,
	          0x95E8: 0x620A,
	          0x95E9: 0x66AE,
	          0x95EA: 0x6BCD,
	          0x95EB: 0x7C3F,
	          0x95EC: 0x83E9,
	          0x95ED: 0x5023,
	          0x95EE: 0x4FF8,
	          0x95EF: 0x5305,
	          0x95F0: 0x5446,
	          0x95F1: 0x5831,
	          0x95F2: 0x5949,
	          0x95F3: 0x5B9D,
	          0x95F4: 0x5CF0,
	          0x95F5: 0x5CEF,
	          0x95F6: 0x5D29,
	          0x95F7: 0x5E96,
	          0x95F8: 0x62B1,
	          0x95F9: 0x6367,
	          0x95FA: 0x653E,
	          0x95FB: 0x65B9,
	          0x95FC: 0x670B,
	          0x9640: 0x6CD5,
	          0x9641: 0x6CE1,
	          0x9642: 0x70F9,
	          0x9643: 0x7832,
	          0x9644: 0x7E2B,
	          0x9645: 0x80DE,
	          0x9646: 0x82B3,
	          0x9647: 0x840C,
	          0x9648: 0x84EC,
	          0x9649: 0x8702,
	          0x964A: 0x8912,
	          0x964B: 0x8A2A,
	          0x964C: 0x8C4A,
	          0x964D: 0x90A6,
	          0x964E: 0x92D2,
	          0x964F: 0x98FD,
	          0x9650: 0x9CF3,
	          0x9651: 0x9D6C,
	          0x9652: 0x4E4F,
	          0x9653: 0x4EA1,
	          0x9654: 0x508D,
	          0x9655: 0x5256,
	          0x9656: 0x574A,
	          0x9657: 0x59A8,
	          0x9658: 0x5E3D,
	          0x9659: 0x5FD8,
	          0x965A: 0x5FD9,
	          0x965B: 0x623F,
	          0x965C: 0x66B4,
	          0x965D: 0x671B,
	          0x965E: 0x67D0,
	          0x965F: 0x68D2,
	          0x9660: 0x5192,
	          0x9661: 0x7D21,
	          0x9662: 0x80AA,
	          0x9663: 0x81A8,
	          0x9664: 0x8B00,
	          0x9665: 0x8C8C,
	          0x9666: 0x8CBF,
	          0x9667: 0x927E,
	          0x9668: 0x9632,
	          0x9669: 0x5420,
	          0x966A: 0x982C,
	          0x966B: 0x5317,
	          0x966C: 0x50D5,
	          0x966D: 0x535C,
	          0x966E: 0x58A8,
	          0x966F: 0x64B2,
	          0x9670: 0x6734,
	          0x9671: 0x7267,
	          0x9672: 0x7766,
	          0x9673: 0x7A46,
	          0x9674: 0x91E6,
	          0x9675: 0x52C3,
	          0x9676: 0x6CA1,
	          0x9677: 0x6B86,
	          0x9678: 0x5800,
	          0x9679: 0x5E4C,
	          0x967A: 0x5954,
	          0x967B: 0x672C,
	          0x967C: 0x7FFB,
	          0x967D: 0x51E1,
	          0x967E: 0x76C6,
	          0x9680: 0x6469,
	          0x9681: 0x78E8,
	          0x9682: 0x9B54,
	          0x9683: 0x9EBB,
	          0x9684: 0x57CB,
	          0x9685: 0x59B9,
	          0x9686: 0x6627,
	          0x9687: 0x679A,
	          0x9688: 0x6BCE,
	          0x9689: 0x54E9,
	          0x968A: 0x69D9,
	          0x968B: 0x5E55,
	          0x968C: 0x819C,
	          0x968D: 0x6795,
	          0x968E: 0x9BAA,
	          0x968F: 0x67FE,
	          0x9690: 0x9C52,
	          0x9691: 0x685D,
	          0x9692: 0x4EA6,
	          0x9693: 0x4FE3,
	          0x9694: 0x53C8,
	          0x9695: 0x62B9,
	          0x9696: 0x672B,
	          0x9697: 0x6CAB,
	          0x9698: 0x8FC4,
	          0x9699: 0x4FAD,
	          0x969A: 0x7E6D,
	          0x969B: 0x9EBF,
	          0x969C: 0x4E07,
	          0x969D: 0x6162,
	          0x969E: 0x6E80,
	          0x969F: 0x6F2B,
	          0x96A0: 0x8513,
	          0x96A1: 0x5473,
	          0x96A2: 0x672A,
	          0x96A3: 0x9B45,
	          0x96A4: 0x5DF3,
	          0x96A5: 0x7B95,
	          0x96A6: 0x5CAC,
	          0x96A7: 0x5BC6,
	          0x96A8: 0x871C,
	          0x96A9: 0x6E4A,
	          0x96AA: 0x84D1,
	          0x96AB: 0x7A14,
	          0x96AC: 0x8108,
	          0x96AD: 0x5999,
	          0x96AE: 0x7C8D,
	          0x96AF: 0x6C11,
	          0x96B0: 0x7720,
	          0x96B1: 0x52D9,
	          0x96B2: 0x5922,
	          0x96B3: 0x7121,
	          0x96B4: 0x725F,
	          0x96B5: 0x77DB,
	          0x96B6: 0x9727,
	          0x96B7: 0x9D61,
	          0x96B8: 0x690B,
	          0x96B9: 0x5A7F,
	          0x96BA: 0x5A18,
	          0x96BB: 0x51A5,
	          0x96BC: 0x540D,
	          0x96BD: 0x547D,
	          0x96BE: 0x660E,
	          0x96BF: 0x76DF,
	          0x96C0: 0x8FF7,
	          0x96C1: 0x9298,
	          0x96C2: 0x9CF4,
	          0x96C3: 0x59EA,
	          0x96C4: 0x725D,
	          0x96C5: 0x6EC5,
	          0x96C6: 0x514D,
	          0x96C7: 0x68C9,
	          0x96C8: 0x7DBF,
	          0x96C9: 0x7DEC,
	          0x96CA: 0x9762,
	          0x96CB: 0x9EBA,
	          0x96CC: 0x6478,
	          0x96CD: 0x6A21,
	          0x96CE: 0x8302,
	          0x96CF: 0x5984,
	          0x96D0: 0x5B5F,
	          0x96D1: 0x6BDB,
	          0x96D2: 0x731B,
	          0x96D3: 0x76F2,
	          0x96D4: 0x7DB2,
	          0x96D5: 0x8017,
	          0x96D6: 0x8499,
	          0x96D7: 0x5132,
	          0x96D8: 0x6728,
	          0x96D9: 0x9ED9,
	          0x96DA: 0x76EE,
	          0x96DB: 0x6762,
	          0x96DC: 0x52FF,
	          0x96DD: 0x9905,
	          0x96DE: 0x5C24,
	          0x96DF: 0x623B,
	          0x96E0: 0x7C7E,
	          0x96E1: 0x8CB0,
	          0x96E2: 0x554F,
	          0x96E3: 0x60B6,
	          0x96E4: 0x7D0B,
	          0x96E5: 0x9580,
	          0x96E6: 0x5301,
	          0x96E7: 0x4E5F,
	          0x96E8: 0x51B6,
	          0x96E9: 0x591C,
	          0x96EA: 0x723A,
	          0x96EB: 0x8036,
	          0x96EC: 0x91CE,
	          0x96ED: 0x5F25,
	          0x96EE: 0x77E2,
	          0x96EF: 0x5384,
	          0x96F0: 0x5F79,
	          0x96F1: 0x7D04,
	          0x96F2: 0x85AC,
	          0x96F3: 0x8A33,
	          0x96F4: 0x8E8D,
	          0x96F5: 0x9756,
	          0x96F6: 0x67F3,
	          0x96F7: 0x85AE,
	          0x96F8: 0x9453,
	          0x96F9: 0x6109,
	          0x96FA: 0x6108,
	          0x96FB: 0x6CB9,
	          0x96FC: 0x7652,
	          0x9740: 0x8AED,
	          0x9741: 0x8F38,
	          0x9742: 0x552F,
	          0x9743: 0x4F51,
	          0x9744: 0x512A,
	          0x9745: 0x52C7,
	          0x9746: 0x53CB,
	          0x9747: 0x5BA5,
	          0x9748: 0x5E7D,
	          0x9749: 0x60A0,
	          0x974A: 0x6182,
	          0x974B: 0x63D6,
	          0x974C: 0x6709,
	          0x974D: 0x67DA,
	          0x974E: 0x6E67,
	          0x974F: 0x6D8C,
	          0x9750: 0x7336,
	          0x9751: 0x7337,
	          0x9752: 0x7531,
	          0x9753: 0x7950,
	          0x9754: 0x88D5,
	          0x9755: 0x8A98,
	          0x9756: 0x904A,
	          0x9757: 0x9091,
	          0x9758: 0x90F5,
	          0x9759: 0x96C4,
	          0x975A: 0x878D,
	          0x975B: 0x5915,
	          0x975C: 0x4E88,
	          0x975D: 0x4F59,
	          0x975E: 0x4E0E,
	          0x975F: 0x8A89,
	          0x9760: 0x8F3F,
	          0x9761: 0x9810,
	          0x9762: 0x50AD,
	          0x9763: 0x5E7C,
	          0x9764: 0x5996,
	          0x9765: 0x5BB9,
	          0x9766: 0x5EB8,
	          0x9767: 0x63DA,
	          0x9768: 0x63FA,
	          0x9769: 0x64C1,
	          0x976A: 0x66DC,
	          0x976B: 0x694A,
	          0x976C: 0x69D8,
	          0x976D: 0x6D0B,
	          0x976E: 0x6EB6,
	          0x976F: 0x7194,
	          0x9770: 0x7528,
	          0x9771: 0x7AAF,
	          0x9772: 0x7F8A,
	          0x9773: 0x8000,
	          0x9774: 0x8449,
	          0x9775: 0x84C9,
	          0x9776: 0x8981,
	          0x9777: 0x8B21,
	          0x9778: 0x8E0A,
	          0x9779: 0x9065,
	          0x977A: 0x967D,
	          0x977B: 0x990A,
	          0x977C: 0x617E,
	          0x977D: 0x6291,
	          0x977E: 0x6B32,
	          0x9780: 0x6C83,
	          0x9781: 0x6D74,
	          0x9782: 0x7FCC,
	          0x9783: 0x7FFC,
	          0x9784: 0x6DC0,
	          0x9785: 0x7F85,
	          0x9786: 0x87BA,
	          0x9787: 0x88F8,
	          0x9788: 0x6765,
	          0x9789: 0x83B1,
	          0x978A: 0x983C,
	          0x978B: 0x96F7,
	          0x978C: 0x6D1B,
	          0x978D: 0x7D61,
	          0x978E: 0x843D,
	          0x978F: 0x916A,
	          0x9790: 0x4E71,
	          0x9791: 0x5375,
	          0x9792: 0x5D50,
	          0x9793: 0x6B04,
	          0x9794: 0x6FEB,
	          0x9795: 0x85CD,
	          0x9796: 0x862D,
	          0x9797: 0x89A7,
	          0x9798: 0x5229,
	          0x9799: 0x540F,
	          0x979A: 0x5C65,
	          0x979B: 0x674E,
	          0x979C: 0x68A8,
	          0x979D: 0x7406,
	          0x979E: 0x7483,
	          0x979F: 0x75E2,
	          0x97A0: 0x88CF,
	          0x97A1: 0x88E1,
	          0x97A2: 0x91CC,
	          0x97A3: 0x96E2,
	          0x97A4: 0x9678,
	          0x97A5: 0x5F8B,
	          0x97A6: 0x7387,
	          0x97A7: 0x7ACB,
	          0x97A8: 0x844E,
	          0x97A9: 0x63A0,
	          0x97AA: 0x7565,
	          0x97AB: 0x5289,
	          0x97AC: 0x6D41,
	          0x97AD: 0x6E9C,
	          0x97AE: 0x7409,
	          0x97AF: 0x7559,
	          0x97B0: 0x786B,
	          0x97B1: 0x7C92,
	          0x97B2: 0x9686,
	          0x97B3: 0x7ADC,
	          0x97B4: 0x9F8D,
	          0x97B5: 0x4FB6,
	          0x97B6: 0x616E,
	          0x97B7: 0x65C5,
	          0x97B8: 0x865C,
	          0x97B9: 0x4E86,
	          0x97BA: 0x4EAE,
	          0x97BB: 0x50DA,
	          0x97BC: 0x4E21,
	          0x97BD: 0x51CC,
	          0x97BE: 0x5BEE,
	          0x97BF: 0x6599,
	          0x97C0: 0x6881,
	          0x97C1: 0x6DBC,
	          0x97C2: 0x731F,
	          0x97C3: 0x7642,
	          0x97C4: 0x77AD,
	          0x97C5: 0x7A1C,
	          0x97C6: 0x7CE7,
	          0x97C7: 0x826F,
	          0x97C8: 0x8AD2,
	          0x97C9: 0x907C,
	          0x97CA: 0x91CF,
	          0x97CB: 0x9675,
	          0x97CC: 0x9818,
	          0x97CD: 0x529B,
	          0x97CE: 0x7DD1,
	          0x97CF: 0x502B,
	          0x97D0: 0x5398,
	          0x97D1: 0x6797,
	          0x97D2: 0x6DCB,
	          0x97D3: 0x71D0,
	          0x97D4: 0x7433,
	          0x97D5: 0x81E8,
	          0x97D6: 0x8F2A,
	          0x97D7: 0x96A3,
	          0x97D8: 0x9C57,
	          0x97D9: 0x9E9F,
	          0x97DA: 0x7460,
	          0x97DB: 0x5841,
	          0x97DC: 0x6D99,
	          0x97DD: 0x7D2F,
	          0x97DE: 0x985E,
	          0x97DF: 0x4EE4,
	          0x97E0: 0x4F36,
	          0x97E1: 0x4F8B,
	          0x97E2: 0x51B7,
	          0x97E3: 0x52B1,
	          0x97E4: 0x5DBA,
	          0x97E5: 0x601C,
	          0x97E6: 0x73B2,
	          0x97E7: 0x793C,
	          0x97E8: 0x82D3,
	          0x97E9: 0x9234,
	          0x97EA: 0x96B7,
	          0x97EB: 0x96F6,
	          0x97EC: 0x970A,
	          0x97ED: 0x9E97,
	          0x97EE: 0x9F62,
	          0x97EF: 0x66A6,
	          0x97F0: 0x6B74,
	          0x97F1: 0x5217,
	          0x97F2: 0x52A3,
	          0x97F3: 0x70C8,
	          0x97F4: 0x88C2,
	          0x97F5: 0x5EC9,
	          0x97F6: 0x604B,
	          0x97F7: 0x6190,
	          0x97F8: 0x6F23,
	          0x97F9: 0x7149,
	          0x97FA: 0x7C3E,
	          0x97FB: 0x7DF4,
	          0x97FC: 0x806F,
	          0x9840: 0x84EE,
	          0x9841: 0x9023,
	          0x9842: 0x932C,
	          0x9843: 0x5442,
	          0x9844: 0x9B6F,
	          0x9845: 0x6AD3,
	          0x9846: 0x7089,
	          0x9847: 0x8CC2,
	          0x9848: 0x8DEF,
	          0x9849: 0x9732,
	          0x984A: 0x52B4,
	          0x984B: 0x5A41,
	          0x984C: 0x5ECA,
	          0x984D: 0x5F04,
	          0x984E: 0x6717,
	          0x984F: 0x697C,
	          0x9850: 0x6994,
	          0x9851: 0x6D6A,
	          0x9852: 0x6F0F,
	          0x9853: 0x7262,
	          0x9854: 0x72FC,
	          0x9855: 0x7BED,
	          0x9856: 0x8001,
	          0x9857: 0x807E,
	          0x9858: 0x874B,
	          0x9859: 0x90CE,
	          0x985A: 0x516D,
	          0x985B: 0x9E93,
	          0x985C: 0x7984,
	          0x985D: 0x808B,
	          0x985E: 0x9332,
	          0x985F: 0x8AD6,
	          0x9860: 0x502D,
	          0x9861: 0x548C,
	          0x9862: 0x8A71,
	          0x9863: 0x6B6A,
	          0x9864: 0x8CC4,
	          0x9865: 0x8107,
	          0x9866: 0x60D1,
	          0x9867: 0x67A0,
	          0x9868: 0x9DF2,
	          0x9869: 0x4E99,
	          0x986A: 0x4E98,
	          0x986B: 0x9C10,
	          0x986C: 0x8A6B,
	          0x986D: 0x85C1,
	          0x986E: 0x8568,
	          0x986F: 0x6900,
	          0x9870: 0x6E7E,
	          0x9871: 0x7897,
	          0x9872: 0x8155,
	          0x989F: 0x5F0C,
	          0x98A0: 0x4E10,
	          0x98A1: 0x4E15,
	          0x98A2: 0x4E2A,
	          0x98A3: 0x4E31,
	          0x98A4: 0x4E36,
	          0x98A5: 0x4E3C,
	          0x98A6: 0x4E3F,
	          0x98A7: 0x4E42,
	          0x98A8: 0x4E56,
	          0x98A9: 0x4E58,
	          0x98AA: 0x4E82,
	          0x98AB: 0x4E85,
	          0x98AC: 0x8C6B,
	          0x98AD: 0x4E8A,
	          0x98AE: 0x8212,
	          0x98AF: 0x5F0D,
	          0x98B0: 0x4E8E,
	          0x98B1: 0x4E9E,
	          0x98B2: 0x4E9F,
	          0x98B3: 0x4EA0,
	          0x98B4: 0x4EA2,
	          0x98B5: 0x4EB0,
	          0x98B6: 0x4EB3,
	          0x98B7: 0x4EB6,
	          0x98B8: 0x4ECE,
	          0x98B9: 0x4ECD,
	          0x98BA: 0x4EC4,
	          0x98BB: 0x4EC6,
	          0x98BC: 0x4EC2,
	          0x98BD: 0x4ED7,
	          0x98BE: 0x4EDE,
	          0x98BF: 0x4EED,
	          0x98C0: 0x4EDF,
	          0x98C1: 0x4EF7,
	          0x98C2: 0x4F09,
	          0x98C3: 0x4F5A,
	          0x98C4: 0x4F30,
	          0x98C5: 0x4F5B,
	          0x98C6: 0x4F5D,
	          0x98C7: 0x4F57,
	          0x98C8: 0x4F47,
	          0x98C9: 0x4F76,
	          0x98CA: 0x4F88,
	          0x98CB: 0x4F8F,
	          0x98CC: 0x4F98,
	          0x98CD: 0x4F7B,
	          0x98CE: 0x4F69,
	          0x98CF: 0x4F70,
	          0x98D0: 0x4F91,
	          0x98D1: 0x4F6F,
	          0x98D2: 0x4F86,
	          0x98D3: 0x4F96,
	          0x98D4: 0x5118,
	          0x98D5: 0x4FD4,
	          0x98D6: 0x4FDF,
	          0x98D7: 0x4FCE,
	          0x98D8: 0x4FD8,
	          0x98D9: 0x4FDB,
	          0x98DA: 0x4FD1,
	          0x98DB: 0x4FDA,
	          0x98DC: 0x4FD0,
	          0x98DD: 0x4FE4,
	          0x98DE: 0x4FE5,
	          0x98DF: 0x501A,
	          0x98E0: 0x5028,
	          0x98E1: 0x5014,
	          0x98E2: 0x502A,
	          0x98E3: 0x5025,
	          0x98E4: 0x5005,
	          0x98E5: 0x4F1C,
	          0x98E6: 0x4FF6,
	          0x98E7: 0x5021,
	          0x98E8: 0x5029,
	          0x98E9: 0x502C,
	          0x98EA: 0x4FFE,
	          0x98EB: 0x4FEF,
	          0x98EC: 0x5011,
	          0x98ED: 0x5006,
	          0x98EE: 0x5043,
	          0x98EF: 0x5047,
	          0x98F0: 0x6703,
	          0x98F1: 0x5055,
	          0x98F2: 0x5050,
	          0x98F3: 0x5048,
	          0x98F4: 0x505A,
	          0x98F5: 0x5056,
	          0x98F6: 0x506C,
	          0x98F7: 0x5078,
	          0x98F8: 0x5080,
	          0x98F9: 0x509A,
	          0x98FA: 0x5085,
	          0x98FB: 0x50B4,
	          0x98FC: 0x50B2,
	          0x9940: 0x50C9,
	          0x9941: 0x50CA,
	          0x9942: 0x50B3,
	          0x9943: 0x50C2,
	          0x9944: 0x50D6,
	          0x9945: 0x50DE,
	          0x9946: 0x50E5,
	          0x9947: 0x50ED,
	          0x9948: 0x50E3,
	          0x9949: 0x50EE,
	          0x994A: 0x50F9,
	          0x994B: 0x50F5,
	          0x994C: 0x5109,
	          0x994D: 0x5101,
	          0x994E: 0x5102,
	          0x994F: 0x5116,
	          0x9950: 0x5115,
	          0x9951: 0x5114,
	          0x9952: 0x511A,
	          0x9953: 0x5121,
	          0x9954: 0x513A,
	          0x9955: 0x5137,
	          0x9956: 0x513C,
	          0x9957: 0x513B,
	          0x9958: 0x513F,
	          0x9959: 0x5140,
	          0x995A: 0x5152,
	          0x995B: 0x514C,
	          0x995C: 0x5154,
	          0x995D: 0x5162,
	          0x995E: 0x7AF8,
	          0x995F: 0x5169,
	          0x9960: 0x516A,
	          0x9961: 0x516E,
	          0x9962: 0x5180,
	          0x9963: 0x5182,
	          0x9964: 0x56D8,
	          0x9965: 0x518C,
	          0x9966: 0x5189,
	          0x9967: 0x518F,
	          0x9968: 0x5191,
	          0x9969: 0x5193,
	          0x996A: 0x5195,
	          0x996B: 0x5196,
	          0x996C: 0x51A4,
	          0x996D: 0x51A6,
	          0x996E: 0x51A2,
	          0x996F: 0x51A9,
	          0x9970: 0x51AA,
	          0x9971: 0x51AB,
	          0x9972: 0x51B3,
	          0x9973: 0x51B1,
	          0x9974: 0x51B2,
	          0x9975: 0x51B0,
	          0x9976: 0x51B5,
	          0x9977: 0x51BD,
	          0x9978: 0x51C5,
	          0x9979: 0x51C9,
	          0x997A: 0x51DB,
	          0x997B: 0x51E0,
	          0x997C: 0x8655,
	          0x997D: 0x51E9,
	          0x997E: 0x51ED,
	          0x9980: 0x51F0,
	          0x9981: 0x51F5,
	          0x9982: 0x51FE,
	          0x9983: 0x5204,
	          0x9984: 0x520B,
	          0x9985: 0x5214,
	          0x9986: 0x520E,
	          0x9987: 0x5227,
	          0x9988: 0x522A,
	          0x9989: 0x522E,
	          0x998A: 0x5233,
	          0x998B: 0x5239,
	          0x998C: 0x524F,
	          0x998D: 0x5244,
	          0x998E: 0x524B,
	          0x998F: 0x524C,
	          0x9990: 0x525E,
	          0x9991: 0x5254,
	          0x9992: 0x526A,
	          0x9993: 0x5274,
	          0x9994: 0x5269,
	          0x9995: 0x5273,
	          0x9996: 0x527F,
	          0x9997: 0x527D,
	          0x9998: 0x528D,
	          0x9999: 0x5294,
	          0x999A: 0x5292,
	          0x999B: 0x5271,
	          0x999C: 0x5288,
	          0x999D: 0x5291,
	          0x999E: 0x8FA8,
	          0x999F: 0x8FA7,
	          0x99A0: 0x52AC,
	          0x99A1: 0x52AD,
	          0x99A2: 0x52BC,
	          0x99A3: 0x52B5,
	          0x99A4: 0x52C1,
	          0x99A5: 0x52CD,
	          0x99A6: 0x52D7,
	          0x99A7: 0x52DE,
	          0x99A8: 0x52E3,
	          0x99A9: 0x52E6,
	          0x99AA: 0x98ED,
	          0x99AB: 0x52E0,
	          0x99AC: 0x52F3,
	          0x99AD: 0x52F5,
	          0x99AE: 0x52F8,
	          0x99AF: 0x52F9,
	          0x99B0: 0x5306,
	          0x99B1: 0x5308,
	          0x99B2: 0x7538,
	          0x99B3: 0x530D,
	          0x99B4: 0x5310,
	          0x99B5: 0x530F,
	          0x99B6: 0x5315,
	          0x99B7: 0x531A,
	          0x99B8: 0x5323,
	          0x99B9: 0x532F,
	          0x99BA: 0x5331,
	          0x99BB: 0x5333,
	          0x99BC: 0x5338,
	          0x99BD: 0x5340,
	          0x99BE: 0x5346,
	          0x99BF: 0x5345,
	          0x99C0: 0x4E17,
	          0x99C1: 0x5349,
	          0x99C2: 0x534D,
	          0x99C3: 0x51D6,
	          0x99C4: 0x535E,
	          0x99C5: 0x5369,
	          0x99C6: 0x536E,
	          0x99C7: 0x5918,
	          0x99C8: 0x537B,
	          0x99C9: 0x5377,
	          0x99CA: 0x5382,
	          0x99CB: 0x5396,
	          0x99CC: 0x53A0,
	          0x99CD: 0x53A6,
	          0x99CE: 0x53A5,
	          0x99CF: 0x53AE,
	          0x99D0: 0x53B0,
	          0x99D1: 0x53B6,
	          0x99D2: 0x53C3,
	          0x99D3: 0x7C12,
	          0x99D4: 0x96D9,
	          0x99D5: 0x53DF,
	          0x99D6: 0x66FC,
	          0x99D7: 0x71EE,
	          0x99D8: 0x53EE,
	          0x99D9: 0x53E8,
	          0x99DA: 0x53ED,
	          0x99DB: 0x53FA,
	          0x99DC: 0x5401,
	          0x99DD: 0x543D,
	          0x99DE: 0x5440,
	          0x99DF: 0x542C,
	          0x99E0: 0x542D,
	          0x99E1: 0x543C,
	          0x99E2: 0x542E,
	          0x99E3: 0x5436,
	          0x99E4: 0x5429,
	          0x99E5: 0x541D,
	          0x99E6: 0x544E,
	          0x99E7: 0x548F,
	          0x99E8: 0x5475,
	          0x99E9: 0x548E,
	          0x99EA: 0x545F,
	          0x99EB: 0x5471,
	          0x99EC: 0x5477,
	          0x99ED: 0x5470,
	          0x99EE: 0x5492,
	          0x99EF: 0x547B,
	          0x99F0: 0x5480,
	          0x99F1: 0x5476,
	          0x99F2: 0x5484,
	          0x99F3: 0x5490,
	          0x99F4: 0x5486,
	          0x99F5: 0x54C7,
	          0x99F6: 0x54A2,
	          0x99F7: 0x54B8,
	          0x99F8: 0x54A5,
	          0x99F9: 0x54AC,
	          0x99FA: 0x54C4,
	          0x99FB: 0x54C8,
	          0x99FC: 0x54A8,
	          0x9A40: 0x54AB,
	          0x9A41: 0x54C2,
	          0x9A42: 0x54A4,
	          0x9A43: 0x54BE,
	          0x9A44: 0x54BC,
	          0x9A45: 0x54D8,
	          0x9A46: 0x54E5,
	          0x9A47: 0x54E6,
	          0x9A48: 0x550F,
	          0x9A49: 0x5514,
	          0x9A4A: 0x54FD,
	          0x9A4B: 0x54EE,
	          0x9A4C: 0x54ED,
	          0x9A4D: 0x54FA,
	          0x9A4E: 0x54E2,
	          0x9A4F: 0x5539,
	          0x9A50: 0x5540,
	          0x9A51: 0x5563,
	          0x9A52: 0x554C,
	          0x9A53: 0x552E,
	          0x9A54: 0x555C,
	          0x9A55: 0x5545,
	          0x9A56: 0x5556,
	          0x9A57: 0x5557,
	          0x9A58: 0x5538,
	          0x9A59: 0x5533,
	          0x9A5A: 0x555D,
	          0x9A5B: 0x5599,
	          0x9A5C: 0x5580,
	          0x9A5D: 0x54AF,
	          0x9A5E: 0x558A,
	          0x9A5F: 0x559F,
	          0x9A60: 0x557B,
	          0x9A61: 0x557E,
	          0x9A62: 0x5598,
	          0x9A63: 0x559E,
	          0x9A64: 0x55AE,
	          0x9A65: 0x557C,
	          0x9A66: 0x5583,
	          0x9A67: 0x55A9,
	          0x9A68: 0x5587,
	          0x9A69: 0x55A8,
	          0x9A6A: 0x55DA,
	          0x9A6B: 0x55C5,
	          0x9A6C: 0x55DF,
	          0x9A6D: 0x55C4,
	          0x9A6E: 0x55DC,
	          0x9A6F: 0x55E4,
	          0x9A70: 0x55D4,
	          0x9A71: 0x5614,
	          0x9A72: 0x55F7,
	          0x9A73: 0x5616,
	          0x9A74: 0x55FE,
	          0x9A75: 0x55FD,
	          0x9A76: 0x561B,
	          0x9A77: 0x55F9,
	          0x9A78: 0x564E,
	          0x9A79: 0x5650,
	          0x9A7A: 0x71DF,
	          0x9A7B: 0x5634,
	          0x9A7C: 0x5636,
	          0x9A7D: 0x5632,
	          0x9A7E: 0x5638,
	          0x9A80: 0x566B,
	          0x9A81: 0x5664,
	          0x9A82: 0x562F,
	          0x9A83: 0x566C,
	          0x9A84: 0x566A,
	          0x9A85: 0x5686,
	          0x9A86: 0x5680,
	          0x9A87: 0x568A,
	          0x9A88: 0x56A0,
	          0x9A89: 0x5694,
	          0x9A8A: 0x568F,
	          0x9A8B: 0x56A5,
	          0x9A8C: 0x56AE,
	          0x9A8D: 0x56B6,
	          0x9A8E: 0x56B4,
	          0x9A8F: 0x56C2,
	          0x9A90: 0x56BC,
	          0x9A91: 0x56C1,
	          0x9A92: 0x56C3,
	          0x9A93: 0x56C0,
	          0x9A94: 0x56C8,
	          0x9A95: 0x56CE,
	          0x9A96: 0x56D1,
	          0x9A97: 0x56D3,
	          0x9A98: 0x56D7,
	          0x9A99: 0x56EE,
	          0x9A9A: 0x56F9,
	          0x9A9B: 0x5700,
	          0x9A9C: 0x56FF,
	          0x9A9D: 0x5704,
	          0x9A9E: 0x5709,
	          0x9A9F: 0x5708,
	          0x9AA0: 0x570B,
	          0x9AA1: 0x570D,
	          0x9AA2: 0x5713,
	          0x9AA3: 0x5718,
	          0x9AA4: 0x5716,
	          0x9AA5: 0x55C7,
	          0x9AA6: 0x571C,
	          0x9AA7: 0x5726,
	          0x9AA8: 0x5737,
	          0x9AA9: 0x5738,
	          0x9AAA: 0x574E,
	          0x9AAB: 0x573B,
	          0x9AAC: 0x5740,
	          0x9AAD: 0x574F,
	          0x9AAE: 0x5769,
	          0x9AAF: 0x57C0,
	          0x9AB0: 0x5788,
	          0x9AB1: 0x5761,
	          0x9AB2: 0x577F,
	          0x9AB3: 0x5789,
	          0x9AB4: 0x5793,
	          0x9AB5: 0x57A0,
	          0x9AB6: 0x57B3,
	          0x9AB7: 0x57A4,
	          0x9AB8: 0x57AA,
	          0x9AB9: 0x57B0,
	          0x9ABA: 0x57C3,
	          0x9ABB: 0x57C6,
	          0x9ABC: 0x57D4,
	          0x9ABD: 0x57D2,
	          0x9ABE: 0x57D3,
	          0x9ABF: 0x580A,
	          0x9AC0: 0x57D6,
	          0x9AC1: 0x57E3,
	          0x9AC2: 0x580B,
	          0x9AC3: 0x5819,
	          0x9AC4: 0x581D,
	          0x9AC5: 0x5872,
	          0x9AC6: 0x5821,
	          0x9AC7: 0x5862,
	          0x9AC8: 0x584B,
	          0x9AC9: 0x5870,
	          0x9ACA: 0x6BC0,
	          0x9ACB: 0x5852,
	          0x9ACC: 0x583D,
	          0x9ACD: 0x5879,
	          0x9ACE: 0x5885,
	          0x9ACF: 0x58B9,
	          0x9AD0: 0x589F,
	          0x9AD1: 0x58AB,
	          0x9AD2: 0x58BA,
	          0x9AD3: 0x58DE,
	          0x9AD4: 0x58BB,
	          0x9AD5: 0x58B8,
	          0x9AD6: 0x58AE,
	          0x9AD7: 0x58C5,
	          0x9AD8: 0x58D3,
	          0x9AD9: 0x58D1,
	          0x9ADA: 0x58D7,
	          0x9ADB: 0x58D9,
	          0x9ADC: 0x58D8,
	          0x9ADD: 0x58E5,
	          0x9ADE: 0x58DC,
	          0x9ADF: 0x58E4,
	          0x9AE0: 0x58DF,
	          0x9AE1: 0x58EF,
	          0x9AE2: 0x58FA,
	          0x9AE3: 0x58F9,
	          0x9AE4: 0x58FB,
	          0x9AE5: 0x58FC,
	          0x9AE6: 0x58FD,
	          0x9AE7: 0x5902,
	          0x9AE8: 0x590A,
	          0x9AE9: 0x5910,
	          0x9AEA: 0x591B,
	          0x9AEB: 0x68A6,
	          0x9AEC: 0x5925,
	          0x9AED: 0x592C,
	          0x9AEE: 0x592D,
	          0x9AEF: 0x5932,
	          0x9AF0: 0x5938,
	          0x9AF1: 0x593E,
	          0x9AF2: 0x7AD2,
	          0x9AF3: 0x5955,
	          0x9AF4: 0x5950,
	          0x9AF5: 0x594E,
	          0x9AF6: 0x595A,
	          0x9AF7: 0x5958,
	          0x9AF8: 0x5962,
	          0x9AF9: 0x5960,
	          0x9AFA: 0x5967,
	          0x9AFB: 0x596C,
	          0x9AFC: 0x5969,
	          0x9B40: 0x5978,
	          0x9B41: 0x5981,
	          0x9B42: 0x599D,
	          0x9B43: 0x4F5E,
	          0x9B44: 0x4FAB,
	          0x9B45: 0x59A3,
	          0x9B46: 0x59B2,
	          0x9B47: 0x59C6,
	          0x9B48: 0x59E8,
	          0x9B49: 0x59DC,
	          0x9B4A: 0x598D,
	          0x9B4B: 0x59D9,
	          0x9B4C: 0x59DA,
	          0x9B4D: 0x5A25,
	          0x9B4E: 0x5A1F,
	          0x9B4F: 0x5A11,
	          0x9B50: 0x5A1C,
	          0x9B51: 0x5A09,
	          0x9B52: 0x5A1A,
	          0x9B53: 0x5A40,
	          0x9B54: 0x5A6C,
	          0x9B55: 0x5A49,
	          0x9B56: 0x5A35,
	          0x9B57: 0x5A36,
	          0x9B58: 0x5A62,
	          0x9B59: 0x5A6A,
	          0x9B5A: 0x5A9A,
	          0x9B5B: 0x5ABC,
	          0x9B5C: 0x5ABE,
	          0x9B5D: 0x5ACB,
	          0x9B5E: 0x5AC2,
	          0x9B5F: 0x5ABD,
	          0x9B60: 0x5AE3,
	          0x9B61: 0x5AD7,
	          0x9B62: 0x5AE6,
	          0x9B63: 0x5AE9,
	          0x9B64: 0x5AD6,
	          0x9B65: 0x5AFA,
	          0x9B66: 0x5AFB,
	          0x9B67: 0x5B0C,
	          0x9B68: 0x5B0B,
	          0x9B69: 0x5B16,
	          0x9B6A: 0x5B32,
	          0x9B6B: 0x5AD0,
	          0x9B6C: 0x5B2A,
	          0x9B6D: 0x5B36,
	          0x9B6E: 0x5B3E,
	          0x9B6F: 0x5B43,
	          0x9B70: 0x5B45,
	          0x9B71: 0x5B40,
	          0x9B72: 0x5B51,
	          0x9B73: 0x5B55,
	          0x9B74: 0x5B5A,
	          0x9B75: 0x5B5B,
	          0x9B76: 0x5B65,
	          0x9B77: 0x5B69,
	          0x9B78: 0x5B70,
	          0x9B79: 0x5B73,
	          0x9B7A: 0x5B75,
	          0x9B7B: 0x5B78,
	          0x9B7C: 0x6588,
	          0x9B7D: 0x5B7A,
	          0x9B7E: 0x5B80,
	          0x9B80: 0x5B83,
	          0x9B81: 0x5BA6,
	          0x9B82: 0x5BB8,
	          0x9B83: 0x5BC3,
	          0x9B84: 0x5BC7,
	          0x9B85: 0x5BC9,
	          0x9B86: 0x5BD4,
	          0x9B87: 0x5BD0,
	          0x9B88: 0x5BE4,
	          0x9B89: 0x5BE6,
	          0x9B8A: 0x5BE2,
	          0x9B8B: 0x5BDE,
	          0x9B8C: 0x5BE5,
	          0x9B8D: 0x5BEB,
	          0x9B8E: 0x5BF0,
	          0x9B8F: 0x5BF6,
	          0x9B90: 0x5BF3,
	          0x9B91: 0x5C05,
	          0x9B92: 0x5C07,
	          0x9B93: 0x5C08,
	          0x9B94: 0x5C0D,
	          0x9B95: 0x5C13,
	          0x9B96: 0x5C20,
	          0x9B97: 0x5C22,
	          0x9B98: 0x5C28,
	          0x9B99: 0x5C38,
	          0x9B9A: 0x5C39,
	          0x9B9B: 0x5C41,
	          0x9B9C: 0x5C46,
	          0x9B9D: 0x5C4E,
	          0x9B9E: 0x5C53,
	          0x9B9F: 0x5C50,
	          0x9BA0: 0x5C4F,
	          0x9BA1: 0x5B71,
	          0x9BA2: 0x5C6C,
	          0x9BA3: 0x5C6E,
	          0x9BA4: 0x4E62,
	          0x9BA5: 0x5C76,
	          0x9BA6: 0x5C79,
	          0x9BA7: 0x5C8C,
	          0x9BA8: 0x5C91,
	          0x9BA9: 0x5C94,
	          0x9BAA: 0x599B,
	          0x9BAB: 0x5CAB,
	          0x9BAC: 0x5CBB,
	          0x9BAD: 0x5CB6,
	          0x9BAE: 0x5CBC,
	          0x9BAF: 0x5CB7,
	          0x9BB0: 0x5CC5,
	          0x9BB1: 0x5CBE,
	          0x9BB2: 0x5CC7,
	          0x9BB3: 0x5CD9,
	          0x9BB4: 0x5CE9,
	          0x9BB5: 0x5CFD,
	          0x9BB6: 0x5CFA,
	          0x9BB7: 0x5CED,
	          0x9BB8: 0x5D8C,
	          0x9BB9: 0x5CEA,
	          0x9BBA: 0x5D0B,
	          0x9BBB: 0x5D15,
	          0x9BBC: 0x5D17,
	          0x9BBD: 0x5D5C,
	          0x9BBE: 0x5D1F,
	          0x9BBF: 0x5D1B,
	          0x9BC0: 0x5D11,
	          0x9BC1: 0x5D14,
	          0x9BC2: 0x5D22,
	          0x9BC3: 0x5D1A,
	          0x9BC4: 0x5D19,
	          0x9BC5: 0x5D18,
	          0x9BC6: 0x5D4C,
	          0x9BC7: 0x5D52,
	          0x9BC8: 0x5D4E,
	          0x9BC9: 0x5D4B,
	          0x9BCA: 0x5D6C,
	          0x9BCB: 0x5D73,
	          0x9BCC: 0x5D76,
	          0x9BCD: 0x5D87,
	          0x9BCE: 0x5D84,
	          0x9BCF: 0x5D82,
	          0x9BD0: 0x5DA2,
	          0x9BD1: 0x5D9D,
	          0x9BD2: 0x5DAC,
	          0x9BD3: 0x5DAE,
	          0x9BD4: 0x5DBD,
	          0x9BD5: 0x5D90,
	          0x9BD6: 0x5DB7,
	          0x9BD7: 0x5DBC,
	          0x9BD8: 0x5DC9,
	          0x9BD9: 0x5DCD,
	          0x9BDA: 0x5DD3,
	          0x9BDB: 0x5DD2,
	          0x9BDC: 0x5DD6,
	          0x9BDD: 0x5DDB,
	          0x9BDE: 0x5DEB,
	          0x9BDF: 0x5DF2,
	          0x9BE0: 0x5DF5,
	          0x9BE1: 0x5E0B,
	          0x9BE2: 0x5E1A,
	          0x9BE3: 0x5E19,
	          0x9BE4: 0x5E11,
	          0x9BE5: 0x5E1B,
	          0x9BE6: 0x5E36,
	          0x9BE7: 0x5E37,
	          0x9BE8: 0x5E44,
	          0x9BE9: 0x5E43,
	          0x9BEA: 0x5E40,
	          0x9BEB: 0x5E4E,
	          0x9BEC: 0x5E57,
	          0x9BED: 0x5E54,
	          0x9BEE: 0x5E5F,
	          0x9BEF: 0x5E62,
	          0x9BF0: 0x5E64,
	          0x9BF1: 0x5E47,
	          0x9BF2: 0x5E75,
	          0x9BF3: 0x5E76,
	          0x9BF4: 0x5E7A,
	          0x9BF5: 0x9EBC,
	          0x9BF6: 0x5E7F,
	          0x9BF7: 0x5EA0,
	          0x9BF8: 0x5EC1,
	          0x9BF9: 0x5EC2,
	          0x9BFA: 0x5EC8,
	          0x9BFB: 0x5ED0,
	          0x9BFC: 0x5ECF,
	          0x9C40: 0x5ED6,
	          0x9C41: 0x5EE3,
	          0x9C42: 0x5EDD,
	          0x9C43: 0x5EDA,
	          0x9C44: 0x5EDB,
	          0x9C45: 0x5EE2,
	          0x9C46: 0x5EE1,
	          0x9C47: 0x5EE8,
	          0x9C48: 0x5EE9,
	          0x9C49: 0x5EEC,
	          0x9C4A: 0x5EF1,
	          0x9C4B: 0x5EF3,
	          0x9C4C: 0x5EF0,
	          0x9C4D: 0x5EF4,
	          0x9C4E: 0x5EF8,
	          0x9C4F: 0x5EFE,
	          0x9C50: 0x5F03,
	          0x9C51: 0x5F09,
	          0x9C52: 0x5F5D,
	          0x9C53: 0x5F5C,
	          0x9C54: 0x5F0B,
	          0x9C55: 0x5F11,
	          0x9C56: 0x5F16,
	          0x9C57: 0x5F29,
	          0x9C58: 0x5F2D,
	          0x9C59: 0x5F38,
	          0x9C5A: 0x5F41,
	          0x9C5B: 0x5F48,
	          0x9C5C: 0x5F4C,
	          0x9C5D: 0x5F4E,
	          0x9C5E: 0x5F2F,
	          0x9C5F: 0x5F51,
	          0x9C60: 0x5F56,
	          0x9C61: 0x5F57,
	          0x9C62: 0x5F59,
	          0x9C63: 0x5F61,
	          0x9C64: 0x5F6D,
	          0x9C65: 0x5F73,
	          0x9C66: 0x5F77,
	          0x9C67: 0x5F83,
	          0x9C68: 0x5F82,
	          0x9C69: 0x5F7F,
	          0x9C6A: 0x5F8A,
	          0x9C6B: 0x5F88,
	          0x9C6C: 0x5F91,
	          0x9C6D: 0x5F87,
	          0x9C6E: 0x5F9E,
	          0x9C6F: 0x5F99,
	          0x9C70: 0x5F98,
	          0x9C71: 0x5FA0,
	          0x9C72: 0x5FA8,
	          0x9C73: 0x5FAD,
	          0x9C74: 0x5FBC,
	          0x9C75: 0x5FD6,
	          0x9C76: 0x5FFB,
	          0x9C77: 0x5FE4,
	          0x9C78: 0x5FF8,
	          0x9C79: 0x5FF1,
	          0x9C7A: 0x5FDD,
	          0x9C7B: 0x60B3,
	          0x9C7C: 0x5FFF,
	          0x9C7D: 0x6021,
	          0x9C7E: 0x6060,
	          0x9C80: 0x6019,
	          0x9C81: 0x6010,
	          0x9C82: 0x6029,
	          0x9C83: 0x600E,
	          0x9C84: 0x6031,
	          0x9C85: 0x601B,
	          0x9C86: 0x6015,
	          0x9C87: 0x602B,
	          0x9C88: 0x6026,
	          0x9C89: 0x600F,
	          0x9C8A: 0x603A,
	          0x9C8B: 0x605A,
	          0x9C8C: 0x6041,
	          0x9C8D: 0x606A,
	          0x9C8E: 0x6077,
	          0x9C8F: 0x605F,
	          0x9C90: 0x604A,
	          0x9C91: 0x6046,
	          0x9C92: 0x604D,
	          0x9C93: 0x6063,
	          0x9C94: 0x6043,
	          0x9C95: 0x6064,
	          0x9C96: 0x6042,
	          0x9C97: 0x606C,
	          0x9C98: 0x606B,
	          0x9C99: 0x6059,
	          0x9C9A: 0x6081,
	          0x9C9B: 0x608D,
	          0x9C9C: 0x60E7,
	          0x9C9D: 0x6083,
	          0x9C9E: 0x609A,
	          0x9C9F: 0x6084,
	          0x9CA0: 0x609B,
	          0x9CA1: 0x6096,
	          0x9CA2: 0x6097,
	          0x9CA3: 0x6092,
	          0x9CA4: 0x60A7,
	          0x9CA5: 0x608B,
	          0x9CA6: 0x60E1,
	          0x9CA7: 0x60B8,
	          0x9CA8: 0x60E0,
	          0x9CA9: 0x60D3,
	          0x9CAA: 0x60B4,
	          0x9CAB: 0x5FF0,
	          0x9CAC: 0x60BD,
	          0x9CAD: 0x60C6,
	          0x9CAE: 0x60B5,
	          0x9CAF: 0x60D8,
	          0x9CB0: 0x614D,
	          0x9CB1: 0x6115,
	          0x9CB2: 0x6106,
	          0x9CB3: 0x60F6,
	          0x9CB4: 0x60F7,
	          0x9CB5: 0x6100,
	          0x9CB6: 0x60F4,
	          0x9CB7: 0x60FA,
	          0x9CB8: 0x6103,
	          0x9CB9: 0x6121,
	          0x9CBA: 0x60FB,
	          0x9CBB: 0x60F1,
	          0x9CBC: 0x610D,
	          0x9CBD: 0x610E,
	          0x9CBE: 0x6147,
	          0x9CBF: 0x613E,
	          0x9CC0: 0x6128,
	          0x9CC1: 0x6127,
	          0x9CC2: 0x614A,
	          0x9CC3: 0x613F,
	          0x9CC4: 0x613C,
	          0x9CC5: 0x612C,
	          0x9CC6: 0x6134,
	          0x9CC7: 0x613D,
	          0x9CC8: 0x6142,
	          0x9CC9: 0x6144,
	          0x9CCA: 0x6173,
	          0x9CCB: 0x6177,
	          0x9CCC: 0x6158,
	          0x9CCD: 0x6159,
	          0x9CCE: 0x615A,
	          0x9CCF: 0x616B,
	          0x9CD0: 0x6174,
	          0x9CD1: 0x616F,
	          0x9CD2: 0x6165,
	          0x9CD3: 0x6171,
	          0x9CD4: 0x615F,
	          0x9CD5: 0x615D,
	          0x9CD6: 0x6153,
	          0x9CD7: 0x6175,
	          0x9CD8: 0x6199,
	          0x9CD9: 0x6196,
	          0x9CDA: 0x6187,
	          0x9CDB: 0x61AC,
	          0x9CDC: 0x6194,
	          0x9CDD: 0x619A,
	          0x9CDE: 0x618A,
	          0x9CDF: 0x6191,
	          0x9CE0: 0x61AB,
	          0x9CE1: 0x61AE,
	          0x9CE2: 0x61CC,
	          0x9CE3: 0x61CA,
	          0x9CE4: 0x61C9,
	          0x9CE5: 0x61F7,
	          0x9CE6: 0x61C8,
	          0x9CE7: 0x61C3,
	          0x9CE8: 0x61C6,
	          0x9CE9: 0x61BA,
	          0x9CEA: 0x61CB,
	          0x9CEB: 0x7F79,
	          0x9CEC: 0x61CD,
	          0x9CED: 0x61E6,
	          0x9CEE: 0x61E3,
	          0x9CEF: 0x61F6,
	          0x9CF0: 0x61FA,
	          0x9CF1: 0x61F4,
	          0x9CF2: 0x61FF,
	          0x9CF3: 0x61FD,
	          0x9CF4: 0x61FC,
	          0x9CF5: 0x61FE,
	          0x9CF6: 0x6200,
	          0x9CF7: 0x6208,
	          0x9CF8: 0x6209,
	          0x9CF9: 0x620D,
	          0x9CFA: 0x620C,
	          0x9CFB: 0x6214,
	          0x9CFC: 0x621B,
	          0x9D40: 0x621E,
	          0x9D41: 0x6221,
	          0x9D42: 0x622A,
	          0x9D43: 0x622E,
	          0x9D44: 0x6230,
	          0x9D45: 0x6232,
	          0x9D46: 0x6233,
	          0x9D47: 0x6241,
	          0x9D48: 0x624E,
	          0x9D49: 0x625E,
	          0x9D4A: 0x6263,
	          0x9D4B: 0x625B,
	          0x9D4C: 0x6260,
	          0x9D4D: 0x6268,
	          0x9D4E: 0x627C,
	          0x9D4F: 0x6282,
	          0x9D50: 0x6289,
	          0x9D51: 0x627E,
	          0x9D52: 0x6292,
	          0x9D53: 0x6293,
	          0x9D54: 0x6296,
	          0x9D55: 0x62D4,
	          0x9D56: 0x6283,
	          0x9D57: 0x6294,
	          0x9D58: 0x62D7,
	          0x9D59: 0x62D1,
	          0x9D5A: 0x62BB,
	          0x9D5B: 0x62CF,
	          0x9D5C: 0x62FF,
	          0x9D5D: 0x62C6,
	          0x9D5E: 0x64D4,
	          0x9D5F: 0x62C8,
	          0x9D60: 0x62DC,
	          0x9D61: 0x62CC,
	          0x9D62: 0x62CA,
	          0x9D63: 0x62C2,
	          0x9D64: 0x62C7,
	          0x9D65: 0x629B,
	          0x9D66: 0x62C9,
	          0x9D67: 0x630C,
	          0x9D68: 0x62EE,
	          0x9D69: 0x62F1,
	          0x9D6A: 0x6327,
	          0x9D6B: 0x6302,
	          0x9D6C: 0x6308,
	          0x9D6D: 0x62EF,
	          0x9D6E: 0x62F5,
	          0x9D6F: 0x6350,
	          0x9D70: 0x633E,
	          0x9D71: 0x634D,
	          0x9D72: 0x641C,
	          0x9D73: 0x634F,
	          0x9D74: 0x6396,
	          0x9D75: 0x638E,
	          0x9D76: 0x6380,
	          0x9D77: 0x63AB,
	          0x9D78: 0x6376,
	          0x9D79: 0x63A3,
	          0x9D7A: 0x638F,
	          0x9D7B: 0x6389,
	          0x9D7C: 0x639F,
	          0x9D7D: 0x63B5,
	          0x9D7E: 0x636B,
	          0x9D80: 0x6369,
	          0x9D81: 0x63BE,
	          0x9D82: 0x63E9,
	          0x9D83: 0x63C0,
	          0x9D84: 0x63C6,
	          0x9D85: 0x63E3,
	          0x9D86: 0x63C9,
	          0x9D87: 0x63D2,
	          0x9D88: 0x63F6,
	          0x9D89: 0x63C4,
	          0x9D8A: 0x6416,
	          0x9D8B: 0x6434,
	          0x9D8C: 0x6406,
	          0x9D8D: 0x6413,
	          0x9D8E: 0x6426,
	          0x9D8F: 0x6436,
	          0x9D90: 0x651D,
	          0x9D91: 0x6417,
	          0x9D92: 0x6428,
	          0x9D93: 0x640F,
	          0x9D94: 0x6467,
	          0x9D95: 0x646F,
	          0x9D96: 0x6476,
	          0x9D97: 0x644E,
	          0x9D98: 0x652A,
	          0x9D99: 0x6495,
	          0x9D9A: 0x6493,
	          0x9D9B: 0x64A5,
	          0x9D9C: 0x64A9,
	          0x9D9D: 0x6488,
	          0x9D9E: 0x64BC,
	          0x9D9F: 0x64DA,
	          0x9DA0: 0x64D2,
	          0x9DA1: 0x64C5,
	          0x9DA2: 0x64C7,
	          0x9DA3: 0x64BB,
	          0x9DA4: 0x64D8,
	          0x9DA5: 0x64C2,
	          0x9DA6: 0x64F1,
	          0x9DA7: 0x64E7,
	          0x9DA8: 0x8209,
	          0x9DA9: 0x64E0,
	          0x9DAA: 0x64E1,
	          0x9DAB: 0x62AC,
	          0x9DAC: 0x64E3,
	          0x9DAD: 0x64EF,
	          0x9DAE: 0x652C,
	          0x9DAF: 0x64F6,
	          0x9DB0: 0x64F4,
	          0x9DB1: 0x64F2,
	          0x9DB2: 0x64FA,
	          0x9DB3: 0x6500,
	          0x9DB4: 0x64FD,
	          0x9DB5: 0x6518,
	          0x9DB6: 0x651C,
	          0x9DB7: 0x6505,
	          0x9DB8: 0x6524,
	          0x9DB9: 0x6523,
	          0x9DBA: 0x652B,
	          0x9DBB: 0x6534,
	          0x9DBC: 0x6535,
	          0x9DBD: 0x6537,
	          0x9DBE: 0x6536,
	          0x9DBF: 0x6538,
	          0x9DC0: 0x754B,
	          0x9DC1: 0x6548,
	          0x9DC2: 0x6556,
	          0x9DC3: 0x6555,
	          0x9DC4: 0x654D,
	          0x9DC5: 0x6558,
	          0x9DC6: 0x655E,
	          0x9DC7: 0x655D,
	          0x9DC8: 0x6572,
	          0x9DC9: 0x6578,
	          0x9DCA: 0x6582,
	          0x9DCB: 0x6583,
	          0x9DCC: 0x8B8A,
	          0x9DCD: 0x659B,
	          0x9DCE: 0x659F,
	          0x9DCF: 0x65AB,
	          0x9DD0: 0x65B7,
	          0x9DD1: 0x65C3,
	          0x9DD2: 0x65C6,
	          0x9DD3: 0x65C1,
	          0x9DD4: 0x65C4,
	          0x9DD5: 0x65CC,
	          0x9DD6: 0x65D2,
	          0x9DD7: 0x65DB,
	          0x9DD8: 0x65D9,
	          0x9DD9: 0x65E0,
	          0x9DDA: 0x65E1,
	          0x9DDB: 0x65F1,
	          0x9DDC: 0x6772,
	          0x9DDD: 0x660A,
	          0x9DDE: 0x6603,
	          0x9DDF: 0x65FB,
	          0x9DE0: 0x6773,
	          0x9DE1: 0x6635,
	          0x9DE2: 0x6636,
	          0x9DE3: 0x6634,
	          0x9DE4: 0x661C,
	          0x9DE5: 0x664F,
	          0x9DE6: 0x6644,
	          0x9DE7: 0x6649,
	          0x9DE8: 0x6641,
	          0x9DE9: 0x665E,
	          0x9DEA: 0x665D,
	          0x9DEB: 0x6664,
	          0x9DEC: 0x6667,
	          0x9DED: 0x6668,
	          0x9DEE: 0x665F,
	          0x9DEF: 0x6662,
	          0x9DF0: 0x6670,
	          0x9DF1: 0x6683,
	          0x9DF2: 0x6688,
	          0x9DF3: 0x668E,
	          0x9DF4: 0x6689,
	          0x9DF5: 0x6684,
	          0x9DF6: 0x6698,
	          0x9DF7: 0x669D,
	          0x9DF8: 0x66C1,
	          0x9DF9: 0x66B9,
	          0x9DFA: 0x66C9,
	          0x9DFB: 0x66BE,
	          0x9DFC: 0x66BC,
	          0x9E40: 0x66C4,
	          0x9E41: 0x66B8,
	          0x9E42: 0x66D6,
	          0x9E43: 0x66DA,
	          0x9E44: 0x66E0,
	          0x9E45: 0x663F,
	          0x9E46: 0x66E6,
	          0x9E47: 0x66E9,
	          0x9E48: 0x66F0,
	          0x9E49: 0x66F5,
	          0x9E4A: 0x66F7,
	          0x9E4B: 0x670F,
	          0x9E4C: 0x6716,
	          0x9E4D: 0x671E,
	          0x9E4E: 0x6726,
	          0x9E4F: 0x6727,
	          0x9E50: 0x9738,
	          0x9E51: 0x672E,
	          0x9E52: 0x673F,
	          0x9E53: 0x6736,
	          0x9E54: 0x6741,
	          0x9E55: 0x6738,
	          0x9E56: 0x6737,
	          0x9E57: 0x6746,
	          0x9E58: 0x675E,
	          0x9E59: 0x6760,
	          0x9E5A: 0x6759,
	          0x9E5B: 0x6763,
	          0x9E5C: 0x6764,
	          0x9E5D: 0x6789,
	          0x9E5E: 0x6770,
	          0x9E5F: 0x67A9,
	          0x9E60: 0x677C,
	          0x9E61: 0x676A,
	          0x9E62: 0x678C,
	          0x9E63: 0x678B,
	          0x9E64: 0x67A6,
	          0x9E65: 0x67A1,
	          0x9E66: 0x6785,
	          0x9E67: 0x67B7,
	          0x9E68: 0x67EF,
	          0x9E69: 0x67B4,
	          0x9E6A: 0x67EC,
	          0x9E6B: 0x67B3,
	          0x9E6C: 0x67E9,
	          0x9E6D: 0x67B8,
	          0x9E6E: 0x67E4,
	          0x9E6F: 0x67DE,
	          0x9E70: 0x67DD,
	          0x9E71: 0x67E2,
	          0x9E72: 0x67EE,
	          0x9E73: 0x67B9,
	          0x9E74: 0x67CE,
	          0x9E75: 0x67C6,
	          0x9E76: 0x67E7,
	          0x9E77: 0x6A9C,
	          0x9E78: 0x681E,
	          0x9E79: 0x6846,
	          0x9E7A: 0x6829,
	          0x9E7B: 0x6840,
	          0x9E7C: 0x684D,
	          0x9E7D: 0x6832,
	          0x9E7E: 0x684E,
	          0x9E80: 0x68B3,
	          0x9E81: 0x682B,
	          0x9E82: 0x6859,
	          0x9E83: 0x6863,
	          0x9E84: 0x6877,
	          0x9E85: 0x687F,
	          0x9E86: 0x689F,
	          0x9E87: 0x688F,
	          0x9E88: 0x68AD,
	          0x9E89: 0x6894,
	          0x9E8A: 0x689D,
	          0x9E8B: 0x689B,
	          0x9E8C: 0x6883,
	          0x9E8D: 0x6AAE,
	          0x9E8E: 0x68B9,
	          0x9E8F: 0x6874,
	          0x9E90: 0x68B5,
	          0x9E91: 0x68A0,
	          0x9E92: 0x68BA,
	          0x9E93: 0x690F,
	          0x9E94: 0x688D,
	          0x9E95: 0x687E,
	          0x9E96: 0x6901,
	          0x9E97: 0x68CA,
	          0x9E98: 0x6908,
	          0x9E99: 0x68D8,
	          0x9E9A: 0x6922,
	          0x9E9B: 0x6926,
	          0x9E9C: 0x68E1,
	          0x9E9D: 0x690C,
	          0x9E9E: 0x68CD,
	          0x9E9F: 0x68D4,
	          0x9EA0: 0x68E7,
	          0x9EA1: 0x68D5,
	          0x9EA2: 0x6936,
	          0x9EA3: 0x6912,
	          0x9EA4: 0x6904,
	          0x9EA5: 0x68D7,
	          0x9EA6: 0x68E3,
	          0x9EA7: 0x6925,
	          0x9EA8: 0x68F9,
	          0x9EA9: 0x68E0,
	          0x9EAA: 0x68EF,
	          0x9EAB: 0x6928,
	          0x9EAC: 0x692A,
	          0x9EAD: 0x691A,
	          0x9EAE: 0x6923,
	          0x9EAF: 0x6921,
	          0x9EB0: 0x68C6,
	          0x9EB1: 0x6979,
	          0x9EB2: 0x6977,
	          0x9EB3: 0x695C,
	          0x9EB4: 0x6978,
	          0x9EB5: 0x696B,
	          0x9EB6: 0x6954,
	          0x9EB7: 0x697E,
	          0x9EB8: 0x696E,
	          0x9EB9: 0x6939,
	          0x9EBA: 0x6974,
	          0x9EBB: 0x693D,
	          0x9EBC: 0x6959,
	          0x9EBD: 0x6930,
	          0x9EBE: 0x6961,
	          0x9EBF: 0x695E,
	          0x9EC0: 0x695D,
	          0x9EC1: 0x6981,
	          0x9EC2: 0x696A,
	          0x9EC3: 0x69B2,
	          0x9EC4: 0x69AE,
	          0x9EC5: 0x69D0,
	          0x9EC6: 0x69BF,
	          0x9EC7: 0x69C1,
	          0x9EC8: 0x69D3,
	          0x9EC9: 0x69BE,
	          0x9ECA: 0x69CE,
	          0x9ECB: 0x5BE8,
	          0x9ECC: 0x69CA,
	          0x9ECD: 0x69DD,
	          0x9ECE: 0x69BB,
	          0x9ECF: 0x69C3,
	          0x9ED0: 0x69A7,
	          0x9ED1: 0x6A2E,
	          0x9ED2: 0x6991,
	          0x9ED3: 0x69A0,
	          0x9ED4: 0x699C,
	          0x9ED5: 0x6995,
	          0x9ED6: 0x69B4,
	          0x9ED7: 0x69DE,
	          0x9ED8: 0x69E8,
	          0x9ED9: 0x6A02,
	          0x9EDA: 0x6A1B,
	          0x9EDB: 0x69FF,
	          0x9EDC: 0x6B0A,
	          0x9EDD: 0x69F9,
	          0x9EDE: 0x69F2,
	          0x9EDF: 0x69E7,
	          0x9EE0: 0x6A05,
	          0x9EE1: 0x69B1,
	          0x9EE2: 0x6A1E,
	          0x9EE3: 0x69ED,
	          0x9EE4: 0x6A14,
	          0x9EE5: 0x69EB,
	          0x9EE6: 0x6A0A,
	          0x9EE7: 0x6A12,
	          0x9EE8: 0x6AC1,
	          0x9EE9: 0x6A23,
	          0x9EEA: 0x6A13,
	          0x9EEB: 0x6A44,
	          0x9EEC: 0x6A0C,
	          0x9EED: 0x6A72,
	          0x9EEE: 0x6A36,
	          0x9EEF: 0x6A78,
	          0x9EF0: 0x6A47,
	          0x9EF1: 0x6A62,
	          0x9EF2: 0x6A59,
	          0x9EF3: 0x6A66,
	          0x9EF4: 0x6A48,
	          0x9EF5: 0x6A38,
	          0x9EF6: 0x6A22,
	          0x9EF7: 0x6A90,
	          0x9EF8: 0x6A8D,
	          0x9EF9: 0x6AA0,
	          0x9EFA: 0x6A84,
	          0x9EFB: 0x6AA2,
	          0x9EFC: 0x6AA3,
	          0x9F40: 0x6A97,
	          0x9F41: 0x8617,
	          0x9F42: 0x6ABB,
	          0x9F43: 0x6AC3,
	          0x9F44: 0x6AC2,
	          0x9F45: 0x6AB8,
	          0x9F46: 0x6AB3,
	          0x9F47: 0x6AAC,
	          0x9F48: 0x6ADE,
	          0x9F49: 0x6AD1,
	          0x9F4A: 0x6ADF,
	          0x9F4B: 0x6AAA,
	          0x9F4C: 0x6ADA,
	          0x9F4D: 0x6AEA,
	          0x9F4E: 0x6AFB,
	          0x9F4F: 0x6B05,
	          0x9F50: 0x8616,
	          0x9F51: 0x6AFA,
	          0x9F52: 0x6B12,
	          0x9F53: 0x6B16,
	          0x9F54: 0x9B31,
	          0x9F55: 0x6B1F,
	          0x9F56: 0x6B38,
	          0x9F57: 0x6B37,
	          0x9F58: 0x76DC,
	          0x9F59: 0x6B39,
	          0x9F5A: 0x98EE,
	          0x9F5B: 0x6B47,
	          0x9F5C: 0x6B43,
	          0x9F5D: 0x6B49,
	          0x9F5E: 0x6B50,
	          0x9F5F: 0x6B59,
	          0x9F60: 0x6B54,
	          0x9F61: 0x6B5B,
	          0x9F62: 0x6B5F,
	          0x9F63: 0x6B61,
	          0x9F64: 0x6B78,
	          0x9F65: 0x6B79,
	          0x9F66: 0x6B7F,
	          0x9F67: 0x6B80,
	          0x9F68: 0x6B84,
	          0x9F69: 0x6B83,
	          0x9F6A: 0x6B8D,
	          0x9F6B: 0x6B98,
	          0x9F6C: 0x6B95,
	          0x9F6D: 0x6B9E,
	          0x9F6E: 0x6BA4,
	          0x9F6F: 0x6BAA,
	          0x9F70: 0x6BAB,
	          0x9F71: 0x6BAF,
	          0x9F72: 0x6BB2,
	          0x9F73: 0x6BB1,
	          0x9F74: 0x6BB3,
	          0x9F75: 0x6BB7,
	          0x9F76: 0x6BBC,
	          0x9F77: 0x6BC6,
	          0x9F78: 0x6BCB,
	          0x9F79: 0x6BD3,
	          0x9F7A: 0x6BDF,
	          0x9F7B: 0x6BEC,
	          0x9F7C: 0x6BEB,
	          0x9F7D: 0x6BF3,
	          0x9F7E: 0x6BEF,
	          0x9F80: 0x9EBE,
	          0x9F81: 0x6C08,
	          0x9F82: 0x6C13,
	          0x9F83: 0x6C14,
	          0x9F84: 0x6C1B,
	          0x9F85: 0x6C24,
	          0x9F86: 0x6C23,
	          0x9F87: 0x6C5E,
	          0x9F88: 0x6C55,
	          0x9F89: 0x6C62,
	          0x9F8A: 0x6C6A,
	          0x9F8B: 0x6C82,
	          0x9F8C: 0x6C8D,
	          0x9F8D: 0x6C9A,
	          0x9F8E: 0x6C81,
	          0x9F8F: 0x6C9B,
	          0x9F90: 0x6C7E,
	          0x9F91: 0x6C68,
	          0x9F92: 0x6C73,
	          0x9F93: 0x6C92,
	          0x9F94: 0x6C90,
	          0x9F95: 0x6CC4,
	          0x9F96: 0x6CF1,
	          0x9F97: 0x6CD3,
	          0x9F98: 0x6CBD,
	          0x9F99: 0x6CD7,
	          0x9F9A: 0x6CC5,
	          0x9F9B: 0x6CDD,
	          0x9F9C: 0x6CAE,
	          0x9F9D: 0x6CB1,
	          0x9F9E: 0x6CBE,
	          0x9F9F: 0x6CBA,
	          0x9FA0: 0x6CDB,
	          0x9FA1: 0x6CEF,
	          0x9FA2: 0x6CD9,
	          0x9FA3: 0x6CEA,
	          0x9FA4: 0x6D1F,
	          0x9FA5: 0x884D,
	          0x9FA6: 0x6D36,
	          0x9FA7: 0x6D2B,
	          0x9FA8: 0x6D3D,
	          0x9FA9: 0x6D38,
	          0x9FAA: 0x6D19,
	          0x9FAB: 0x6D35,
	          0x9FAC: 0x6D33,
	          0x9FAD: 0x6D12,
	          0x9FAE: 0x6D0C,
	          0x9FAF: 0x6D63,
	          0x9FB0: 0x6D93,
	          0x9FB1: 0x6D64,
	          0x9FB2: 0x6D5A,
	          0x9FB3: 0x6D79,
	          0x9FB4: 0x6D59,
	          0x9FB5: 0x6D8E,
	          0x9FB6: 0x6D95,
	          0x9FB7: 0x6FE4,
	          0x9FB8: 0x6D85,
	          0x9FB9: 0x6DF9,
	          0x9FBA: 0x6E15,
	          0x9FBB: 0x6E0A,
	          0x9FBC: 0x6DB5,
	          0x9FBD: 0x6DC7,
	          0x9FBE: 0x6DE6,
	          0x9FBF: 0x6DB8,
	          0x9FC0: 0x6DC6,
	          0x9FC1: 0x6DEC,
	          0x9FC2: 0x6DDE,
	          0x9FC3: 0x6DCC,
	          0x9FC4: 0x6DE8,
	          0x9FC5: 0x6DD2,
	          0x9FC6: 0x6DC5,
	          0x9FC7: 0x6DFA,
	          0x9FC8: 0x6DD9,
	          0x9FC9: 0x6DE4,
	          0x9FCA: 0x6DD5,
	          0x9FCB: 0x6DEA,
	          0x9FCC: 0x6DEE,
	          0x9FCD: 0x6E2D,
	          0x9FCE: 0x6E6E,
	          0x9FCF: 0x6E2E,
	          0x9FD0: 0x6E19,
	          0x9FD1: 0x6E72,
	          0x9FD2: 0x6E5F,
	          0x9FD3: 0x6E3E,
	          0x9FD4: 0x6E23,
	          0x9FD5: 0x6E6B,
	          0x9FD6: 0x6E2B,
	          0x9FD7: 0x6E76,
	          0x9FD8: 0x6E4D,
	          0x9FD9: 0x6E1F,
	          0x9FDA: 0x6E43,
	          0x9FDB: 0x6E3A,
	          0x9FDC: 0x6E4E,
	          0x9FDD: 0x6E24,
	          0x9FDE: 0x6EFF,
	          0x9FDF: 0x6E1D,
	          0x9FE0: 0x6E38,
	          0x9FE1: 0x6E82,
	          0x9FE2: 0x6EAA,
	          0x9FE3: 0x6E98,
	          0x9FE4: 0x6EC9,
	          0x9FE5: 0x6EB7,
	          0x9FE6: 0x6ED3,
	          0x9FE7: 0x6EBD,
	          0x9FE8: 0x6EAF,
	          0x9FE9: 0x6EC4,
	          0x9FEA: 0x6EB2,
	          0x9FEB: 0x6ED4,
	          0x9FEC: 0x6ED5,
	          0x9FED: 0x6E8F,
	          0x9FEE: 0x6EA5,
	          0x9FEF: 0x6EC2,
	          0x9FF0: 0x6E9F,
	          0x9FF1: 0x6F41,
	          0x9FF2: 0x6F11,
	          0x9FF3: 0x704C,
	          0x9FF4: 0x6EEC,
	          0x9FF5: 0x6EF8,
	          0x9FF6: 0x6EFE,
	          0x9FF7: 0x6F3F,
	          0x9FF8: 0x6EF2,
	          0x9FF9: 0x6F31,
	          0x9FFA: 0x6EEF,
	          0x9FFB: 0x6F32,
	          0x9FFC: 0x6ECC,
	          0xA1: 0xFF61,
	          0xA2: 0xFF62,
	          0xA3: 0xFF63,
	          0xA4: 0xFF64,
	          0xA5: 0xFF65,
	          0xA6: 0xFF66,
	          0xA7: 0xFF67,
	          0xA8: 0xFF68,
	          0xA9: 0xFF69,
	          0xAA: 0xFF6A,
	          0xAB: 0xFF6B,
	          0xAC: 0xFF6C,
	          0xAD: 0xFF6D,
	          0xAE: 0xFF6E,
	          0xAF: 0xFF6F,
	          0xB0: 0xFF70,
	          0xB1: 0xFF71,
	          0xB2: 0xFF72,
	          0xB3: 0xFF73,
	          0xB4: 0xFF74,
	          0xB5: 0xFF75,
	          0xB6: 0xFF76,
	          0xB7: 0xFF77,
	          0xB8: 0xFF78,
	          0xB9: 0xFF79,
	          0xBA: 0xFF7A,
	          0xBB: 0xFF7B,
	          0xBC: 0xFF7C,
	          0xBD: 0xFF7D,
	          0xBE: 0xFF7E,
	          0xBF: 0xFF7F,
	          0xC0: 0xFF80,
	          0xC1: 0xFF81,
	          0xC2: 0xFF82,
	          0xC3: 0xFF83,
	          0xC4: 0xFF84,
	          0xC5: 0xFF85,
	          0xC6: 0xFF86,
	          0xC7: 0xFF87,
	          0xC8: 0xFF88,
	          0xC9: 0xFF89,
	          0xCA: 0xFF8A,
	          0xCB: 0xFF8B,
	          0xCC: 0xFF8C,
	          0xCD: 0xFF8D,
	          0xCE: 0xFF8E,
	          0xCF: 0xFF8F,
	          0xD0: 0xFF90,
	          0xD1: 0xFF91,
	          0xD2: 0xFF92,
	          0xD3: 0xFF93,
	          0xD4: 0xFF94,
	          0xD5: 0xFF95,
	          0xD6: 0xFF96,
	          0xD7: 0xFF97,
	          0xD8: 0xFF98,
	          0xD9: 0xFF99,
	          0xDA: 0xFF9A,
	          0xDB: 0xFF9B,
	          0xDC: 0xFF9C,
	          0xDD: 0xFF9D,
	          0xDE: 0xFF9E,
	          0xDF: 0xFF9F,
	          0xE040: 0x6F3E,
	          0xE041: 0x6F13,
	          0xE042: 0x6EF7,
	          0xE043: 0x6F86,
	          0xE044: 0x6F7A,
	          0xE045: 0x6F78,
	          0xE046: 0x6F81,
	          0xE047: 0x6F80,
	          0xE048: 0x6F6F,
	          0xE049: 0x6F5B,
	          0xE04A: 0x6FF3,
	          0xE04B: 0x6F6D,
	          0xE04C: 0x6F82,
	          0xE04D: 0x6F7C,
	          0xE04E: 0x6F58,
	          0xE04F: 0x6F8E,
	          0xE050: 0x6F91,
	          0xE051: 0x6FC2,
	          0xE052: 0x6F66,
	          0xE053: 0x6FB3,
	          0xE054: 0x6FA3,
	          0xE055: 0x6FA1,
	          0xE056: 0x6FA4,
	          0xE057: 0x6FB9,
	          0xE058: 0x6FC6,
	          0xE059: 0x6FAA,
	          0xE05A: 0x6FDF,
	          0xE05B: 0x6FD5,
	          0xE05C: 0x6FEC,
	          0xE05D: 0x6FD4,
	          0xE05E: 0x6FD8,
	          0xE05F: 0x6FF1,
	          0xE060: 0x6FEE,
	          0xE061: 0x6FDB,
	          0xE062: 0x7009,
	          0xE063: 0x700B,
	          0xE064: 0x6FFA,
	          0xE065: 0x7011,
	          0xE066: 0x7001,
	          0xE067: 0x700F,
	          0xE068: 0x6FFE,
	          0xE069: 0x701B,
	          0xE06A: 0x701A,
	          0xE06B: 0x6F74,
	          0xE06C: 0x701D,
	          0xE06D: 0x7018,
	          0xE06E: 0x701F,
	          0xE06F: 0x7030,
	          0xE070: 0x703E,
	          0xE071: 0x7032,
	          0xE072: 0x7051,
	          0xE073: 0x7063,
	          0xE074: 0x7099,
	          0xE075: 0x7092,
	          0xE076: 0x70AF,
	          0xE077: 0x70F1,
	          0xE078: 0x70AC,
	          0xE079: 0x70B8,
	          0xE07A: 0x70B3,
	          0xE07B: 0x70AE,
	          0xE07C: 0x70DF,
	          0xE07D: 0x70CB,
	          0xE07E: 0x70DD,
	          0xE080: 0x70D9,
	          0xE081: 0x7109,
	          0xE082: 0x70FD,
	          0xE083: 0x711C,
	          0xE084: 0x7119,
	          0xE085: 0x7165,
	          0xE086: 0x7155,
	          0xE087: 0x7188,
	          0xE088: 0x7166,
	          0xE089: 0x7162,
	          0xE08A: 0x714C,
	          0xE08B: 0x7156,
	          0xE08C: 0x716C,
	          0xE08D: 0x718F,
	          0xE08E: 0x71FB,
	          0xE08F: 0x7184,
	          0xE090: 0x7195,
	          0xE091: 0x71A8,
	          0xE092: 0x71AC,
	          0xE093: 0x71D7,
	          0xE094: 0x71B9,
	          0xE095: 0x71BE,
	          0xE096: 0x71D2,
	          0xE097: 0x71C9,
	          0xE098: 0x71D4,
	          0xE099: 0x71CE,
	          0xE09A: 0x71E0,
	          0xE09B: 0x71EC,
	          0xE09C: 0x71E7,
	          0xE09D: 0x71F5,
	          0xE09E: 0x71FC,
	          0xE09F: 0x71F9,
	          0xE0A0: 0x71FF,
	          0xE0A1: 0x720D,
	          0xE0A2: 0x7210,
	          0xE0A3: 0x721B,
	          0xE0A4: 0x7228,
	          0xE0A5: 0x722D,
	          0xE0A6: 0x722C,
	          0xE0A7: 0x7230,
	          0xE0A8: 0x7232,
	          0xE0A9: 0x723B,
	          0xE0AA: 0x723C,
	          0xE0AB: 0x723F,
	          0xE0AC: 0x7240,
	          0xE0AD: 0x7246,
	          0xE0AE: 0x724B,
	          0xE0AF: 0x7258,
	          0xE0B0: 0x7274,
	          0xE0B1: 0x727E,
	          0xE0B2: 0x7282,
	          0xE0B3: 0x7281,
	          0xE0B4: 0x7287,
	          0xE0B5: 0x7292,
	          0xE0B6: 0x7296,
	          0xE0B7: 0x72A2,
	          0xE0B8: 0x72A7,
	          0xE0B9: 0x72B9,
	          0xE0BA: 0x72B2,
	          0xE0BB: 0x72C3,
	          0xE0BC: 0x72C6,
	          0xE0BD: 0x72C4,
	          0xE0BE: 0x72CE,
	          0xE0BF: 0x72D2,
	          0xE0C0: 0x72E2,
	          0xE0C1: 0x72E0,
	          0xE0C2: 0x72E1,
	          0xE0C3: 0x72F9,
	          0xE0C4: 0x72F7,
	          0xE0C5: 0x500F,
	          0xE0C6: 0x7317,
	          0xE0C7: 0x730A,
	          0xE0C8: 0x731C,
	          0xE0C9: 0x7316,
	          0xE0CA: 0x731D,
	          0xE0CB: 0x7334,
	          0xE0CC: 0x732F,
	          0xE0CD: 0x7329,
	          0xE0CE: 0x7325,
	          0xE0CF: 0x733E,
	          0xE0D0: 0x734E,
	          0xE0D1: 0x734F,
	          0xE0D2: 0x9ED8,
	          0xE0D3: 0x7357,
	          0xE0D4: 0x736A,
	          0xE0D5: 0x7368,
	          0xE0D6: 0x7370,
	          0xE0D7: 0x7378,
	          0xE0D8: 0x7375,
	          0xE0D9: 0x737B,
	          0xE0DA: 0x737A,
	          0xE0DB: 0x73C8,
	          0xE0DC: 0x73B3,
	          0xE0DD: 0x73CE,
	          0xE0DE: 0x73BB,
	          0xE0DF: 0x73C0,
	          0xE0E0: 0x73E5,
	          0xE0E1: 0x73EE,
	          0xE0E2: 0x73DE,
	          0xE0E3: 0x74A2,
	          0xE0E4: 0x7405,
	          0xE0E5: 0x746F,
	          0xE0E6: 0x7425,
	          0xE0E7: 0x73F8,
	          0xE0E8: 0x7432,
	          0xE0E9: 0x743A,
	          0xE0EA: 0x7455,
	          0xE0EB: 0x743F,
	          0xE0EC: 0x745F,
	          0xE0ED: 0x7459,
	          0xE0EE: 0x7441,
	          0xE0EF: 0x745C,
	          0xE0F0: 0x7469,
	          0xE0F1: 0x7470,
	          0xE0F2: 0x7463,
	          0xE0F3: 0x746A,
	          0xE0F4: 0x7476,
	          0xE0F5: 0x747E,
	          0xE0F6: 0x748B,
	          0xE0F7: 0x749E,
	          0xE0F8: 0x74A7,
	          0xE0F9: 0x74CA,
	          0xE0FA: 0x74CF,
	          0xE0FB: 0x74D4,
	          0xE0FC: 0x73F1,
	          0xE140: 0x74E0,
	          0xE141: 0x74E3,
	          0xE142: 0x74E7,
	          0xE143: 0x74E9,
	          0xE144: 0x74EE,
	          0xE145: 0x74F2,
	          0xE146: 0x74F0,
	          0xE147: 0x74F1,
	          0xE148: 0x74F8,
	          0xE149: 0x74F7,
	          0xE14A: 0x7504,
	          0xE14B: 0x7503,
	          0xE14C: 0x7505,
	          0xE14D: 0x750C,
	          0xE14E: 0x750E,
	          0xE14F: 0x750D,
	          0xE150: 0x7515,
	          0xE151: 0x7513,
	          0xE152: 0x751E,
	          0xE153: 0x7526,
	          0xE154: 0x752C,
	          0xE155: 0x753C,
	          0xE156: 0x7544,
	          0xE157: 0x754D,
	          0xE158: 0x754A,
	          0xE159: 0x7549,
	          0xE15A: 0x755B,
	          0xE15B: 0x7546,
	          0xE15C: 0x755A,
	          0xE15D: 0x7569,
	          0xE15E: 0x7564,
	          0xE15F: 0x7567,
	          0xE160: 0x756B,
	          0xE161: 0x756D,
	          0xE162: 0x7578,
	          0xE163: 0x7576,
	          0xE164: 0x7586,
	          0xE165: 0x7587,
	          0xE166: 0x7574,
	          0xE167: 0x758A,
	          0xE168: 0x7589,
	          0xE169: 0x7582,
	          0xE16A: 0x7594,
	          0xE16B: 0x759A,
	          0xE16C: 0x759D,
	          0xE16D: 0x75A5,
	          0xE16E: 0x75A3,
	          0xE16F: 0x75C2,
	          0xE170: 0x75B3,
	          0xE171: 0x75C3,
	          0xE172: 0x75B5,
	          0xE173: 0x75BD,
	          0xE174: 0x75B8,
	          0xE175: 0x75BC,
	          0xE176: 0x75B1,
	          0xE177: 0x75CD,
	          0xE178: 0x75CA,
	          0xE179: 0x75D2,
	          0xE17A: 0x75D9,
	          0xE17B: 0x75E3,
	          0xE17C: 0x75DE,
	          0xE17D: 0x75FE,
	          0xE17E: 0x75FF,
	          0xE180: 0x75FC,
	          0xE181: 0x7601,
	          0xE182: 0x75F0,
	          0xE183: 0x75FA,
	          0xE184: 0x75F2,
	          0xE185: 0x75F3,
	          0xE186: 0x760B,
	          0xE187: 0x760D,
	          0xE188: 0x7609,
	          0xE189: 0x761F,
	          0xE18A: 0x7627,
	          0xE18B: 0x7620,
	          0xE18C: 0x7621,
	          0xE18D: 0x7622,
	          0xE18E: 0x7624,
	          0xE18F: 0x7634,
	          0xE190: 0x7630,
	          0xE191: 0x763B,
	          0xE192: 0x7647,
	          0xE193: 0x7648,
	          0xE194: 0x7646,
	          0xE195: 0x765C,
	          0xE196: 0x7658,
	          0xE197: 0x7661,
	          0xE198: 0x7662,
	          0xE199: 0x7668,
	          0xE19A: 0x7669,
	          0xE19B: 0x766A,
	          0xE19C: 0x7667,
	          0xE19D: 0x766C,
	          0xE19E: 0x7670,
	          0xE19F: 0x7672,
	          0xE1A0: 0x7676,
	          0xE1A1: 0x7678,
	          0xE1A2: 0x767C,
	          0xE1A3: 0x7680,
	          0xE1A4: 0x7683,
	          0xE1A5: 0x7688,
	          0xE1A6: 0x768B,
	          0xE1A7: 0x768E,
	          0xE1A8: 0x7696,
	          0xE1A9: 0x7693,
	          0xE1AA: 0x7699,
	          0xE1AB: 0x769A,
	          0xE1AC: 0x76B0,
	          0xE1AD: 0x76B4,
	          0xE1AE: 0x76B8,
	          0xE1AF: 0x76B9,
	          0xE1B0: 0x76BA,
	          0xE1B1: 0x76C2,
	          0xE1B2: 0x76CD,
	          0xE1B3: 0x76D6,
	          0xE1B4: 0x76D2,
	          0xE1B5: 0x76DE,
	          0xE1B6: 0x76E1,
	          0xE1B7: 0x76E5,
	          0xE1B8: 0x76E7,
	          0xE1B9: 0x76EA,
	          0xE1BA: 0x862F,
	          0xE1BB: 0x76FB,
	          0xE1BC: 0x7708,
	          0xE1BD: 0x7707,
	          0xE1BE: 0x7704,
	          0xE1BF: 0x7729,
	          0xE1C0: 0x7724,
	          0xE1C1: 0x771E,
	          0xE1C2: 0x7725,
	          0xE1C3: 0x7726,
	          0xE1C4: 0x771B,
	          0xE1C5: 0x7737,
	          0xE1C6: 0x7738,
	          0xE1C7: 0x7747,
	          0xE1C8: 0x775A,
	          0xE1C9: 0x7768,
	          0xE1CA: 0x776B,
	          0xE1CB: 0x775B,
	          0xE1CC: 0x7765,
	          0xE1CD: 0x777F,
	          0xE1CE: 0x777E,
	          0xE1CF: 0x7779,
	          0xE1D0: 0x778E,
	          0xE1D1: 0x778B,
	          0xE1D2: 0x7791,
	          0xE1D3: 0x77A0,
	          0xE1D4: 0x779E,
	          0xE1D5: 0x77B0,
	          0xE1D6: 0x77B6,
	          0xE1D7: 0x77B9,
	          0xE1D8: 0x77BF,
	          0xE1D9: 0x77BC,
	          0xE1DA: 0x77BD,
	          0xE1DB: 0x77BB,
	          0xE1DC: 0x77C7,
	          0xE1DD: 0x77CD,
	          0xE1DE: 0x77D7,
	          0xE1DF: 0x77DA,
	          0xE1E0: 0x77DC,
	          0xE1E1: 0x77E3,
	          0xE1E2: 0x77EE,
	          0xE1E3: 0x77FC,
	          0xE1E4: 0x780C,
	          0xE1E5: 0x7812,
	          0xE1E6: 0x7926,
	          0xE1E7: 0x7820,
	          0xE1E8: 0x792A,
	          0xE1E9: 0x7845,
	          0xE1EA: 0x788E,
	          0xE1EB: 0x7874,
	          0xE1EC: 0x7886,
	          0xE1ED: 0x787C,
	          0xE1EE: 0x789A,
	          0xE1EF: 0x788C,
	          0xE1F0: 0x78A3,
	          0xE1F1: 0x78B5,
	          0xE1F2: 0x78AA,
	          0xE1F3: 0x78AF,
	          0xE1F4: 0x78D1,
	          0xE1F5: 0x78C6,
	          0xE1F6: 0x78CB,
	          0xE1F7: 0x78D4,
	          0xE1F8: 0x78BE,
	          0xE1F9: 0x78BC,
	          0xE1FA: 0x78C5,
	          0xE1FB: 0x78CA,
	          0xE1FC: 0x78EC,
	          0xE240: 0x78E7,
	          0xE241: 0x78DA,
	          0xE242: 0x78FD,
	          0xE243: 0x78F4,
	          0xE244: 0x7907,
	          0xE245: 0x7912,
	          0xE246: 0x7911,
	          0xE247: 0x7919,
	          0xE248: 0x792C,
	          0xE249: 0x792B,
	          0xE24A: 0x7940,
	          0xE24B: 0x7960,
	          0xE24C: 0x7957,
	          0xE24D: 0x795F,
	          0xE24E: 0x795A,
	          0xE24F: 0x7955,
	          0xE250: 0x7953,
	          0xE251: 0x797A,
	          0xE252: 0x797F,
	          0xE253: 0x798A,
	          0xE254: 0x799D,
	          0xE255: 0x79A7,
	          0xE256: 0x9F4B,
	          0xE257: 0x79AA,
	          0xE258: 0x79AE,
	          0xE259: 0x79B3,
	          0xE25A: 0x79B9,
	          0xE25B: 0x79BA,
	          0xE25C: 0x79C9,
	          0xE25D: 0x79D5,
	          0xE25E: 0x79E7,
	          0xE25F: 0x79EC,
	          0xE260: 0x79E1,
	          0xE261: 0x79E3,
	          0xE262: 0x7A08,
	          0xE263: 0x7A0D,
	          0xE264: 0x7A18,
	          0xE265: 0x7A19,
	          0xE266: 0x7A20,
	          0xE267: 0x7A1F,
	          0xE268: 0x7980,
	          0xE269: 0x7A31,
	          0xE26A: 0x7A3B,
	          0xE26B: 0x7A3E,
	          0xE26C: 0x7A37,
	          0xE26D: 0x7A43,
	          0xE26E: 0x7A57,
	          0xE26F: 0x7A49,
	          0xE270: 0x7A61,
	          0xE271: 0x7A62,
	          0xE272: 0x7A69,
	          0xE273: 0x9F9D,
	          0xE274: 0x7A70,
	          0xE275: 0x7A79,
	          0xE276: 0x7A7D,
	          0xE277: 0x7A88,
	          0xE278: 0x7A97,
	          0xE279: 0x7A95,
	          0xE27A: 0x7A98,
	          0xE27B: 0x7A96,
	          0xE27C: 0x7AA9,
	          0xE27D: 0x7AC8,
	          0xE27E: 0x7AB0,
	          0xE280: 0x7AB6,
	          0xE281: 0x7AC5,
	          0xE282: 0x7AC4,
	          0xE283: 0x7ABF,
	          0xE284: 0x9083,
	          0xE285: 0x7AC7,
	          0xE286: 0x7ACA,
	          0xE287: 0x7ACD,
	          0xE288: 0x7ACF,
	          0xE289: 0x7AD5,
	          0xE28A: 0x7AD3,
	          0xE28B: 0x7AD9,
	          0xE28C: 0x7ADA,
	          0xE28D: 0x7ADD,
	          0xE28E: 0x7AE1,
	          0xE28F: 0x7AE2,
	          0xE290: 0x7AE6,
	          0xE291: 0x7AED,
	          0xE292: 0x7AF0,
	          0xE293: 0x7B02,
	          0xE294: 0x7B0F,
	          0xE295: 0x7B0A,
	          0xE296: 0x7B06,
	          0xE297: 0x7B33,
	          0xE298: 0x7B18,
	          0xE299: 0x7B19,
	          0xE29A: 0x7B1E,
	          0xE29B: 0x7B35,
	          0xE29C: 0x7B28,
	          0xE29D: 0x7B36,
	          0xE29E: 0x7B50,
	          0xE29F: 0x7B7A,
	          0xE2A0: 0x7B04,
	          0xE2A1: 0x7B4D,
	          0xE2A2: 0x7B0B,
	          0xE2A3: 0x7B4C,
	          0xE2A4: 0x7B45,
	          0xE2A5: 0x7B75,
	          0xE2A6: 0x7B65,
	          0xE2A7: 0x7B74,
	          0xE2A8: 0x7B67,
	          0xE2A9: 0x7B70,
	          0xE2AA: 0x7B71,
	          0xE2AB: 0x7B6C,
	          0xE2AC: 0x7B6E,
	          0xE2AD: 0x7B9D,
	          0xE2AE: 0x7B98,
	          0xE2AF: 0x7B9F,
	          0xE2B0: 0x7B8D,
	          0xE2B1: 0x7B9C,
	          0xE2B2: 0x7B9A,
	          0xE2B3: 0x7B8B,
	          0xE2B4: 0x7B92,
	          0xE2B5: 0x7B8F,
	          0xE2B6: 0x7B5D,
	          0xE2B7: 0x7B99,
	          0xE2B8: 0x7BCB,
	          0xE2B9: 0x7BC1,
	          0xE2BA: 0x7BCC,
	          0xE2BB: 0x7BCF,
	          0xE2BC: 0x7BB4,
	          0xE2BD: 0x7BC6,
	          0xE2BE: 0x7BDD,
	          0xE2BF: 0x7BE9,
	          0xE2C0: 0x7C11,
	          0xE2C1: 0x7C14,
	          0xE2C2: 0x7BE6,
	          0xE2C3: 0x7BE5,
	          0xE2C4: 0x7C60,
	          0xE2C5: 0x7C00,
	          0xE2C6: 0x7C07,
	          0xE2C7: 0x7C13,
	          0xE2C8: 0x7BF3,
	          0xE2C9: 0x7BF7,
	          0xE2CA: 0x7C17,
	          0xE2CB: 0x7C0D,
	          0xE2CC: 0x7BF6,
	          0xE2CD: 0x7C23,
	          0xE2CE: 0x7C27,
	          0xE2CF: 0x7C2A,
	          0xE2D0: 0x7C1F,
	          0xE2D1: 0x7C37,
	          0xE2D2: 0x7C2B,
	          0xE2D3: 0x7C3D,
	          0xE2D4: 0x7C4C,
	          0xE2D5: 0x7C43,
	          0xE2D6: 0x7C54,
	          0xE2D7: 0x7C4F,
	          0xE2D8: 0x7C40,
	          0xE2D9: 0x7C50,
	          0xE2DA: 0x7C58,
	          0xE2DB: 0x7C5F,
	          0xE2DC: 0x7C64,
	          0xE2DD: 0x7C56,
	          0xE2DE: 0x7C65,
	          0xE2DF: 0x7C6C,
	          0xE2E0: 0x7C75,
	          0xE2E1: 0x7C83,
	          0xE2E2: 0x7C90,
	          0xE2E3: 0x7CA4,
	          0xE2E4: 0x7CAD,
	          0xE2E5: 0x7CA2,
	          0xE2E6: 0x7CAB,
	          0xE2E7: 0x7CA1,
	          0xE2E8: 0x7CA8,
	          0xE2E9: 0x7CB3,
	          0xE2EA: 0x7CB2,
	          0xE2EB: 0x7CB1,
	          0xE2EC: 0x7CAE,
	          0xE2ED: 0x7CB9,
	          0xE2EE: 0x7CBD,
	          0xE2EF: 0x7CC0,
	          0xE2F0: 0x7CC5,
	          0xE2F1: 0x7CC2,
	          0xE2F2: 0x7CD8,
	          0xE2F3: 0x7CD2,
	          0xE2F4: 0x7CDC,
	          0xE2F5: 0x7CE2,
	          0xE2F6: 0x9B3B,
	          0xE2F7: 0x7CEF,
	          0xE2F8: 0x7CF2,
	          0xE2F9: 0x7CF4,
	          0xE2FA: 0x7CF6,
	          0xE2FB: 0x7CFA,
	          0xE2FC: 0x7D06,
	          0xE340: 0x7D02,
	          0xE341: 0x7D1C,
	          0xE342: 0x7D15,
	          0xE343: 0x7D0A,
	          0xE344: 0x7D45,
	          0xE345: 0x7D4B,
	          0xE346: 0x7D2E,
	          0xE347: 0x7D32,
	          0xE348: 0x7D3F,
	          0xE349: 0x7D35,
	          0xE34A: 0x7D46,
	          0xE34B: 0x7D73,
	          0xE34C: 0x7D56,
	          0xE34D: 0x7D4E,
	          0xE34E: 0x7D72,
	          0xE34F: 0x7D68,
	          0xE350: 0x7D6E,
	          0xE351: 0x7D4F,
	          0xE352: 0x7D63,
	          0xE353: 0x7D93,
	          0xE354: 0x7D89,
	          0xE355: 0x7D5B,
	          0xE356: 0x7D8F,
	          0xE357: 0x7D7D,
	          0xE358: 0x7D9B,
	          0xE359: 0x7DBA,
	          0xE35A: 0x7DAE,
	          0xE35B: 0x7DA3,
	          0xE35C: 0x7DB5,
	          0xE35D: 0x7DC7,
	          0xE35E: 0x7DBD,
	          0xE35F: 0x7DAB,
	          0xE360: 0x7E3D,
	          0xE361: 0x7DA2,
	          0xE362: 0x7DAF,
	          0xE363: 0x7DDC,
	          0xE364: 0x7DB8,
	          0xE365: 0x7D9F,
	          0xE366: 0x7DB0,
	          0xE367: 0x7DD8,
	          0xE368: 0x7DDD,
	          0xE369: 0x7DE4,
	          0xE36A: 0x7DDE,
	          0xE36B: 0x7DFB,
	          0xE36C: 0x7DF2,
	          0xE36D: 0x7DE1,
	          0xE36E: 0x7E05,
	          0xE36F: 0x7E0A,
	          0xE370: 0x7E23,
	          0xE371: 0x7E21,
	          0xE372: 0x7E12,
	          0xE373: 0x7E31,
	          0xE374: 0x7E1F,
	          0xE375: 0x7E09,
	          0xE376: 0x7E0B,
	          0xE377: 0x7E22,
	          0xE378: 0x7E46,
	          0xE379: 0x7E66,
	          0xE37A: 0x7E3B,
	          0xE37B: 0x7E35,
	          0xE37C: 0x7E39,
	          0xE37D: 0x7E43,
	          0xE37E: 0x7E37,
	          0xE380: 0x7E32,
	          0xE381: 0x7E3A,
	          0xE382: 0x7E67,
	          0xE383: 0x7E5D,
	          0xE384: 0x7E56,
	          0xE385: 0x7E5E,
	          0xE386: 0x7E59,
	          0xE387: 0x7E5A,
	          0xE388: 0x7E79,
	          0xE389: 0x7E6A,
	          0xE38A: 0x7E69,
	          0xE38B: 0x7E7C,
	          0xE38C: 0x7E7B,
	          0xE38D: 0x7E83,
	          0xE38E: 0x7DD5,
	          0xE38F: 0x7E7D,
	          0xE390: 0x8FAE,
	          0xE391: 0x7E7F,
	          0xE392: 0x7E88,
	          0xE393: 0x7E89,
	          0xE394: 0x7E8C,
	          0xE395: 0x7E92,
	          0xE396: 0x7E90,
	          0xE397: 0x7E93,
	          0xE398: 0x7E94,
	          0xE399: 0x7E96,
	          0xE39A: 0x7E8E,
	          0xE39B: 0x7E9B,
	          0xE39C: 0x7E9C,
	          0xE39D: 0x7F38,
	          0xE39E: 0x7F3A,
	          0xE39F: 0x7F45,
	          0xE3A0: 0x7F4C,
	          0xE3A1: 0x7F4D,
	          0xE3A2: 0x7F4E,
	          0xE3A3: 0x7F50,
	          0xE3A4: 0x7F51,
	          0xE3A5: 0x7F55,
	          0xE3A6: 0x7F54,
	          0xE3A7: 0x7F58,
	          0xE3A8: 0x7F5F,
	          0xE3A9: 0x7F60,
	          0xE3AA: 0x7F68,
	          0xE3AB: 0x7F69,
	          0xE3AC: 0x7F67,
	          0xE3AD: 0x7F78,
	          0xE3AE: 0x7F82,
	          0xE3AF: 0x7F86,
	          0xE3B0: 0x7F83,
	          0xE3B1: 0x7F88,
	          0xE3B2: 0x7F87,
	          0xE3B3: 0x7F8C,
	          0xE3B4: 0x7F94,
	          0xE3B5: 0x7F9E,
	          0xE3B6: 0x7F9D,
	          0xE3B7: 0x7F9A,
	          0xE3B8: 0x7FA3,
	          0xE3B9: 0x7FAF,
	          0xE3BA: 0x7FB2,
	          0xE3BB: 0x7FB9,
	          0xE3BC: 0x7FAE,
	          0xE3BD: 0x7FB6,
	          0xE3BE: 0x7FB8,
	          0xE3BF: 0x8B71,
	          0xE3C0: 0x7FC5,
	          0xE3C1: 0x7FC6,
	          0xE3C2: 0x7FCA,
	          0xE3C3: 0x7FD5,
	          0xE3C4: 0x7FD4,
	          0xE3C5: 0x7FE1,
	          0xE3C6: 0x7FE6,
	          0xE3C7: 0x7FE9,
	          0xE3C8: 0x7FF3,
	          0xE3C9: 0x7FF9,
	          0xE3CA: 0x98DC,
	          0xE3CB: 0x8006,
	          0xE3CC: 0x8004,
	          0xE3CD: 0x800B,
	          0xE3CE: 0x8012,
	          0xE3CF: 0x8018,
	          0xE3D0: 0x8019,
	          0xE3D1: 0x801C,
	          0xE3D2: 0x8021,
	          0xE3D3: 0x8028,
	          0xE3D4: 0x803F,
	          0xE3D5: 0x803B,
	          0xE3D6: 0x804A,
	          0xE3D7: 0x8046,
	          0xE3D8: 0x8052,
	          0xE3D9: 0x8058,
	          0xE3DA: 0x805A,
	          0xE3DB: 0x805F,
	          0xE3DC: 0x8062,
	          0xE3DD: 0x8068,
	          0xE3DE: 0x8073,
	          0xE3DF: 0x8072,
	          0xE3E0: 0x8070,
	          0xE3E1: 0x8076,
	          0xE3E2: 0x8079,
	          0xE3E3: 0x807D,
	          0xE3E4: 0x807F,
	          0xE3E5: 0x8084,
	          0xE3E6: 0x8086,
	          0xE3E7: 0x8085,
	          0xE3E8: 0x809B,
	          0xE3E9: 0x8093,
	          0xE3EA: 0x809A,
	          0xE3EB: 0x80AD,
	          0xE3EC: 0x5190,
	          0xE3ED: 0x80AC,
	          0xE3EE: 0x80DB,
	          0xE3EF: 0x80E5,
	          0xE3F0: 0x80D9,
	          0xE3F1: 0x80DD,
	          0xE3F2: 0x80C4,
	          0xE3F3: 0x80DA,
	          0xE3F4: 0x80D6,
	          0xE3F5: 0x8109,
	          0xE3F6: 0x80EF,
	          0xE3F7: 0x80F1,
	          0xE3F8: 0x811B,
	          0xE3F9: 0x8129,
	          0xE3FA: 0x8123,
	          0xE3FB: 0x812F,
	          0xE3FC: 0x814B,
	          0xE440: 0x968B,
	          0xE441: 0x8146,
	          0xE442: 0x813E,
	          0xE443: 0x8153,
	          0xE444: 0x8151,
	          0xE445: 0x80FC,
	          0xE446: 0x8171,
	          0xE447: 0x816E,
	          0xE448: 0x8165,
	          0xE449: 0x8166,
	          0xE44A: 0x8174,
	          0xE44B: 0x8183,
	          0xE44C: 0x8188,
	          0xE44D: 0x818A,
	          0xE44E: 0x8180,
	          0xE44F: 0x8182,
	          0xE450: 0x81A0,
	          0xE451: 0x8195,
	          0xE452: 0x81A4,
	          0xE453: 0x81A3,
	          0xE454: 0x815F,
	          0xE455: 0x8193,
	          0xE456: 0x81A9,
	          0xE457: 0x81B0,
	          0xE458: 0x81B5,
	          0xE459: 0x81BE,
	          0xE45A: 0x81B8,
	          0xE45B: 0x81BD,
	          0xE45C: 0x81C0,
	          0xE45D: 0x81C2,
	          0xE45E: 0x81BA,
	          0xE45F: 0x81C9,
	          0xE460: 0x81CD,
	          0xE461: 0x81D1,
	          0xE462: 0x81D9,
	          0xE463: 0x81D8,
	          0xE464: 0x81C8,
	          0xE465: 0x81DA,
	          0xE466: 0x81DF,
	          0xE467: 0x81E0,
	          0xE468: 0x81E7,
	          0xE469: 0x81FA,
	          0xE46A: 0x81FB,
	          0xE46B: 0x81FE,
	          0xE46C: 0x8201,
	          0xE46D: 0x8202,
	          0xE46E: 0x8205,
	          0xE46F: 0x8207,
	          0xE470: 0x820A,
	          0xE471: 0x820D,
	          0xE472: 0x8210,
	          0xE473: 0x8216,
	          0xE474: 0x8229,
	          0xE475: 0x822B,
	          0xE476: 0x8238,
	          0xE477: 0x8233,
	          0xE478: 0x8240,
	          0xE479: 0x8259,
	          0xE47A: 0x8258,
	          0xE47B: 0x825D,
	          0xE47C: 0x825A,
	          0xE47D: 0x825F,
	          0xE47E: 0x8264,
	          0xE480: 0x8262,
	          0xE481: 0x8268,
	          0xE482: 0x826A,
	          0xE483: 0x826B,
	          0xE484: 0x822E,
	          0xE485: 0x8271,
	          0xE486: 0x8277,
	          0xE487: 0x8278,
	          0xE488: 0x827E,
	          0xE489: 0x828D,
	          0xE48A: 0x8292,
	          0xE48B: 0x82AB,
	          0xE48C: 0x829F,
	          0xE48D: 0x82BB,
	          0xE48E: 0x82AC,
	          0xE48F: 0x82E1,
	          0xE490: 0x82E3,
	          0xE491: 0x82DF,
	          0xE492: 0x82D2,
	          0xE493: 0x82F4,
	          0xE494: 0x82F3,
	          0xE495: 0x82FA,
	          0xE496: 0x8393,
	          0xE497: 0x8303,
	          0xE498: 0x82FB,
	          0xE499: 0x82F9,
	          0xE49A: 0x82DE,
	          0xE49B: 0x8306,
	          0xE49C: 0x82DC,
	          0xE49D: 0x8309,
	          0xE49E: 0x82D9,
	          0xE49F: 0x8335,
	          0xE4A0: 0x8334,
	          0xE4A1: 0x8316,
	          0xE4A2: 0x8332,
	          0xE4A3: 0x8331,
	          0xE4A4: 0x8340,
	          0xE4A5: 0x8339,
	          0xE4A6: 0x8350,
	          0xE4A7: 0x8345,
	          0xE4A8: 0x832F,
	          0xE4A9: 0x832B,
	          0xE4AA: 0x8317,
	          0xE4AB: 0x8318,
	          0xE4AC: 0x8385,
	          0xE4AD: 0x839A,
	          0xE4AE: 0x83AA,
	          0xE4AF: 0x839F,
	          0xE4B0: 0x83A2,
	          0xE4B1: 0x8396,
	          0xE4B2: 0x8323,
	          0xE4B3: 0x838E,
	          0xE4B4: 0x8387,
	          0xE4B5: 0x838A,
	          0xE4B6: 0x837C,
	          0xE4B7: 0x83B5,
	          0xE4B8: 0x8373,
	          0xE4B9: 0x8375,
	          0xE4BA: 0x83A0,
	          0xE4BB: 0x8389,
	          0xE4BC: 0x83A8,
	          0xE4BD: 0x83F4,
	          0xE4BE: 0x8413,
	          0xE4BF: 0x83EB,
	          0xE4C0: 0x83CE,
	          0xE4C1: 0x83FD,
	          0xE4C2: 0x8403,
	          0xE4C3: 0x83D8,
	          0xE4C4: 0x840B,
	          0xE4C5: 0x83C1,
	          0xE4C6: 0x83F7,
	          0xE4C7: 0x8407,
	          0xE4C8: 0x83E0,
	          0xE4C9: 0x83F2,
	          0xE4CA: 0x840D,
	          0xE4CB: 0x8422,
	          0xE4CC: 0x8420,
	          0xE4CD: 0x83BD,
	          0xE4CE: 0x8438,
	          0xE4CF: 0x8506,
	          0xE4D0: 0x83FB,
	          0xE4D1: 0x846D,
	          0xE4D2: 0x842A,
	          0xE4D3: 0x843C,
	          0xE4D4: 0x855A,
	          0xE4D5: 0x8484,
	          0xE4D6: 0x8477,
	          0xE4D7: 0x846B,
	          0xE4D8: 0x84AD,
	          0xE4D9: 0x846E,
	          0xE4DA: 0x8482,
	          0xE4DB: 0x8469,
	          0xE4DC: 0x8446,
	          0xE4DD: 0x842C,
	          0xE4DE: 0x846F,
	          0xE4DF: 0x8479,
	          0xE4E0: 0x8435,
	          0xE4E1: 0x84CA,
	          0xE4E2: 0x8462,
	          0xE4E3: 0x84B9,
	          0xE4E4: 0x84BF,
	          0xE4E5: 0x849F,
	          0xE4E6: 0x84D9,
	          0xE4E7: 0x84CD,
	          0xE4E8: 0x84BB,
	          0xE4E9: 0x84DA,
	          0xE4EA: 0x84D0,
	          0xE4EB: 0x84C1,
	          0xE4EC: 0x84C6,
	          0xE4ED: 0x84D6,
	          0xE4EE: 0x84A1,
	          0xE4EF: 0x8521,
	          0xE4F0: 0x84FF,
	          0xE4F1: 0x84F4,
	          0xE4F2: 0x8517,
	          0xE4F3: 0x8518,
	          0xE4F4: 0x852C,
	          0xE4F5: 0x851F,
	          0xE4F6: 0x8515,
	          0xE4F7: 0x8514,
	          0xE4F8: 0x84FC,
	          0xE4F9: 0x8540,
	          0xE4FA: 0x8563,
	          0xE4FB: 0x8558,
	          0xE4FC: 0x8548,
	          0xE540: 0x8541,
	          0xE541: 0x8602,
	          0xE542: 0x854B,
	          0xE543: 0x8555,
	          0xE544: 0x8580,
	          0xE545: 0x85A4,
	          0xE546: 0x8588,
	          0xE547: 0x8591,
	          0xE548: 0x858A,
	          0xE549: 0x85A8,
	          0xE54A: 0x856D,
	          0xE54B: 0x8594,
	          0xE54C: 0x859B,
	          0xE54D: 0x85EA,
	          0xE54E: 0x8587,
	          0xE54F: 0x859C,
	          0xE550: 0x8577,
	          0xE551: 0x857E,
	          0xE552: 0x8590,
	          0xE553: 0x85C9,
	          0xE554: 0x85BA,
	          0xE555: 0x85CF,
	          0xE556: 0x85B9,
	          0xE557: 0x85D0,
	          0xE558: 0x85D5,
	          0xE559: 0x85DD,
	          0xE55A: 0x85E5,
	          0xE55B: 0x85DC,
	          0xE55C: 0x85F9,
	          0xE55D: 0x860A,
	          0xE55E: 0x8613,
	          0xE55F: 0x860B,
	          0xE560: 0x85FE,
	          0xE561: 0x85FA,
	          0xE562: 0x8606,
	          0xE563: 0x8622,
	          0xE564: 0x861A,
	          0xE565: 0x8630,
	          0xE566: 0x863F,
	          0xE567: 0x864D,
	          0xE568: 0x4E55,
	          0xE569: 0x8654,
	          0xE56A: 0x865F,
	          0xE56B: 0x8667,
	          0xE56C: 0x8671,
	          0xE56D: 0x8693,
	          0xE56E: 0x86A3,
	          0xE56F: 0x86A9,
	          0xE570: 0x86AA,
	          0xE571: 0x868B,
	          0xE572: 0x868C,
	          0xE573: 0x86B6,
	          0xE574: 0x86AF,
	          0xE575: 0x86C4,
	          0xE576: 0x86C6,
	          0xE577: 0x86B0,
	          0xE578: 0x86C9,
	          0xE579: 0x8823,
	          0xE57A: 0x86AB,
	          0xE57B: 0x86D4,
	          0xE57C: 0x86DE,
	          0xE57D: 0x86E9,
	          0xE57E: 0x86EC,
	          0xE580: 0x86DF,
	          0xE581: 0x86DB,
	          0xE582: 0x86EF,
	          0xE583: 0x8712,
	          0xE584: 0x8706,
	          0xE585: 0x8708,
	          0xE586: 0x8700,
	          0xE587: 0x8703,
	          0xE588: 0x86FB,
	          0xE589: 0x8711,
	          0xE58A: 0x8709,
	          0xE58B: 0x870D,
	          0xE58C: 0x86F9,
	          0xE58D: 0x870A,
	          0xE58E: 0x8734,
	          0xE58F: 0x873F,
	          0xE590: 0x8737,
	          0xE591: 0x873B,
	          0xE592: 0x8725,
	          0xE593: 0x8729,
	          0xE594: 0x871A,
	          0xE595: 0x8760,
	          0xE596: 0x875F,
	          0xE597: 0x8778,
	          0xE598: 0x874C,
	          0xE599: 0x874E,
	          0xE59A: 0x8774,
	          0xE59B: 0x8757,
	          0xE59C: 0x8768,
	          0xE59D: 0x876E,
	          0xE59E: 0x8759,
	          0xE59F: 0x8753,
	          0xE5A0: 0x8763,
	          0xE5A1: 0x876A,
	          0xE5A2: 0x8805,
	          0xE5A3: 0x87A2,
	          0xE5A4: 0x879F,
	          0xE5A5: 0x8782,
	          0xE5A6: 0x87AF,
	          0xE5A7: 0x87CB,
	          0xE5A8: 0x87BD,
	          0xE5A9: 0x87C0,
	          0xE5AA: 0x87D0,
	          0xE5AB: 0x96D6,
	          0xE5AC: 0x87AB,
	          0xE5AD: 0x87C4,
	          0xE5AE: 0x87B3,
	          0xE5AF: 0x87C7,
	          0xE5B0: 0x87C6,
	          0xE5B1: 0x87BB,
	          0xE5B2: 0x87EF,
	          0xE5B3: 0x87F2,
	          0xE5B4: 0x87E0,
	          0xE5B5: 0x880F,
	          0xE5B6: 0x880D,
	          0xE5B7: 0x87FE,
	          0xE5B8: 0x87F6,
	          0xE5B9: 0x87F7,
	          0xE5BA: 0x880E,
	          0xE5BB: 0x87D2,
	          0xE5BC: 0x8811,
	          0xE5BD: 0x8816,
	          0xE5BE: 0x8815,
	          0xE5BF: 0x8822,
	          0xE5C0: 0x8821,
	          0xE5C1: 0x8831,
	          0xE5C2: 0x8836,
	          0xE5C3: 0x8839,
	          0xE5C4: 0x8827,
	          0xE5C5: 0x883B,
	          0xE5C6: 0x8844,
	          0xE5C7: 0x8842,
	          0xE5C8: 0x8852,
	          0xE5C9: 0x8859,
	          0xE5CA: 0x885E,
	          0xE5CB: 0x8862,
	          0xE5CC: 0x886B,
	          0xE5CD: 0x8881,
	          0xE5CE: 0x887E,
	          0xE5CF: 0x889E,
	          0xE5D0: 0x8875,
	          0xE5D1: 0x887D,
	          0xE5D2: 0x88B5,
	          0xE5D3: 0x8872,
	          0xE5D4: 0x8882,
	          0xE5D5: 0x8897,
	          0xE5D6: 0x8892,
	          0xE5D7: 0x88AE,
	          0xE5D8: 0x8899,
	          0xE5D9: 0x88A2,
	          0xE5DA: 0x888D,
	          0xE5DB: 0x88A4,
	          0xE5DC: 0x88B0,
	          0xE5DD: 0x88BF,
	          0xE5DE: 0x88B1,
	          0xE5DF: 0x88C3,
	          0xE5E0: 0x88C4,
	          0xE5E1: 0x88D4,
	          0xE5E2: 0x88D8,
	          0xE5E3: 0x88D9,
	          0xE5E4: 0x88DD,
	          0xE5E5: 0x88F9,
	          0xE5E6: 0x8902,
	          0xE5E7: 0x88FC,
	          0xE5E8: 0x88F4,
	          0xE5E9: 0x88E8,
	          0xE5EA: 0x88F2,
	          0xE5EB: 0x8904,
	          0xE5EC: 0x890C,
	          0xE5ED: 0x890A,
	          0xE5EE: 0x8913,
	          0xE5EF: 0x8943,
	          0xE5F0: 0x891E,
	          0xE5F1: 0x8925,
	          0xE5F2: 0x892A,
	          0xE5F3: 0x892B,
	          0xE5F4: 0x8941,
	          0xE5F5: 0x8944,
	          0xE5F6: 0x893B,
	          0xE5F7: 0x8936,
	          0xE5F8: 0x8938,
	          0xE5F9: 0x894C,
	          0xE5FA: 0x891D,
	          0xE5FB: 0x8960,
	          0xE5FC: 0x895E,
	          0xE640: 0x8966,
	          0xE641: 0x8964,
	          0xE642: 0x896D,
	          0xE643: 0x896A,
	          0xE644: 0x896F,
	          0xE645: 0x8974,
	          0xE646: 0x8977,
	          0xE647: 0x897E,
	          0xE648: 0x8983,
	          0xE649: 0x8988,
	          0xE64A: 0x898A,
	          0xE64B: 0x8993,
	          0xE64C: 0x8998,
	          0xE64D: 0x89A1,
	          0xE64E: 0x89A9,
	          0xE64F: 0x89A6,
	          0xE650: 0x89AC,
	          0xE651: 0x89AF,
	          0xE652: 0x89B2,
	          0xE653: 0x89BA,
	          0xE654: 0x89BD,
	          0xE655: 0x89BF,
	          0xE656: 0x89C0,
	          0xE657: 0x89DA,
	          0xE658: 0x89DC,
	          0xE659: 0x89DD,
	          0xE65A: 0x89E7,
	          0xE65B: 0x89F4,
	          0xE65C: 0x89F8,
	          0xE65D: 0x8A03,
	          0xE65E: 0x8A16,
	          0xE65F: 0x8A10,
	          0xE660: 0x8A0C,
	          0xE661: 0x8A1B,
	          0xE662: 0x8A1D,
	          0xE663: 0x8A25,
	          0xE664: 0x8A36,
	          0xE665: 0x8A41,
	          0xE666: 0x8A5B,
	          0xE667: 0x8A52,
	          0xE668: 0x8A46,
	          0xE669: 0x8A48,
	          0xE66A: 0x8A7C,
	          0xE66B: 0x8A6D,
	          0xE66C: 0x8A6C,
	          0xE66D: 0x8A62,
	          0xE66E: 0x8A85,
	          0xE66F: 0x8A82,
	          0xE670: 0x8A84,
	          0xE671: 0x8AA8,
	          0xE672: 0x8AA1,
	          0xE673: 0x8A91,
	          0xE674: 0x8AA5,
	          0xE675: 0x8AA6,
	          0xE676: 0x8A9A,
	          0xE677: 0x8AA3,
	          0xE678: 0x8AC4,
	          0xE679: 0x8ACD,
	          0xE67A: 0x8AC2,
	          0xE67B: 0x8ADA,
	          0xE67C: 0x8AEB,
	          0xE67D: 0x8AF3,
	          0xE67E: 0x8AE7,
	          0xE680: 0x8AE4,
	          0xE681: 0x8AF1,
	          0xE682: 0x8B14,
	          0xE683: 0x8AE0,
	          0xE684: 0x8AE2,
	          0xE685: 0x8AF7,
	          0xE686: 0x8ADE,
	          0xE687: 0x8ADB,
	          0xE688: 0x8B0C,
	          0xE689: 0x8B07,
	          0xE68A: 0x8B1A,
	          0xE68B: 0x8AE1,
	          0xE68C: 0x8B16,
	          0xE68D: 0x8B10,
	          0xE68E: 0x8B17,
	          0xE68F: 0x8B20,
	          0xE690: 0x8B33,
	          0xE691: 0x97AB,
	          0xE692: 0x8B26,
	          0xE693: 0x8B2B,
	          0xE694: 0x8B3E,
	          0xE695: 0x8B28,
	          0xE696: 0x8B41,
	          0xE697: 0x8B4C,
	          0xE698: 0x8B4F,
	          0xE699: 0x8B4E,
	          0xE69A: 0x8B49,
	          0xE69B: 0x8B56,
	          0xE69C: 0x8B5B,
	          0xE69D: 0x8B5A,
	          0xE69E: 0x8B6B,
	          0xE69F: 0x8B5F,
	          0xE6A0: 0x8B6C,
	          0xE6A1: 0x8B6F,
	          0xE6A2: 0x8B74,
	          0xE6A3: 0x8B7D,
	          0xE6A4: 0x8B80,
	          0xE6A5: 0x8B8C,
	          0xE6A6: 0x8B8E,
	          0xE6A7: 0x8B92,
	          0xE6A8: 0x8B93,
	          0xE6A9: 0x8B96,
	          0xE6AA: 0x8B99,
	          0xE6AB: 0x8B9A,
	          0xE6AC: 0x8C3A,
	          0xE6AD: 0x8C41,
	          0xE6AE: 0x8C3F,
	          0xE6AF: 0x8C48,
	          0xE6B0: 0x8C4C,
	          0xE6B1: 0x8C4E,
	          0xE6B2: 0x8C50,
	          0xE6B3: 0x8C55,
	          0xE6B4: 0x8C62,
	          0xE6B5: 0x8C6C,
	          0xE6B6: 0x8C78,
	          0xE6B7: 0x8C7A,
	          0xE6B8: 0x8C82,
	          0xE6B9: 0x8C89,
	          0xE6BA: 0x8C85,
	          0xE6BB: 0x8C8A,
	          0xE6BC: 0x8C8D,
	          0xE6BD: 0x8C8E,
	          0xE6BE: 0x8C94,
	          0xE6BF: 0x8C7C,
	          0xE6C0: 0x8C98,
	          0xE6C1: 0x621D,
	          0xE6C2: 0x8CAD,
	          0xE6C3: 0x8CAA,
	          0xE6C4: 0x8CBD,
	          0xE6C5: 0x8CB2,
	          0xE6C6: 0x8CB3,
	          0xE6C7: 0x8CAE,
	          0xE6C8: 0x8CB6,
	          0xE6C9: 0x8CC8,
	          0xE6CA: 0x8CC1,
	          0xE6CB: 0x8CE4,
	          0xE6CC: 0x8CE3,
	          0xE6CD: 0x8CDA,
	          0xE6CE: 0x8CFD,
	          0xE6CF: 0x8CFA,
	          0xE6D0: 0x8CFB,
	          0xE6D1: 0x8D04,
	          0xE6D2: 0x8D05,
	          0xE6D3: 0x8D0A,
	          0xE6D4: 0x8D07,
	          0xE6D5: 0x8D0F,
	          0xE6D6: 0x8D0D,
	          0xE6D7: 0x8D10,
	          0xE6D8: 0x9F4E,
	          0xE6D9: 0x8D13,
	          0xE6DA: 0x8CCD,
	          0xE6DB: 0x8D14,
	          0xE6DC: 0x8D16,
	          0xE6DD: 0x8D67,
	          0xE6DE: 0x8D6D,
	          0xE6DF: 0x8D71,
	          0xE6E0: 0x8D73,
	          0xE6E1: 0x8D81,
	          0xE6E2: 0x8D99,
	          0xE6E3: 0x8DC2,
	          0xE6E4: 0x8DBE,
	          0xE6E5: 0x8DBA,
	          0xE6E6: 0x8DCF,
	          0xE6E7: 0x8DDA,
	          0xE6E8: 0x8DD6,
	          0xE6E9: 0x8DCC,
	          0xE6EA: 0x8DDB,
	          0xE6EB: 0x8DCB,
	          0xE6EC: 0x8DEA,
	          0xE6ED: 0x8DEB,
	          0xE6EE: 0x8DDF,
	          0xE6EF: 0x8DE3,
	          0xE6F0: 0x8DFC,
	          0xE6F1: 0x8E08,
	          0xE6F2: 0x8E09,
	          0xE6F3: 0x8DFF,
	          0xE6F4: 0x8E1D,
	          0xE6F5: 0x8E1E,
	          0xE6F6: 0x8E10,
	          0xE6F7: 0x8E1F,
	          0xE6F8: 0x8E42,
	          0xE6F9: 0x8E35,
	          0xE6FA: 0x8E30,
	          0xE6FB: 0x8E34,
	          0xE6FC: 0x8E4A,
	          0xE740: 0x8E47,
	          0xE741: 0x8E49,
	          0xE742: 0x8E4C,
	          0xE743: 0x8E50,
	          0xE744: 0x8E48,
	          0xE745: 0x8E59,
	          0xE746: 0x8E64,
	          0xE747: 0x8E60,
	          0xE748: 0x8E2A,
	          0xE749: 0x8E63,
	          0xE74A: 0x8E55,
	          0xE74B: 0x8E76,
	          0xE74C: 0x8E72,
	          0xE74D: 0x8E7C,
	          0xE74E: 0x8E81,
	          0xE74F: 0x8E87,
	          0xE750: 0x8E85,
	          0xE751: 0x8E84,
	          0xE752: 0x8E8B,
	          0xE753: 0x8E8A,
	          0xE754: 0x8E93,
	          0xE755: 0x8E91,
	          0xE756: 0x8E94,
	          0xE757: 0x8E99,
	          0xE758: 0x8EAA,
	          0xE759: 0x8EA1,
	          0xE75A: 0x8EAC,
	          0xE75B: 0x8EB0,
	          0xE75C: 0x8EC6,
	          0xE75D: 0x8EB1,
	          0xE75E: 0x8EBE,
	          0xE75F: 0x8EC5,
	          0xE760: 0x8EC8,
	          0xE761: 0x8ECB,
	          0xE762: 0x8EDB,
	          0xE763: 0x8EE3,
	          0xE764: 0x8EFC,
	          0xE765: 0x8EFB,
	          0xE766: 0x8EEB,
	          0xE767: 0x8EFE,
	          0xE768: 0x8F0A,
	          0xE769: 0x8F05,
	          0xE76A: 0x8F15,
	          0xE76B: 0x8F12,
	          0xE76C: 0x8F19,
	          0xE76D: 0x8F13,
	          0xE76E: 0x8F1C,
	          0xE76F: 0x8F1F,
	          0xE770: 0x8F1B,
	          0xE771: 0x8F0C,
	          0xE772: 0x8F26,
	          0xE773: 0x8F33,
	          0xE774: 0x8F3B,
	          0xE775: 0x8F39,
	          0xE776: 0x8F45,
	          0xE777: 0x8F42,
	          0xE778: 0x8F3E,
	          0xE779: 0x8F4C,
	          0xE77A: 0x8F49,
	          0xE77B: 0x8F46,
	          0xE77C: 0x8F4E,
	          0xE77D: 0x8F57,
	          0xE77E: 0x8F5C,
	          0xE780: 0x8F62,
	          0xE781: 0x8F63,
	          0xE782: 0x8F64,
	          0xE783: 0x8F9C,
	          0xE784: 0x8F9F,
	          0xE785: 0x8FA3,
	          0xE786: 0x8FAD,
	          0xE787: 0x8FAF,
	          0xE788: 0x8FB7,
	          0xE789: 0x8FDA,
	          0xE78A: 0x8FE5,
	          0xE78B: 0x8FE2,
	          0xE78C: 0x8FEA,
	          0xE78D: 0x8FEF,
	          0xE78E: 0x9087,
	          0xE78F: 0x8FF4,
	          0xE790: 0x9005,
	          0xE791: 0x8FF9,
	          0xE792: 0x8FFA,
	          0xE793: 0x9011,
	          0xE794: 0x9015,
	          0xE795: 0x9021,
	          0xE796: 0x900D,
	          0xE797: 0x901E,
	          0xE798: 0x9016,
	          0xE799: 0x900B,
	          0xE79A: 0x9027,
	          0xE79B: 0x9036,
	          0xE79C: 0x9035,
	          0xE79D: 0x9039,
	          0xE79E: 0x8FF8,
	          0xE79F: 0x904F,
	          0xE7A0: 0x9050,
	          0xE7A1: 0x9051,
	          0xE7A2: 0x9052,
	          0xE7A3: 0x900E,
	          0xE7A4: 0x9049,
	          0xE7A5: 0x903E,
	          0xE7A6: 0x9056,
	          0xE7A7: 0x9058,
	          0xE7A8: 0x905E,
	          0xE7A9: 0x9068,
	          0xE7AA: 0x906F,
	          0xE7AB: 0x9076,
	          0xE7AC: 0x96A8,
	          0xE7AD: 0x9072,
	          0xE7AE: 0x9082,
	          0xE7AF: 0x907D,
	          0xE7B0: 0x9081,
	          0xE7B1: 0x9080,
	          0xE7B2: 0x908A,
	          0xE7B3: 0x9089,
	          0xE7B4: 0x908F,
	          0xE7B5: 0x90A8,
	          0xE7B6: 0x90AF,
	          0xE7B7: 0x90B1,
	          0xE7B8: 0x90B5,
	          0xE7B9: 0x90E2,
	          0xE7BA: 0x90E4,
	          0xE7BB: 0x6248,
	          0xE7BC: 0x90DB,
	          0xE7BD: 0x9102,
	          0xE7BE: 0x9112,
	          0xE7BF: 0x9119,
	          0xE7C0: 0x9132,
	          0xE7C1: 0x9130,
	          0xE7C2: 0x914A,
	          0xE7C3: 0x9156,
	          0xE7C4: 0x9158,
	          0xE7C5: 0x9163,
	          0xE7C6: 0x9165,
	          0xE7C7: 0x9169,
	          0xE7C8: 0x9173,
	          0xE7C9: 0x9172,
	          0xE7CA: 0x918B,
	          0xE7CB: 0x9189,
	          0xE7CC: 0x9182,
	          0xE7CD: 0x91A2,
	          0xE7CE: 0x91AB,
	          0xE7CF: 0x91AF,
	          0xE7D0: 0x91AA,
	          0xE7D1: 0x91B5,
	          0xE7D2: 0x91B4,
	          0xE7D3: 0x91BA,
	          0xE7D4: 0x91C0,
	          0xE7D5: 0x91C1,
	          0xE7D6: 0x91C9,
	          0xE7D7: 0x91CB,
	          0xE7D8: 0x91D0,
	          0xE7D9: 0x91D6,
	          0xE7DA: 0x91DF,
	          0xE7DB: 0x91E1,
	          0xE7DC: 0x91DB,
	          0xE7DD: 0x91FC,
	          0xE7DE: 0x91F5,
	          0xE7DF: 0x91F6,
	          0xE7E0: 0x921E,
	          0xE7E1: 0x91FF,
	          0xE7E2: 0x9214,
	          0xE7E3: 0x922C,
	          0xE7E4: 0x9215,
	          0xE7E5: 0x9211,
	          0xE7E6: 0x925E,
	          0xE7E7: 0x9257,
	          0xE7E8: 0x9245,
	          0xE7E9: 0x9249,
	          0xE7EA: 0x9264,
	          0xE7EB: 0x9248,
	          0xE7EC: 0x9295,
	          0xE7ED: 0x923F,
	          0xE7EE: 0x924B,
	          0xE7EF: 0x9250,
	          0xE7F0: 0x929C,
	          0xE7F1: 0x9296,
	          0xE7F2: 0x9293,
	          0xE7F3: 0x929B,
	          0xE7F4: 0x925A,
	          0xE7F5: 0x92CF,
	          0xE7F6: 0x92B9,
	          0xE7F7: 0x92B7,
	          0xE7F8: 0x92E9,
	          0xE7F9: 0x930F,
	          0xE7FA: 0x92FA,
	          0xE7FB: 0x9344,
	          0xE7FC: 0x932E,
	          0xE840: 0x9319,
	          0xE841: 0x9322,
	          0xE842: 0x931A,
	          0xE843: 0x9323,
	          0xE844: 0x933A,
	          0xE845: 0x9335,
	          0xE846: 0x933B,
	          0xE847: 0x935C,
	          0xE848: 0x9360,
	          0xE849: 0x937C,
	          0xE84A: 0x936E,
	          0xE84B: 0x9356,
	          0xE84C: 0x93B0,
	          0xE84D: 0x93AC,
	          0xE84E: 0x93AD,
	          0xE84F: 0x9394,
	          0xE850: 0x93B9,
	          0xE851: 0x93D6,
	          0xE852: 0x93D7,
	          0xE853: 0x93E8,
	          0xE854: 0x93E5,
	          0xE855: 0x93D8,
	          0xE856: 0x93C3,
	          0xE857: 0x93DD,
	          0xE858: 0x93D0,
	          0xE859: 0x93C8,
	          0xE85A: 0x93E4,
	          0xE85B: 0x941A,
	          0xE85C: 0x9414,
	          0xE85D: 0x9413,
	          0xE85E: 0x9403,
	          0xE85F: 0x9407,
	          0xE860: 0x9410,
	          0xE861: 0x9436,
	          0xE862: 0x942B,
	          0xE863: 0x9435,
	          0xE864: 0x9421,
	          0xE865: 0x943A,
	          0xE866: 0x9441,
	          0xE867: 0x9452,
	          0xE868: 0x9444,
	          0xE869: 0x945B,
	          0xE86A: 0x9460,
	          0xE86B: 0x9462,
	          0xE86C: 0x945E,
	          0xE86D: 0x946A,
	          0xE86E: 0x9229,
	          0xE86F: 0x9470,
	          0xE870: 0x9475,
	          0xE871: 0x9477,
	          0xE872: 0x947D,
	          0xE873: 0x945A,
	          0xE874: 0x947C,
	          0xE875: 0x947E,
	          0xE876: 0x9481,
	          0xE877: 0x947F,
	          0xE878: 0x9582,
	          0xE879: 0x9587,
	          0xE87A: 0x958A,
	          0xE87B: 0x9594,
	          0xE87C: 0x9596,
	          0xE87D: 0x9598,
	          0xE87E: 0x9599,
	          0xE880: 0x95A0,
	          0xE881: 0x95A8,
	          0xE882: 0x95A7,
	          0xE883: 0x95AD,
	          0xE884: 0x95BC,
	          0xE885: 0x95BB,
	          0xE886: 0x95B9,
	          0xE887: 0x95BE,
	          0xE888: 0x95CA,
	          0xE889: 0x6FF6,
	          0xE88A: 0x95C3,
	          0xE88B: 0x95CD,
	          0xE88C: 0x95CC,
	          0xE88D: 0x95D5,
	          0xE88E: 0x95D4,
	          0xE88F: 0x95D6,
	          0xE890: 0x95DC,
	          0xE891: 0x95E1,
	          0xE892: 0x95E5,
	          0xE893: 0x95E2,
	          0xE894: 0x9621,
	          0xE895: 0x9628,
	          0xE896: 0x962E,
	          0xE897: 0x962F,
	          0xE898: 0x9642,
	          0xE899: 0x964C,
	          0xE89A: 0x964F,
	          0xE89B: 0x964B,
	          0xE89C: 0x9677,
	          0xE89D: 0x965C,
	          0xE89E: 0x965E,
	          0xE89F: 0x965D,
	          0xE8A0: 0x965F,
	          0xE8A1: 0x9666,
	          0xE8A2: 0x9672,
	          0xE8A3: 0x966C,
	          0xE8A4: 0x968D,
	          0xE8A5: 0x9698,
	          0xE8A6: 0x9695,
	          0xE8A7: 0x9697,
	          0xE8A8: 0x96AA,
	          0xE8A9: 0x96A7,
	          0xE8AA: 0x96B1,
	          0xE8AB: 0x96B2,
	          0xE8AC: 0x96B0,
	          0xE8AD: 0x96B4,
	          0xE8AE: 0x96B6,
	          0xE8AF: 0x96B8,
	          0xE8B0: 0x96B9,
	          0xE8B1: 0x96CE,
	          0xE8B2: 0x96CB,
	          0xE8B3: 0x96C9,
	          0xE8B4: 0x96CD,
	          0xE8B5: 0x894D,
	          0xE8B6: 0x96DC,
	          0xE8B7: 0x970D,
	          0xE8B8: 0x96D5,
	          0xE8B9: 0x96F9,
	          0xE8BA: 0x9704,
	          0xE8BB: 0x9706,
	          0xE8BC: 0x9708,
	          0xE8BD: 0x9713,
	          0xE8BE: 0x970E,
	          0xE8BF: 0x9711,
	          0xE8C0: 0x970F,
	          0xE8C1: 0x9716,
	          0xE8C2: 0x9719,
	          0xE8C3: 0x9724,
	          0xE8C4: 0x972A,
	          0xE8C5: 0x9730,
	          0xE8C6: 0x9739,
	          0xE8C7: 0x973D,
	          0xE8C8: 0x973E,
	          0xE8C9: 0x9744,
	          0xE8CA: 0x9746,
	          0xE8CB: 0x9748,
	          0xE8CC: 0x9742,
	          0xE8CD: 0x9749,
	          0xE8CE: 0x975C,
	          0xE8CF: 0x9760,
	          0xE8D0: 0x9764,
	          0xE8D1: 0x9766,
	          0xE8D2: 0x9768,
	          0xE8D3: 0x52D2,
	          0xE8D4: 0x976B,
	          0xE8D5: 0x9771,
	          0xE8D6: 0x9779,
	          0xE8D7: 0x9785,
	          0xE8D8: 0x977C,
	          0xE8D9: 0x9781,
	          0xE8DA: 0x977A,
	          0xE8DB: 0x9786,
	          0xE8DC: 0x978B,
	          0xE8DD: 0x978F,
	          0xE8DE: 0x9790,
	          0xE8DF: 0x979C,
	          0xE8E0: 0x97A8,
	          0xE8E1: 0x97A6,
	          0xE8E2: 0x97A3,
	          0xE8E3: 0x97B3,
	          0xE8E4: 0x97B4,
	          0xE8E5: 0x97C3,
	          0xE8E6: 0x97C6,
	          0xE8E7: 0x97C8,
	          0xE8E8: 0x97CB,
	          0xE8E9: 0x97DC,
	          0xE8EA: 0x97ED,
	          0xE8EB: 0x9F4F,
	          0xE8EC: 0x97F2,
	          0xE8ED: 0x7ADF,
	          0xE8EE: 0x97F6,
	          0xE8EF: 0x97F5,
	          0xE8F0: 0x980F,
	          0xE8F1: 0x980C,
	          0xE8F2: 0x9838,
	          0xE8F3: 0x9824,
	          0xE8F4: 0x9821,
	          0xE8F5: 0x9837,
	          0xE8F6: 0x983D,
	          0xE8F7: 0x9846,
	          0xE8F8: 0x984F,
	          0xE8F9: 0x984B,
	          0xE8FA: 0x986B,
	          0xE8FB: 0x986F,
	          0xE8FC: 0x9870,
	          0xE940: 0x9871,
	          0xE941: 0x9874,
	          0xE942: 0x9873,
	          0xE943: 0x98AA,
	          0xE944: 0x98AF,
	          0xE945: 0x98B1,
	          0xE946: 0x98B6,
	          0xE947: 0x98C4,
	          0xE948: 0x98C3,
	          0xE949: 0x98C6,
	          0xE94A: 0x98E9,
	          0xE94B: 0x98EB,
	          0xE94C: 0x9903,
	          0xE94D: 0x9909,
	          0xE94E: 0x9912,
	          0xE94F: 0x9914,
	          0xE950: 0x9918,
	          0xE951: 0x9921,
	          0xE952: 0x991D,
	          0xE953: 0x991E,
	          0xE954: 0x9924,
	          0xE955: 0x9920,
	          0xE956: 0x992C,
	          0xE957: 0x992E,
	          0xE958: 0x993D,
	          0xE959: 0x993E,
	          0xE95A: 0x9942,
	          0xE95B: 0x9949,
	          0xE95C: 0x9945,
	          0xE95D: 0x9950,
	          0xE95E: 0x994B,
	          0xE95F: 0x9951,
	          0xE960: 0x9952,
	          0xE961: 0x994C,
	          0xE962: 0x9955,
	          0xE963: 0x9997,
	          0xE964: 0x9998,
	          0xE965: 0x99A5,
	          0xE966: 0x99AD,
	          0xE967: 0x99AE,
	          0xE968: 0x99BC,
	          0xE969: 0x99DF,
	          0xE96A: 0x99DB,
	          0xE96B: 0x99DD,
	          0xE96C: 0x99D8,
	          0xE96D: 0x99D1,
	          0xE96E: 0x99ED,
	          0xE96F: 0x99EE,
	          0xE970: 0x99F1,
	          0xE971: 0x99F2,
	          0xE972: 0x99FB,
	          0xE973: 0x99F8,
	          0xE974: 0x9A01,
	          0xE975: 0x9A0F,
	          0xE976: 0x9A05,
	          0xE977: 0x99E2,
	          0xE978: 0x9A19,
	          0xE979: 0x9A2B,
	          0xE97A: 0x9A37,
	          0xE97B: 0x9A45,
	          0xE97C: 0x9A42,
	          0xE97D: 0x9A40,
	          0xE97E: 0x9A43,
	          0xE980: 0x9A3E,
	          0xE981: 0x9A55,
	          0xE982: 0x9A4D,
	          0xE983: 0x9A5B,
	          0xE984: 0x9A57,
	          0xE985: 0x9A5F,
	          0xE986: 0x9A62,
	          0xE987: 0x9A65,
	          0xE988: 0x9A64,
	          0xE989: 0x9A69,
	          0xE98A: 0x9A6B,
	          0xE98B: 0x9A6A,
	          0xE98C: 0x9AAD,
	          0xE98D: 0x9AB0,
	          0xE98E: 0x9ABC,
	          0xE98F: 0x9AC0,
	          0xE990: 0x9ACF,
	          0xE991: 0x9AD1,
	          0xE992: 0x9AD3,
	          0xE993: 0x9AD4,
	          0xE994: 0x9ADE,
	          0xE995: 0x9ADF,
	          0xE996: 0x9AE2,
	          0xE997: 0x9AE3,
	          0xE998: 0x9AE6,
	          0xE999: 0x9AEF,
	          0xE99A: 0x9AEB,
	          0xE99B: 0x9AEE,
	          0xE99C: 0x9AF4,
	          0xE99D: 0x9AF1,
	          0xE99E: 0x9AF7,
	          0xE99F: 0x9AFB,
	          0xE9A0: 0x9B06,
	          0xE9A1: 0x9B18,
	          0xE9A2: 0x9B1A,
	          0xE9A3: 0x9B1F,
	          0xE9A4: 0x9B22,
	          0xE9A5: 0x9B23,
	          0xE9A6: 0x9B25,
	          0xE9A7: 0x9B27,
	          0xE9A8: 0x9B28,
	          0xE9A9: 0x9B29,
	          0xE9AA: 0x9B2A,
	          0xE9AB: 0x9B2E,
	          0xE9AC: 0x9B2F,
	          0xE9AD: 0x9B32,
	          0xE9AE: 0x9B44,
	          0xE9AF: 0x9B43,
	          0xE9B0: 0x9B4F,
	          0xE9B1: 0x9B4D,
	          0xE9B2: 0x9B4E,
	          0xE9B3: 0x9B51,
	          0xE9B4: 0x9B58,
	          0xE9B5: 0x9B74,
	          0xE9B6: 0x9B93,
	          0xE9B7: 0x9B83,
	          0xE9B8: 0x9B91,
	          0xE9B9: 0x9B96,
	          0xE9BA: 0x9B97,
	          0xE9BB: 0x9B9F,
	          0xE9BC: 0x9BA0,
	          0xE9BD: 0x9BA8,
	          0xE9BE: 0x9BB4,
	          0xE9BF: 0x9BC0,
	          0xE9C0: 0x9BCA,
	          0xE9C1: 0x9BB9,
	          0xE9C2: 0x9BC6,
	          0xE9C3: 0x9BCF,
	          0xE9C4: 0x9BD1,
	          0xE9C5: 0x9BD2,
	          0xE9C6: 0x9BE3,
	          0xE9C7: 0x9BE2,
	          0xE9C8: 0x9BE4,
	          0xE9C9: 0x9BD4,
	          0xE9CA: 0x9BE1,
	          0xE9CB: 0x9C3A,
	          0xE9CC: 0x9BF2,
	          0xE9CD: 0x9BF1,
	          0xE9CE: 0x9BF0,
	          0xE9CF: 0x9C15,
	          0xE9D0: 0x9C14,
	          0xE9D1: 0x9C09,
	          0xE9D2: 0x9C13,
	          0xE9D3: 0x9C0C,
	          0xE9D4: 0x9C06,
	          0xE9D5: 0x9C08,
	          0xE9D6: 0x9C12,
	          0xE9D7: 0x9C0A,
	          0xE9D8: 0x9C04,
	          0xE9D9: 0x9C2E,
	          0xE9DA: 0x9C1B,
	          0xE9DB: 0x9C25,
	          0xE9DC: 0x9C24,
	          0xE9DD: 0x9C21,
	          0xE9DE: 0x9C30,
	          0xE9DF: 0x9C47,
	          0xE9E0: 0x9C32,
	          0xE9E1: 0x9C46,
	          0xE9E2: 0x9C3E,
	          0xE9E3: 0x9C5A,
	          0xE9E4: 0x9C60,
	          0xE9E5: 0x9C67,
	          0xE9E6: 0x9C76,
	          0xE9E7: 0x9C78,
	          0xE9E8: 0x9CE7,
	          0xE9E9: 0x9CEC,
	          0xE9EA: 0x9CF0,
	          0xE9EB: 0x9D09,
	          0xE9EC: 0x9D08,
	          0xE9ED: 0x9CEB,
	          0xE9EE: 0x9D03,
	          0xE9EF: 0x9D06,
	          0xE9F0: 0x9D2A,
	          0xE9F1: 0x9D26,
	          0xE9F2: 0x9DAF,
	          0xE9F3: 0x9D23,
	          0xE9F4: 0x9D1F,
	          0xE9F5: 0x9D44,
	          0xE9F6: 0x9D15,
	          0xE9F7: 0x9D12,
	          0xE9F8: 0x9D41,
	          0xE9F9: 0x9D3F,
	          0xE9FA: 0x9D3E,
	          0xE9FB: 0x9D46,
	          0xE9FC: 0x9D48,
	          0xEA40: 0x9D5D,
	          0xEA41: 0x9D5E,
	          0xEA42: 0x9D64,
	          0xEA43: 0x9D51,
	          0xEA44: 0x9D50,
	          0xEA45: 0x9D59,
	          0xEA46: 0x9D72,
	          0xEA47: 0x9D89,
	          0xEA48: 0x9D87,
	          0xEA49: 0x9DAB,
	          0xEA4A: 0x9D6F,
	          0xEA4B: 0x9D7A,
	          0xEA4C: 0x9D9A,
	          0xEA4D: 0x9DA4,
	          0xEA4E: 0x9DA9,
	          0xEA4F: 0x9DB2,
	          0xEA50: 0x9DC4,
	          0xEA51: 0x9DC1,
	          0xEA52: 0x9DBB,
	          0xEA53: 0x9DB8,
	          0xEA54: 0x9DBA,
	          0xEA55: 0x9DC6,
	          0xEA56: 0x9DCF,
	          0xEA57: 0x9DC2,
	          0xEA58: 0x9DD9,
	          0xEA59: 0x9DD3,
	          0xEA5A: 0x9DF8,
	          0xEA5B: 0x9DE6,
	          0xEA5C: 0x9DED,
	          0xEA5D: 0x9DEF,
	          0xEA5E: 0x9DFD,
	          0xEA5F: 0x9E1A,
	          0xEA60: 0x9E1B,
	          0xEA61: 0x9E1E,
	          0xEA62: 0x9E75,
	          0xEA63: 0x9E79,
	          0xEA64: 0x9E7D,
	          0xEA65: 0x9E81,
	          0xEA66: 0x9E88,
	          0xEA67: 0x9E8B,
	          0xEA68: 0x9E8C,
	          0xEA69: 0x9E92,
	          0xEA6A: 0x9E95,
	          0xEA6B: 0x9E91,
	          0xEA6C: 0x9E9D,
	          0xEA6D: 0x9EA5,
	          0xEA6E: 0x9EA9,
	          0xEA6F: 0x9EB8,
	          0xEA70: 0x9EAA,
	          0xEA71: 0x9EAD,
	          0xEA72: 0x9761,
	          0xEA73: 0x9ECC,
	          0xEA74: 0x9ECE,
	          0xEA75: 0x9ECF,
	          0xEA76: 0x9ED0,
	          0xEA77: 0x9ED4,
	          0xEA78: 0x9EDC,
	          0xEA79: 0x9EDE,
	          0xEA7A: 0x9EDD,
	          0xEA7B: 0x9EE0,
	          0xEA7C: 0x9EE5,
	          0xEA7D: 0x9EE8,
	          0xEA7E: 0x9EEF,
	          0xEA80: 0x9EF4,
	          0xEA81: 0x9EF6,
	          0xEA82: 0x9EF7,
	          0xEA83: 0x9EF9,
	          0xEA84: 0x9EFB,
	          0xEA85: 0x9EFC,
	          0xEA86: 0x9EFD,
	          0xEA87: 0x9F07,
	          0xEA88: 0x9F08,
	          0xEA89: 0x76B7,
	          0xEA8A: 0x9F15,
	          0xEA8B: 0x9F21,
	          0xEA8C: 0x9F2C,
	          0xEA8D: 0x9F3E,
	          0xEA8E: 0x9F4A,
	          0xEA8F: 0x9F52,
	          0xEA90: 0x9F54,
	          0xEA91: 0x9F63,
	          0xEA92: 0x9F5F,
	          0xEA93: 0x9F60,
	          0xEA94: 0x9F61,
	          0xEA95: 0x9F66,
	          0xEA96: 0x9F67,
	          0xEA97: 0x9F6C,
	          0xEA98: 0x9F6A,
	          0xEA99: 0x9F77,
	          0xEA9A: 0x9F72,
	          0xEA9B: 0x9F76,
	          0xEA9C: 0x9F95,
	          0xEA9D: 0x9F9C,
	          0xEA9E: 0x9FA0,
	          0xEA9F: 0x582F,
	          0xEAA0: 0x69C7,
	          0xEAA1: 0x9059,
	          0xEAA2: 0x7464,
	          0xEAA3: 0x51DC,
	          0xEAA4: 0x7199
	        };
	        /***/
	      },
	      /* 9 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var GenericGF_1 = __webpack_require__(1);

	        var GenericGFPoly_1 = __webpack_require__(2);

	        function runEuclideanAlgorithm(field, a, b, R) {
	          var _a; // Assume a's degree is >= b's


	          if (a.degree() < b.degree()) {
	            _a = [b, a], a = _a[0], b = _a[1];
	          }

	          var rLast = a;
	          var r = b;
	          var tLast = field.zero;
	          var t = field.one; // Run Euclidean algorithm until r's degree is less than R/2

	          while (r.degree() >= R / 2) {
	            var rLastLast = rLast;
	            var tLastLast = tLast;
	            rLast = r;
	            tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r

	            if (rLast.isZero()) {
	              // Euclidean algorithm already terminated?
	              return null;
	            }

	            r = rLastLast;
	            var q = field.zero;
	            var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
	            var dltInverse = field.inverse(denominatorLeadingTerm);

	            while (r.degree() >= rLast.degree() && !r.isZero()) {
	              var degreeDiff = r.degree() - rLast.degree();
	              var scale = field.multiply(r.getCoefficient(r.degree()), dltInverse);
	              q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
	              r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
	            }

	            t = q.multiplyPoly(tLast).addOrSubtract(tLastLast);

	            if (r.degree() >= rLast.degree()) {
	              return null;
	            }
	          }

	          var sigmaTildeAtZero = t.getCoefficient(0);

	          if (sigmaTildeAtZero === 0) {
	            return null;
	          }

	          var inverse = field.inverse(sigmaTildeAtZero);
	          return [t.multiply(inverse), r.multiply(inverse)];
	        }

	        function findErrorLocations(field, errorLocator) {
	          // This is a direct application of Chien's search
	          var numErrors = errorLocator.degree();

	          if (numErrors === 1) {
	            return [errorLocator.getCoefficient(1)];
	          }

	          var result = new Array(numErrors);
	          var errorCount = 0;

	          for (var i = 1; i < field.size && errorCount < numErrors; i++) {
	            if (errorLocator.evaluateAt(i) === 0) {
	              result[errorCount] = field.inverse(i);
	              errorCount++;
	            }
	          }

	          if (errorCount !== numErrors) {
	            return null;
	          }

	          return result;
	        }

	        function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
	          // This is directly applying Forney's Formula
	          var s = errorLocations.length;
	          var result = new Array(s);

	          for (var i = 0; i < s; i++) {
	            var xiInverse = field.inverse(errorLocations[i]);
	            var denominator = 1;

	            for (var j = 0; j < s; j++) {
	              if (i !== j) {
	                denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j], xiInverse)));
	              }
	            }

	            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));

	            if (field.generatorBase !== 0) {
	              result[i] = field.multiply(result[i], xiInverse);
	            }
	          }

	          return result;
	        }

	        function decode(bytes, twoS) {
	          var outputBytes = new Uint8ClampedArray(bytes.length);
	          outputBytes.set(bytes);
	          var field = new GenericGF_1.default(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1

	          var poly = new GenericGFPoly_1.default(field, outputBytes);
	          var syndromeCoefficients = new Uint8ClampedArray(twoS);
	          var error = false;

	          for (var s = 0; s < twoS; s++) {
	            var evaluation = poly.evaluateAt(field.exp(s + field.generatorBase));
	            syndromeCoefficients[syndromeCoefficients.length - 1 - s] = evaluation;

	            if (evaluation !== 0) {
	              error = true;
	            }
	          }

	          if (!error) {
	            return outputBytes;
	          }

	          var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
	          var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);

	          if (sigmaOmega === null) {
	            return null;
	          }

	          var errorLocations = findErrorLocations(field, sigmaOmega[0]);

	          if (errorLocations == null) {
	            return null;
	          }

	          var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);

	          for (var i = 0; i < errorLocations.length; i++) {
	            var position = outputBytes.length - 1 - field.log(errorLocations[i]);

	            if (position < 0) {
	              return null;
	            }

	            outputBytes[position] = GenericGF_1.addOrSubtractGF(outputBytes[position], errorMagnitudes[i]);
	          }

	          return outputBytes;
	        }

	        exports.decode = decode;
	        /***/
	      },
	      /* 10 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });
	        exports.VERSIONS = [{
	          infoBits: null,
	          versionNumber: 1,
	          alignmentPatternCenters: [],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 7,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 19
	            }]
	          }, {
	            ecCodewordsPerBlock: 10,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 16
	            }]
	          }, {
	            ecCodewordsPerBlock: 13,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 13
	            }]
	          }, {
	            ecCodewordsPerBlock: 17,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 9
	            }]
	          }]
	        }, {
	          infoBits: null,
	          versionNumber: 2,
	          alignmentPatternCenters: [6, 18],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 10,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 34
	            }]
	          }, {
	            ecCodewordsPerBlock: 16,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 28
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 22
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: null,
	          versionNumber: 3,
	          alignmentPatternCenters: [6, 22],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 15,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 55
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 44
	            }]
	          }, {
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 17
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: null,
	          versionNumber: 4,
	          alignmentPatternCenters: [6, 26],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 20,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 80
	            }]
	          }, {
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 32
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 24
	            }]
	          }, {
	            ecCodewordsPerBlock: 16,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 9
	            }]
	          }]
	        }, {
	          infoBits: null,
	          versionNumber: 5,
	          alignmentPatternCenters: [6, 30],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 108
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 43
	            }]
	          }, {
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 16
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 11
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 12
	            }]
	          }]
	        }, {
	          infoBits: null,
	          versionNumber: 6,
	          alignmentPatternCenters: [6, 34],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 68
	            }]
	          }, {
	            ecCodewordsPerBlock: 16,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 27
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 19
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 15
	            }]
	          }]
	        }, {
	          infoBits: 0x07C94,
	          versionNumber: 7,
	          alignmentPatternCenters: [6, 22, 38],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 20,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 78
	            }]
	          }, {
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 31
	            }]
	          }, {
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 14
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 15
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 13
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 14
	            }]
	          }]
	        }, {
	          infoBits: 0x085BC,
	          versionNumber: 8,
	          alignmentPatternCenters: [6, 24, 42],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 97
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 38
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 39
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 18
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 19
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 14
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 15
	            }]
	          }]
	        }, {
	          infoBits: 0x09A99,
	          versionNumber: 9,
	          alignmentPatternCenters: [6, 26, 46],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 36
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 37
	            }]
	          }, {
	            ecCodewordsPerBlock: 20,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 17
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 12
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: 0x0A4D3,
	          versionNumber: 10,
	          alignmentPatternCenters: [6, 28, 50],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 18,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 68
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 69
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 43
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 44
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 19
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 20
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x0BBF6,
	          versionNumber: 11,
	          alignmentPatternCenters: [6, 30, 54],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 20,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 81
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 50
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 51
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 22
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 23
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 12
	            }, {
	              numBlocks: 8,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: 0x0C762,
	          versionNumber: 12,
	          alignmentPatternCenters: [6, 32, 58],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 92
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 93
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 36
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 37
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 20
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 21
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 7,
	              dataCodewordsPerBlock: 14
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 15
	            }]
	          }]
	        }, {
	          infoBits: 0x0D847,
	          versionNumber: 13,
	          alignmentPatternCenters: [6, 34, 62],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 107
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 37
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 38
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 20
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 21
	            }]
	          }, {
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 12,
	              dataCodewordsPerBlock: 11
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 12
	            }]
	          }]
	        }, {
	          infoBits: 0x0E60D,
	          versionNumber: 14,
	          alignmentPatternCenters: [6, 26, 46, 66],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 115
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 40
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 41
	            }]
	          }, {
	            ecCodewordsPerBlock: 20,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 17
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 12
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: 0x0F928,
	          versionNumber: 15,
	          alignmentPatternCenters: [6, 26, 48, 70],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 22,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 87
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 88
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 41
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 42
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 12
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: 0x10B78,
	          versionNumber: 16,
	          alignmentPatternCenters: [6, 26, 50, 74],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 98
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 99
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 7,
	              dataCodewordsPerBlock: 45
	            }, {
	              numBlocks: 3,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 15,
	              dataCodewordsPerBlock: 19
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 20
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 13,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1145D,
	          versionNumber: 17,
	          alignmentPatternCenters: [6, 30, 54, 78],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 107
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 108
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 10,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 22
	            }, {
	              numBlocks: 15,
	              dataCodewordsPerBlock: 23
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 14
	            }, {
	              numBlocks: 17,
	              dataCodewordsPerBlock: 15
	            }]
	          }]
	        }, {
	          infoBits: 0x12A17,
	          versionNumber: 18,
	          alignmentPatternCenters: [6, 30, 56, 82],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 120
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 121
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 9,
	              dataCodewordsPerBlock: 43
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 44
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 22
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 23
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 14
	            }, {
	              numBlocks: 19,
	              dataCodewordsPerBlock: 15
	            }]
	          }]
	        }, {
	          infoBits: 0x13532,
	          versionNumber: 19,
	          alignmentPatternCenters: [6, 30, 58, 86],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 113
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 114
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 44
	            }, {
	              numBlocks: 11,
	              dataCodewordsPerBlock: 45
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 21
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 22
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 9,
	              dataCodewordsPerBlock: 13
	            }, {
	              numBlocks: 16,
	              dataCodewordsPerBlock: 14
	            }]
	          }]
	        }, {
	          infoBits: 0x149A6,
	          versionNumber: 20,
	          alignmentPatternCenters: [6, 34, 62, 90],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 107
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 108
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 41
	            }, {
	              numBlocks: 13,
	              dataCodewordsPerBlock: 42
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 15,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 15,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x15683,
	          versionNumber: 21,
	          alignmentPatternCenters: [6, 28, 50, 72, 94],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 116
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 117
	            }]
	          }, {
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 42
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 22
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 23
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 17
	            }]
	          }]
	        }, {
	          infoBits: 0x168C9,
	          versionNumber: 22,
	          alignmentPatternCenters: [6, 26, 50, 74, 98],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 111
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 112
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 7,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 16,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 24,
	            ecBlocks: [{
	              numBlocks: 34,
	              dataCodewordsPerBlock: 13
	            }]
	          }]
	        }, {
	          infoBits: 0x177EC,
	          versionNumber: 23,
	          alignmentPatternCenters: [6, 30, 54, 74, 102],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 121
	            }, {
	              numBlocks: 5,
	              dataCodewordsPerBlock: 122
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 16,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x18EC4,
	          versionNumber: 24,
	          alignmentPatternCenters: [6, 28, 54, 80, 106],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 117
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 118
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 45
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 16,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 30,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 17
	            }]
	          }]
	        }, {
	          infoBits: 0x191E1,
	          versionNumber: 25,
	          alignmentPatternCenters: [6, 32, 58, 84, 110],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 26,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 106
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 107
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 13,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 7,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 22,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 22,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 13,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1AFAB,
	          versionNumber: 26,
	          alignmentPatternCenters: [6, 30, 58, 86, 114],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 10,
	              dataCodewordsPerBlock: 114
	            }, {
	              numBlocks: 2,
	              dataCodewordsPerBlock: 115
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 28,
	              dataCodewordsPerBlock: 22
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 23
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 33,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 17
	            }]
	          }]
	        }, {
	          infoBits: 0x1B08E,
	          versionNumber: 27,
	          alignmentPatternCenters: [6, 34, 62, 90, 118],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 122
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 123
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 22,
	              dataCodewordsPerBlock: 45
	            }, {
	              numBlocks: 3,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 8,
	              dataCodewordsPerBlock: 23
	            }, {
	              numBlocks: 26,
	              dataCodewordsPerBlock: 24
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 12,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 28,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1CC1A,
	          versionNumber: 28,
	          alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 117
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 118
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 3,
	              dataCodewordsPerBlock: 45
	            }, {
	              numBlocks: 23,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 31,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 31,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1D33F,
	          versionNumber: 29,
	          alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 7,
	              dataCodewordsPerBlock: 116
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 117
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 21,
	              dataCodewordsPerBlock: 45
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 46
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 1,
	              dataCodewordsPerBlock: 23
	            }, {
	              numBlocks: 37,
	              dataCodewordsPerBlock: 24
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 26,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1ED75,
	          versionNumber: 30,
	          alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 5,
	              dataCodewordsPerBlock: 115
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 15,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 25,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 23,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 25,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x1F250,
	          versionNumber: 31,
	          alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 13,
	              dataCodewordsPerBlock: 115
	            }, {
	              numBlocks: 3,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 29,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 42,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 23,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 28,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x209D5,
	          versionNumber: 32,
	          alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 115
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 10,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 23,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 10,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 35,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 35,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x216F0,
	          versionNumber: 33,
	          alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 115
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 14,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 21,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 29,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 19,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 11,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 46,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x228BA,
	          versionNumber: 34,
	          alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 13,
	              dataCodewordsPerBlock: 115
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 116
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 14,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 23,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 44,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 59,
	              dataCodewordsPerBlock: 16
	            }, {
	              numBlocks: 1,
	              dataCodewordsPerBlock: 17
	            }]
	          }]
	        }, {
	          infoBits: 0x2379F,
	          versionNumber: 35,
	          alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 12,
	              dataCodewordsPerBlock: 121
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 122
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 12,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 26,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 39,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 22,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 41,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x24B0B,
	          versionNumber: 36,
	          alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 121
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 122
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 6,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 34,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 46,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 2,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 64,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x2542E,
	          versionNumber: 37,
	          alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 17,
	              dataCodewordsPerBlock: 122
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 123
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 29,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 49,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 10,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 24,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 46,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x26A64,
	          versionNumber: 38,
	          alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 4,
	              dataCodewordsPerBlock: 122
	            }, {
	              numBlocks: 18,
	              dataCodewordsPerBlock: 123
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 13,
	              dataCodewordsPerBlock: 46
	            }, {
	              numBlocks: 32,
	              dataCodewordsPerBlock: 47
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 48,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 14,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 42,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 32,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x27541,
	          versionNumber: 39,
	          alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 20,
	              dataCodewordsPerBlock: 117
	            }, {
	              numBlocks: 4,
	              dataCodewordsPerBlock: 118
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 40,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 7,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 43,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 22,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 10,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 67,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }, {
	          infoBits: 0x28C69,
	          versionNumber: 40,
	          alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
	          errorCorrectionLevels: [{
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 19,
	              dataCodewordsPerBlock: 118
	            }, {
	              numBlocks: 6,
	              dataCodewordsPerBlock: 119
	            }]
	          }, {
	            ecCodewordsPerBlock: 28,
	            ecBlocks: [{
	              numBlocks: 18,
	              dataCodewordsPerBlock: 47
	            }, {
	              numBlocks: 31,
	              dataCodewordsPerBlock: 48
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 34,
	              dataCodewordsPerBlock: 24
	            }, {
	              numBlocks: 34,
	              dataCodewordsPerBlock: 25
	            }]
	          }, {
	            ecCodewordsPerBlock: 30,
	            ecBlocks: [{
	              numBlocks: 20,
	              dataCodewordsPerBlock: 15
	            }, {
	              numBlocks: 61,
	              dataCodewordsPerBlock: 16
	            }]
	          }]
	        }];
	        /***/
	      },
	      /* 11 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });

	        var BitMatrix_1 = __webpack_require__(0);

	        function squareToQuadrilateral(p1, p2, p3, p4) {
	          var dx3 = p1.x - p2.x + p3.x - p4.x;
	          var dy3 = p1.y - p2.y + p3.y - p4.y;

	          if (dx3 === 0 && dy3 === 0) {
	            // Affine
	            return {
	              a11: p2.x - p1.x,
	              a12: p2.y - p1.y,
	              a13: 0,
	              a21: p3.x - p2.x,
	              a22: p3.y - p2.y,
	              a23: 0,
	              a31: p1.x,
	              a32: p1.y,
	              a33: 1
	            };
	          } else {
	            var dx1 = p2.x - p3.x;
	            var dx2 = p4.x - p3.x;
	            var dy1 = p2.y - p3.y;
	            var dy2 = p4.y - p3.y;
	            var denominator = dx1 * dy2 - dx2 * dy1;
	            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
	            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
	            return {
	              a11: p2.x - p1.x + a13 * p2.x,
	              a12: p2.y - p1.y + a13 * p2.y,
	              a13: a13,
	              a21: p4.x - p1.x + a23 * p4.x,
	              a22: p4.y - p1.y + a23 * p4.y,
	              a23: a23,
	              a31: p1.x,
	              a32: p1.y,
	              a33: 1
	            };
	          }
	        }

	        function quadrilateralToSquare(p1, p2, p3, p4) {
	          // Here, the adjoint serves as the inverse:
	          var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
	          return {
	            a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
	            a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
	            a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
	            a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
	            a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
	            a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
	            a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
	            a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
	            a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21
	          };
	        }

	        function times(a, b) {
	          return {
	            a11: a.a11 * b.a11 + a.a21 * b.a12 + a.a31 * b.a13,
	            a12: a.a12 * b.a11 + a.a22 * b.a12 + a.a32 * b.a13,
	            a13: a.a13 * b.a11 + a.a23 * b.a12 + a.a33 * b.a13,
	            a21: a.a11 * b.a21 + a.a21 * b.a22 + a.a31 * b.a23,
	            a22: a.a12 * b.a21 + a.a22 * b.a22 + a.a32 * b.a23,
	            a23: a.a13 * b.a21 + a.a23 * b.a22 + a.a33 * b.a23,
	            a31: a.a11 * b.a31 + a.a21 * b.a32 + a.a31 * b.a33,
	            a32: a.a12 * b.a31 + a.a22 * b.a32 + a.a32 * b.a33,
	            a33: a.a13 * b.a31 + a.a23 * b.a32 + a.a33 * b.a33
	          };
	        }

	        function extract(image, location) {
	          var qToS = quadrilateralToSquare({
	            x: 3.5,
	            y: 3.5
	          }, {
	            x: location.dimension - 3.5,
	            y: 3.5
	          }, {
	            x: location.dimension - 6.5,
	            y: location.dimension - 6.5
	          }, {
	            x: 3.5,
	            y: location.dimension - 3.5
	          });
	          var sToQ = squareToQuadrilateral(location.topLeft, location.topRight, location.alignmentPattern, location.bottomLeft);
	          var transform = times(sToQ, qToS);
	          var matrix = BitMatrix_1.BitMatrix.createEmpty(location.dimension, location.dimension);

	          var mappingFunction = function mappingFunction(x, y) {
	            var denominator = transform.a13 * x + transform.a23 * y + transform.a33;
	            return {
	              x: (transform.a11 * x + transform.a21 * y + transform.a31) / denominator,
	              y: (transform.a12 * x + transform.a22 * y + transform.a32) / denominator
	            };
	          };

	          for (var y = 0; y < location.dimension; y++) {
	            for (var x = 0; x < location.dimension; x++) {
	              var xValue = x + 0.5;
	              var yValue = y + 0.5;
	              var sourcePixel = mappingFunction(xValue, yValue);
	              matrix.set(x, y, image.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
	            }
	          }

	          return {
	            matrix: matrix,
	            mappingFunction: mappingFunction
	          };
	        }

	        exports.extract = extract;
	        /***/
	      },
	      /* 12 */

	      /***/
	      function (module, exports, __webpack_require__) {

	        Object.defineProperty(exports, "__esModule", {
	          value: true
	        });
	        var MAX_FINDERPATTERNS_TO_SEARCH = 4;
	        var MIN_QUAD_RATIO = 0.5;
	        var MAX_QUAD_RATIO = 1.5;

	        var distance = function distance(a, b) {
	          return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
	        };

	        function sum(values) {
	          return values.reduce(function (a, b) {
	            return a + b;
	          });
	        } // Takes three finder patterns and organizes them into topLeft, topRight, etc


	        function reorderFinderPatterns(pattern1, pattern2, pattern3) {
	          var _a, _b, _c, _d; // Find distances between pattern centers


	          var oneTwoDistance = distance(pattern1, pattern2);
	          var twoThreeDistance = distance(pattern2, pattern3);
	          var oneThreeDistance = distance(pattern1, pattern3);
	          var bottomLeft;
	          var topLeft;
	          var topRight; // Assume one closest to other two is B; A and C will just be guesses at first

	          if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
	            _a = [pattern2, pattern1, pattern3], bottomLeft = _a[0], topLeft = _a[1], topRight = _a[2];
	          } else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
	            _b = [pattern1, pattern2, pattern3], bottomLeft = _b[0], topLeft = _b[1], topRight = _b[2];
	          } else {
	            _c = [pattern1, pattern3, pattern2], bottomLeft = _c[0], topLeft = _c[1], topRight = _c[2];
	          } // Use cross product to figure out whether bottomLeft (A) and topRight (C) are correct or flipped in relation to topLeft (B)
	          // This asks whether BC x BA has a positive z component, which is the arrangement we want. If it's negative, then
	          // we've got it flipped around and should swap topRight and bottomLeft.


	          if ((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) - (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) < 0) {
	            _d = [topRight, bottomLeft], bottomLeft = _d[0], topRight = _d[1];
	          }

	          return {
	            bottomLeft: bottomLeft,
	            topLeft: topLeft,
	            topRight: topRight
	          };
	        } // Computes the dimension (number of modules on a side) of the QR Code based on the position of the finder patterns


	        function computeDimension(topLeft, topRight, bottomLeft, matrix) {
	          var moduleSize = (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1
	          sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 + sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 + sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;

	          if (moduleSize < 1) {
	            throw new Error("Invalid module size");
	          }

	          var topDimension = Math.round(distance(topLeft, topRight) / moduleSize);
	          var sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);
	          var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;

	          switch (dimension % 4) {
	            case 0:
	              dimension++;
	              break;

	            case 2:
	              dimension--;
	              break;
	          }

	          return {
	            dimension: dimension,
	            moduleSize: moduleSize
	          };
	        } // Takes an origin point and an end point and counts the sizes of the black white run from the origin towards the end point.
	        // Returns an array of elements, representing the pixel size of the black white run.
	        // Uses a variant of http://en.wikipedia.org/wiki/Bresenham's_line_algorithm


	        function countBlackWhiteRunTowardsPoint(origin, end, matrix, length) {
	          var switchPoints = [{
	            x: Math.floor(origin.x),
	            y: Math.floor(origin.y)
	          }];
	          var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
	          var fromX;
	          var fromY;
	          var toX;
	          var toY;

	          if (steep) {
	            fromX = Math.floor(origin.y);
	            fromY = Math.floor(origin.x);
	            toX = Math.floor(end.y);
	            toY = Math.floor(end.x);
	          } else {
	            fromX = Math.floor(origin.x);
	            fromY = Math.floor(origin.y);
	            toX = Math.floor(end.x);
	            toY = Math.floor(end.y);
	          }

	          var dx = Math.abs(toX - fromX);
	          var dy = Math.abs(toY - fromY);
	          var error = Math.floor(-dx / 2);
	          var xStep = fromX < toX ? 1 : -1;
	          var yStep = fromY < toY ? 1 : -1;
	          var currentPixel = true; // Loop up until x == toX, but not beyond

	          for (var x = fromX, y = fromY; x !== toX + xStep; x += xStep) {
	            // Does current pixel mean we have moved white to black or vice versa?
	            // Scanning black in state 0,2 and white in state 1, so if we find the wrong
	            // color, advance to next state or end if we are in state 2 already
	            var realX = steep ? y : x;
	            var realY = steep ? x : y;

	            if (matrix.get(realX, realY) !== currentPixel) {
	              currentPixel = !currentPixel;
	              switchPoints.push({
	                x: realX,
	                y: realY
	              });

	              if (switchPoints.length === length + 1) {
	                break;
	              }
	            }

	            error += dy;

	            if (error > 0) {
	              if (y === toY) {
	                break;
	              }

	              y += yStep;
	              error -= dx;
	            }
	          }

	          var distances = [];

	          for (var i = 0; i < length; i++) {
	            if (switchPoints[i] && switchPoints[i + 1]) {
	              distances.push(distance(switchPoints[i], switchPoints[i + 1]));
	            } else {
	              distances.push(0);
	            }
	          }

	          return distances;
	        } // Takes an origin point and an end point and counts the sizes of the black white run in the origin point
	        // along the line that intersects with the end point. Returns an array of elements, representing the pixel sizes
	        // of the black white run. Takes a length which represents the number of switches from black to white to look for.


	        function countBlackWhiteRun(origin, end, matrix, length) {
	          var _a;

	          var rise = end.y - origin.y;
	          var run = end.x - origin.x;
	          var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length / 2));
	          var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, {
	            x: origin.x - run,
	            y: origin.y - rise
	          }, matrix, Math.ceil(length / 2));
	          var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1; // Substract one so we don't double count a pixel

	          return (_a = awayFromEnd.concat(middleValue)).concat.apply(_a, towardsEnd);
	        } // Takes in a black white run and an array of expected ratios. Returns the average size of the run as well as the "error" -
	        // that is the amount the run diverges from the expected ratio


	        function scoreBlackWhiteRun(sequence, ratios) {
	          var averageSize = sum(sequence) / sum(ratios);
	          var error = 0;
	          ratios.forEach(function (ratio, i) {
	            error += Math.pow(sequence[i] - ratio * averageSize, 2);
	          });
	          return {
	            averageSize: averageSize,
	            error: error
	          };
	        } // Takes an X,Y point and an array of sizes and scores the point against those ratios.
	        // For example for a finder pattern takes the ratio list of 1:1:3:1:1 and checks horizontal, vertical and diagonal ratios
	        // against that.


	        function scorePattern(point, ratios, matrix) {
	          try {
	            var horizontalRun = countBlackWhiteRun(point, {
	              x: -1,
	              y: point.y
	            }, matrix, ratios.length);
	            var verticalRun = countBlackWhiteRun(point, {
	              x: point.x,
	              y: -1
	            }, matrix, ratios.length);
	            var topLeftPoint = {
	              x: Math.max(0, point.x - point.y) - 1,
	              y: Math.max(0, point.y - point.x) - 1
	            };
	            var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
	            var bottomLeftPoint = {
	              x: Math.min(matrix.width, point.x + point.y) + 1,
	              y: Math.min(matrix.height, point.y + point.x) + 1
	            };
	            var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
	            var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
	            var vertError = scoreBlackWhiteRun(verticalRun, ratios);
	            var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
	            var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
	            var ratioError = Math.sqrt(horzError.error * horzError.error + vertError.error * vertError.error + diagDownError.error * diagDownError.error + diagUpError.error * diagUpError.error);
	            var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
	            var sizeError = (Math.pow(horzError.averageSize - avgSize, 2) + Math.pow(vertError.averageSize - avgSize, 2) + Math.pow(diagDownError.averageSize - avgSize, 2) + Math.pow(diagUpError.averageSize - avgSize, 2)) / avgSize;
	            return ratioError + sizeError;
	          } catch (_a) {
	            return Infinity;
	          }
	        }

	        function recenterLocation(matrix, p) {
	          var leftX = Math.round(p.x);

	          while (matrix.get(leftX, Math.round(p.y))) {
	            leftX--;
	          }

	          var rightX = Math.round(p.x);

	          while (matrix.get(rightX, Math.round(p.y))) {
	            rightX++;
	          }

	          var x = (leftX + rightX) / 2;
	          var topY = Math.round(p.y);

	          while (matrix.get(Math.round(x), topY)) {
	            topY--;
	          }

	          var bottomY = Math.round(p.y);

	          while (matrix.get(Math.round(x), bottomY)) {
	            bottomY++;
	          }

	          var y = (topY + bottomY) / 2;
	          return {
	            x: x,
	            y: y
	          };
	        }

	        function locate(matrix) {
	          var finderPatternQuads = [];
	          var activeFinderPatternQuads = [];
	          var alignmentPatternQuads = [];
	          var activeAlignmentPatternQuads = [];

	          var _loop_1 = function _loop_1(y) {
	            var length_1 = 0;
	            var lastBit = false;
	            var scans = [0, 0, 0, 0, 0];

	            var _loop_2 = function _loop_2(x) {
	              var v = matrix.get(x, y);

	              if (v === lastBit) {
	                length_1++;
	              } else {
	                scans = [scans[1], scans[2], scans[3], scans[4], length_1];
	                length_1 = 1;
	                lastBit = v; // Do the last 5 color changes ~ match the expected ratio for a finder pattern? 1:1:3:1:1 of b:w:b:w:b

	                var averageFinderPatternBlocksize = sum(scans) / 7;
	                var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize && Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && !v; // And make sure the current pixel is white since finder patterns are bordered in white
	                // Do the last 3 color changes ~ match the expected ratio for an alignment pattern? 1:1:1 of w:b:w

	                var averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;
	                var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && v; // Is the current pixel black since alignment patterns are bordered in black

	                if (validFinderPattern) {
	                  // Compute the start and end x values of the large center black square
	                  var endX_1 = x - scans[3] - scans[4];
	                  var startX_1 = endX_1 - scans[2];
	                  var line = {
	                    startX: startX_1,
	                    endX: endX_1,
	                    y: y
	                  }; // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
	                  // that line as the starting point.

	                  var matchingQuads = activeFinderPatternQuads.filter(function (q) {
	                    return startX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || endX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || startX_1 <= q.bottom.startX && endX_1 >= q.bottom.endX && scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO;
	                  });

	                  if (matchingQuads.length > 0) {
	                    matchingQuads[0].bottom = line;
	                  } else {
	                    activeFinderPatternQuads.push({
	                      top: line,
	                      bottom: line
	                    });
	                  }
	                }

	                if (validAlignmentPattern) {
	                  // Compute the start and end x values of the center black square
	                  var endX_2 = x - scans[4];
	                  var startX_2 = endX_2 - scans[3];
	                  var line = {
	                    startX: startX_2,
	                    y: y,
	                    endX: endX_2
	                  }; // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
	                  // that line as the starting point.

	                  var matchingQuads = activeAlignmentPatternQuads.filter(function (q) {
	                    return startX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || endX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || startX_2 <= q.bottom.startX && endX_2 >= q.bottom.endX && scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO;
	                  });

	                  if (matchingQuads.length > 0) {
	                    matchingQuads[0].bottom = line;
	                  } else {
	                    activeAlignmentPatternQuads.push({
	                      top: line,
	                      bottom: line
	                    });
	                  }
	                }
	              }
	            };

	            for (var x = -1; x <= matrix.width; x++) {
	              _loop_2(x);
	            }

	            finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function (q) {
	              return q.bottom.y !== y && q.bottom.y - q.top.y >= 2;
	            }));
	            activeFinderPatternQuads = activeFinderPatternQuads.filter(function (q) {
	              return q.bottom.y === y;
	            });
	            alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function (q) {
	              return q.bottom.y !== y;
	            }));
	            activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function (q) {
	              return q.bottom.y === y;
	            });
	          };

	          for (var y = 0; y <= matrix.height; y++) {
	            _loop_1(y);
	          }

	          finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function (q) {
	            return q.bottom.y - q.top.y >= 2;
	          }));
	          alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
	          var finderPatternGroups = finderPatternQuads.filter(function (q) {
	            return q.bottom.y - q.top.y >= 2;
	          }) // All quads must be at least 2px tall since the center square is larger than a block
	          .map(function (q) {
	            var x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
	            var y = (q.top.y + q.bottom.y + 1) / 2;

	            if (!matrix.get(Math.round(x), Math.round(y))) {
	              return;
	            }

	            var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
	            var size = sum(lengths) / lengths.length;
	            var score = scorePattern({
	              x: Math.round(x),
	              y: Math.round(y)
	            }, [1, 1, 3, 1, 1], matrix);
	            return {
	              score: score,
	              x: x,
	              y: y,
	              size: size
	            };
	          }).filter(function (q) {
	            return !!q;
	          }) // Filter out any rejected quads from above
	          .sort(function (a, b) {
	            return a.score - b.score;
	          }) // Now take the top finder pattern options and try to find 2 other options with a similar size.
	          .map(function (point, i, finderPatterns) {
	            if (i > MAX_FINDERPATTERNS_TO_SEARCH) {
	              return null;
	            }

	            var otherPoints = finderPatterns.filter(function (p, ii) {
	              return i !== ii;
	            }).map(function (p) {
	              return {
	                x: p.x,
	                y: p.y,
	                score: p.score + Math.pow(p.size - point.size, 2) / point.size,
	                size: p.size
	              };
	            }).sort(function (a, b) {
	              return a.score - b.score;
	            });

	            if (otherPoints.length < 2) {
	              return null;
	            }

	            var score = point.score + otherPoints[0].score + otherPoints[1].score;
	            return {
	              points: [point].concat(otherPoints.slice(0, 2)),
	              score: score
	            };
	          }).filter(function (q) {
	            return !!q;
	          }) // Filter out any rejected finder patterns from above
	          .sort(function (a, b) {
	            return a.score - b.score;
	          });

	          if (finderPatternGroups.length === 0) {
	            return null;
	          }

	          var _a = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]),
	              topRight = _a.topRight,
	              topLeft = _a.topLeft,
	              bottomLeft = _a.bottomLeft;

	          var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
	          var result = [];

	          if (alignment) {
	            result.push({
	              alignmentPattern: {
	                x: alignment.alignmentPattern.x,
	                y: alignment.alignmentPattern.y
	              },
	              bottomLeft: {
	                x: bottomLeft.x,
	                y: bottomLeft.y
	              },
	              dimension: alignment.dimension,
	              topLeft: {
	                x: topLeft.x,
	                y: topLeft.y
	              },
	              topRight: {
	                x: topRight.x,
	                y: topRight.y
	              }
	            });
	          } // We normally use the center of the quads as the location of the tracking points, which is optimal for most cases and will account
	          // for a skew in the image. However, In some cases, a slight skew might not be real and instead be caused by image compression
	          // errors and/or low resolution. For those cases, we'd be better off centering the point exactly in the middle of the black area. We
	          // compute and return the location data for the naively centered points as it is little additional work and allows for multiple
	          // attempts at decoding harder images.


	          var midTopRight = recenterLocation(matrix, topRight);
	          var midTopLeft = recenterLocation(matrix, topLeft);
	          var midBottomLeft = recenterLocation(matrix, bottomLeft);
	          var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);

	          if (centeredAlignment) {
	            result.push({
	              alignmentPattern: {
	                x: centeredAlignment.alignmentPattern.x,
	                y: centeredAlignment.alignmentPattern.y
	              },
	              bottomLeft: {
	                x: midBottomLeft.x,
	                y: midBottomLeft.y
	              },
	              topLeft: {
	                x: midTopLeft.x,
	                y: midTopLeft.y
	              },
	              topRight: {
	                x: midTopRight.x,
	                y: midTopRight.y
	              },
	              dimension: centeredAlignment.dimension
	            });
	          }

	          if (result.length === 0) {
	            return null;
	          }

	          return result;
	        }

	        exports.locate = locate;

	        function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
	          var _a; // Now that we've found the three finder patterns we can determine the blockSize and the size of the QR code.
	          // We'll use these to help find the alignment pattern but also later when we do the extraction.


	          var dimension;
	          var moduleSize;

	          try {
	            _a = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a.dimension, moduleSize = _a.moduleSize;
	          } catch (e) {
	            return null;
	          } // Now find the alignment pattern


	          var bottomRightFinderPattern = {
	            x: topRight.x - topLeft.x + bottomLeft.x,
	            y: topRight.y - topLeft.y + bottomLeft.y
	          };
	          var modulesBetweenFinderPatterns = (distance(topLeft, bottomLeft) + distance(topLeft, topRight)) / 2 / moduleSize;
	          var correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;
	          var expectedAlignmentPattern = {
	            x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
	            y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y)
	          };
	          var alignmentPatterns = alignmentPatternQuads.map(function (q) {
	            var x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
	            var y = (q.top.y + q.bottom.y + 1) / 2;

	            if (!matrix.get(Math.floor(x), Math.floor(y))) {
	              return;
	            }

	            var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
	            sum(lengths) / lengths.length;
	            var sizeScore = scorePattern({
	              x: Math.floor(x),
	              y: Math.floor(y)
	            }, [1, 1, 1], matrix);
	            var score = sizeScore + distance({
	              x: x,
	              y: y
	            }, expectedAlignmentPattern);
	            return {
	              x: x,
	              y: y,
	              score: score
	            };
	          }).filter(function (v) {
	            return !!v;
	          }).sort(function (a, b) {
	            return a.score - b.score;
	          }); // If there are less than 15 modules between finder patterns it's a version 1 QR code and as such has no alignmemnt pattern
	          // so we can only use our best guess.

	          var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
	          return {
	            alignmentPattern: alignmentPattern,
	            dimension: dimension
	          };
	        }
	        /***/

	      }
	      /******/
	      ])["default"]
	    );
	  });
	});
	var jsQR$1 = /*@__PURE__*/getDefaultExportFromCjs(jsQR);

	var console_1$c = globals.console;
	var file$Z = "src/widgets/QRScanner.svelte";

	function create_fragment$Z(ctx) {
	  var div4;
	  var div3;
	  var div0;
	  var t0;
	  var t1;
	  var div2;
	  var div1;
	  var video;
	  var block = {
	    c: function create() {
	      div4 = element("div");
	      div3 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div2 = element("div");
	      div1 = element("div");
	      video = element("video");
	      attr_dev(div0, "class", "kai-dialog-header svelte-1bpnhjc");
	      add_location(div0, file$Z, 83, 4, 2772);
	      attr_dev(video, "height", "320");
	      attr_dev(video, "width", "240");
	      video.autoplay = true;
	      add_location(video, file$Z, 86, 8, 2909);
	      set_style(div1, "overflow", "hidden");
	      set_style(div1, "height", "212px");
	      add_location(div1, file$Z, 85, 6, 2857);
	      attr_dev(div2, "class", "kai-dialog-body svelte-1bpnhjc");
	      add_location(div2, file$Z, 84, 4, 2821);
	      attr_dev(div3, "class", "kai-dialog-content svelte-1bpnhjc");
	      add_location(div3, file$Z, 82, 2, 2735);
	      attr_dev(div4, "class", "kai-dialog svelte-1bpnhjc");
	      add_location(div4, file$Z, 81, 0, 2708);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div4, anchor);
	      append_dev(div4, div3);
	      append_dev(div3, div0);
	      append_dev(div0, t0);
	      append_dev(div3, t1);
	      append_dev(div3, div2);
	      append_dev(div2, div1);
	      append_dev(div1, video);
	      /*video_binding*/

	      ctx[6](video);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div4);
	      /*video_binding*/

	      ctx[6](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Z.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$Z($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('QRScanner', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Link Device' : _$$props$title;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? evt => {} : _$$props$onBackspace;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  var _$$props$callback = $$props.callback,
	      callback = _$$props$callback === void 0 ? buf => {} : _$$props$callback;
	  var nodeRef;
	  var softwareKey;
	  var scanning = null;
	  var navOptions = {
	    softkeyRightListener(evt) {
	      onBackspace(evt);
	    },

	    backspaceListener(evt) {
	      onBackspace(evt);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: false,
	        leftText: '',
	        centerText: '',
	        rightText: 'Cancel'
	      }
	    });
	    onOpened();
	    navigator.mediaDevices.getUserMedia({
	      audio: false,
	      video: true
	    }).then(stream => {
	      // const video = document.getElementById("qr_video");
	      $$invalidate(1, nodeRef.srcObject = stream, nodeRef);
	      $$invalidate(1, nodeRef.onloadedmetadata = e => {
	        nodeRef.play();
	        var barcodeCanvas = document.createElement("canvas");
	        scanning = setInterval(() => {
	          barcodeCanvas.width = nodeRef.videoWidth;
	          barcodeCanvas.height = nodeRef.videoHeight;
	          var barcodeContext = barcodeCanvas.getContext("2d");
	          var imageWidth = Math.max(1, Math.floor(nodeRef.videoWidth)),
	              imageHeight = Math.max(1, Math.floor(nodeRef.videoHeight));
	          barcodeContext.drawImage(nodeRef, 0, 0, imageWidth, imageHeight);
	          var imageData = barcodeContext.getImageData(0, 0, imageWidth, imageHeight);
	          var idd = imageData.data;
	          var code = jsQR$1(idd, imageWidth, imageHeight);

	          if (code) {
	            if (scanning != null) {
	              clearInterval(scanning);
	            } // console.log(code.data);


	            callback(code.data.replace('tg://login?token=', ''));
	          }
	        }, 1000);
	      }, nodeRef);
	    }).catch(err => {
	      console.log(err);
	    });
	  });
	  onDestroy(() => {
	    navigator.mediaDevices.getUserMedia({
	      audio: false,
	      video: true
	    }).then(stream => {
	      stream.getTracks().forEach(track => {
	        track.stop();
	      });
	    });

	    if (scanning != null) {
	      clearInterval(scanning);
	    }

	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed();
	  });
	  var writable_props = ['title', 'onBackspace', 'onOpened', 'onClosed', 'callback'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$c.warn(`<QRScanner> was created with unknown prop '${key}'`);
	  });

	  function video_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(1, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('onBackspace' in $$props) $$invalidate(2, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(3, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(4, onClosed = $$props.onClosed);
	    if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    jsQR: jsQR$1,
	    title,
	    onBackspace,
	    onOpened,
	    onClosed,
	    callback,
	    nodeRef,
	    softwareKey,
	    scanning,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('onBackspace' in $$props) $$invalidate(2, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(3, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(4, onClosed = $$props.onClosed);
	    if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
	    if ('nodeRef' in $$props) $$invalidate(1, nodeRef = $$props.nodeRef);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('scanning' in $$props) scanning = $$props.scanning;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, nodeRef, onBackspace, onOpened, onClosed, callback, video_binding];
	}

	class QRScanner extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
	      title: 0,
	      onBackspace: 2,
	      onOpened: 3,
	      onClosed: 4,
	      callback: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "QRScanner",
	      options,
	      id: create_fragment$Z.name
	    });
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[2];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[3];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[4];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get callback() {
	    return this.$$.ctx[5];
	  }

	  set callback(callback) {
	    this.$$set({
	      callback
	    });
	    flush();
	  }

	}

	var file$Y = "src/widgets/ChatListView.svelte"; // (15:6) {#if chat.entity.__muted != false && !chat.entity.__isSavedMessages}

	function create_if_block_5$1(ctx) {
	  var t;
	  var block = {
	    c: function create() {
	      t = text("");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_5$1.name,
	    type: "if",
	    source: "(15:6) {#if chat.entity.__muted != false && !chat.entity.__isSavedMessages}",
	    ctx
	  });
	  return block;
	} // (20:29) 


	function create_if_block_4$1(ctx) {
	  var b;
	  var t_value = (
	  /*chat*/
	  ctx[2].message._sender.firstName ||
	  /*chat*/
	  ctx[2].message._sender.lastName ||
	  /*chat*/
	  ctx[2].message._sender.username ||
	  /*chat*/
	  ctx[2].message._sender.id) + "";
	  var t;
	  var br;
	  var block = {
	    c: function create() {
	      b = element("b");
	      t = text(t_value);
	      br = element("br");
	      add_location(b, file$Y, 20, 9, 692);
	      add_location(br, file$Y, 20, 141, 824);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, b, anchor);
	      append_dev(b, t);
	      insert_dev(target, br, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*chat*/
	      4 && t_value !== (t_value = (
	      /*chat*/
	      ctx[2].message._sender.firstName ||
	      /*chat*/
	      ctx[2].message._sender.lastName ||
	      /*chat*/
	      ctx[2].message._sender.username ||
	      /*chat*/
	      ctx[2].message._sender.id) + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(b);
	      if (detaching) detach_dev(br);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_4$1.name,
	    type: "if",
	    source: "(20:29) ",
	    ctx
	  });
	  return block;
	} // (18:6) {#if chat.isGroup && userId === chat.message._sender.id.value.toString()}


	function create_if_block_3$1(ctx) {
	  var b;
	  var br;
	  var block = {
	    c: function create() {
	      b = element("b");
	      b.textContent = "You";
	      br = element("br");
	      add_location(b, file$Y, 18, 9, 638);
	      add_location(br, file$Y, 18, 19, 648);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, b, anchor);
	      insert_dev(target, br, anchor);
	    },
	    p: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(b);
	      if (detaching) detach_dev(br);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_3$1.name,
	    type: "if",
	    source: "(18:6) {#if chat.isGroup && userId === chat.message._sender.id.value.toString()}",
	    ctx
	  });
	  return block;
	} // (27:6) {:else}


	function create_else_block$4(ctx) {
	  var t_value = (
	  /*chat*/
	  ctx[2].message.media ?
	  /*chat*/
	  ctx[2].message.media.className :
	  /*chat*/
	  ctx[2].message.className) + "";
	  var t;
	  var block = {
	    c: function create() {
	      t = text(t_value);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*chat*/
	      4 && t_value !== (t_value = (
	      /*chat*/
	      ctx[2].message.media ?
	      /*chat*/
	      ctx[2].message.media.className :
	      /*chat*/
	      ctx[2].message.className) + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$4.name,
	    type: "else",
	    source: "(27:6) {:else}",
	    ctx
	  });
	  return block;
	} // (25:36) 


	function create_if_block_2$3(ctx) {
	  var t_value =
	  /*chat*/
	  ctx[2].message.action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      t = text(t_value);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*chat*/
	      4 && t_value !== (t_value =
	      /*chat*/
	      ctx[2].message.action.className + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$3.name,
	    type: "if",
	    source: "(25:36) ",
	    ctx
	  });
	  return block;
	} // (23:6) {#if chat.message && chat.message.message}


	function create_if_block_1$8(ctx) {
	  var t_value =
	  /*chat*/
	  ctx[2].message.message.substring(0, 25) + (
	  /*chat*/
	  ctx[2].message.message.length > 25 ? '...' : '') + "";
	  var t;
	  var block = {
	    c: function create() {
	      t = text(t_value);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*chat*/
	      4 && t_value !== (t_value =
	      /*chat*/
	      ctx[2].message.message.substring(0, 25) + (
	      /*chat*/
	      ctx[2].message.message.length > 25 ? '...' : '') + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$8.name,
	    type: "if",
	    source: "(23:6) {#if chat.message && chat.message.message}",
	    ctx
	  });
	  return block;
	} // (33:4) {#if chat.unreadCount}


	function create_if_block$c(ctx) {
	  var span;
	  var t_value =
	  /*chat*/
	  ctx[2].unreadCount + "";
	  var t;
	  var block = {
	    c: function create() {
	      span = element("span");
	      t = text(t_value);
	      attr_dev(span, "class", "badge svelte-1js42ya");
	      set_style(span, "background-color",
	      /*chat*/
	      ctx[2].entity.__muted ? '#c0c0c0' : '#008000');
	      add_location(span, file$Y, 33, 6, 1265);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	      append_dev(span, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*chat*/
	      4 && t_value !== (t_value =
	      /*chat*/
	      ctx[2].unreadCount + "")) set_data_dev(t, t_value);

	      if (dirty &
	      /*chat*/
	      4) {
	        set_style(span, "background-color",
	        /*chat*/
	        ctx[2].entity.__muted ? '#c0c0c0' : '#008000');
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$c.name,
	    type: "if",
	    source: "(33:4) {#if chat.unreadCount}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$Y(ctx) {
	  var div3;
	  var div0;
	  var t0;
	  var div1;
	  var p;
	  var t1_value =
	  /*chat*/
	  ctx[2].name + "";
	  var t1;
	  var t2;
	  var small;
	  var show_if;
	  var t3;
	  var t4;
	  var div2;
	  var t5;
	  var span;
	  var div3_class_value;
	  var mounted;
	  var dispose;
	  var if_block0 =
	  /*chat*/
	  ctx[2].entity.__muted != false && !
	  /*chat*/
	  ctx[2].entity.__isSavedMessages && create_if_block_5$1(ctx);

	  function select_block_type(ctx, dirty) {
	    if (dirty &
	    /*chat, userId*/
	    20) show_if = null;
	    if (show_if == null) show_if = !!(
	    /*chat*/
	    ctx[2].isGroup &&
	    /*userId*/
	    ctx[4] ===
	    /*chat*/
	    ctx[2].message._sender.id.value.toString());
	    if (show_if) return create_if_block_3$1;
	    if (
	    /*chat*/
	    ctx[2].isGroup) return create_if_block_4$1;
	  }

	  var current_block_type = select_block_type(ctx, -1);
	  var if_block1 = current_block_type && current_block_type(ctx);

	  function select_block_type_1(ctx, dirty) {
	    if (
	    /*chat*/
	    ctx[2].message &&
	    /*chat*/
	    ctx[2].message.message) return create_if_block_1$8;
	    if (
	    /*chat*/
	    ctx[2].message.action) return create_if_block_2$3;
	    return create_else_block$4;
	  }

	  var current_block_type_1 = select_block_type_1(ctx);
	  var if_block2 = current_block_type_1(ctx);
	  var if_block3 =
	  /*chat*/
	  ctx[2].unreadCount && create_if_block$c(ctx);
	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div0 = element("div");
	      t0 = space();
	      div1 = element("div");
	      p = element("p");
	      if (if_block0) if_block0.c();
	      t1 = text(t1_value);
	      t2 = space();
	      small = element("small");
	      if (if_block1) if_block1.c();
	      t3 = space();
	      if_block2.c();
	      t4 = space();
	      div2 = element("div");
	      if (if_block3) if_block3.c();
	      t5 = space();
	      span = element("span");
	      attr_dev(div0, "class", "kai-list-view-icon svelte-1js42ya");
	      add_location(div0, file$Y, 11, 2, 325);
	      attr_dev(p, "class", "svelte-1js42ya");
	      add_location(p, file$Y, 13, 4, 418);
	      attr_dev(small, "class", "svelte-1js42ya");
	      add_location(small, file$Y, 16, 4, 541);
	      attr_dev(div1, "class", "kai-list-view-content svelte-1js42ya");
	      add_location(div1, file$Y, 12, 2, 378);
	      attr_dev(span, "class", "kai-icon-arrow");
	      add_location(span, file$Y, 35, 4, 1397);
	      attr_dev(div2, "class", "kai-list-view-indicator svelte-1js42ya");
	      add_location(div2, file$Y, 31, 2, 1194);
	      attr_dev(div3, "data-key",
	      /*key*/
	      ctx[0]);
	      attr_dev(div3, "class", div3_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-1js42ya");
	      add_location(div3, file$Y, 10, 0, 230);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div0);
	      div0.innerHTML =
	      /*icon*/
	      ctx[1];
	      append_dev(div3, t0);
	      append_dev(div3, div1);
	      append_dev(div1, p);
	      if (if_block0) if_block0.m(p, null);
	      append_dev(p, t1);
	      append_dev(div1, t2);
	      append_dev(div1, small);
	      if (if_block1) if_block1.m(small, null);
	      append_dev(small, t3);
	      if_block2.m(small, null);
	      append_dev(div3, t4);
	      append_dev(div3, div2);
	      if (if_block3) if_block3.m(div2, null);
	      append_dev(div2, t5);
	      append_dev(div2, span);

	      if (!mounted) {
	        dispose = listen_dev(div3, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[5]))
	            /*onClick*/
	            ctx[5].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;
	      if (dirty &
	      /*icon*/
	      2) div0.innerHTML =
	      /*icon*/
	      ctx[1];

	      if (
	      /*chat*/
	      ctx[2].entity.__muted != false && !
	      /*chat*/
	      ctx[2].entity.__isSavedMessages) {
	        if (if_block0) ; else {
	          if_block0 = create_if_block_5$1(ctx);
	          if_block0.c();
	          if_block0.m(p, t1);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (dirty &
	      /*chat*/
	      4 && t1_value !== (t1_value =
	      /*chat*/
	      ctx[2].name + "")) set_data_dev(t1, t1_value);

	      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
	        if_block1.p(ctx, dirty);
	      } else {
	        if (if_block1) if_block1.d(1);
	        if_block1 = current_block_type && current_block_type(ctx);

	        if (if_block1) {
	          if_block1.c();
	          if_block1.m(small, t3);
	        }
	      }

	      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block2) {
	        if_block2.p(ctx, dirty);
	      } else {
	        if_block2.d(1);
	        if_block2 = current_block_type_1(ctx);

	        if (if_block2) {
	          if_block2.c();
	          if_block2.m(small, null);
	        }
	      }

	      if (
	      /*chat*/
	      ctx[2].unreadCount) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block$c(ctx);
	          if_block3.c();
	          if_block3.m(div2, t5);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }

	      if (dirty &
	      /*key*/
	      1) {
	        attr_dev(div3, "data-key",
	        /*key*/
	        ctx[0]);
	      }

	      if (dirty &
	      /*className*/
	      8 && div3_class_value !== (div3_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-1js42ya")) {
	        attr_dev(div3, "class", div3_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      if (if_block0) if_block0.d();

	      if (if_block1) {
	        if_block1.d();
	      }

	      if_block2.d();
	      if (if_block3) if_block3.d();
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Y.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$Y($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('ChatListView', slots, []);
	  var _$$props$key = $$props.key,
	      key = _$$props$key === void 0 ? '' : _$$props$key;
	  var _$$props$icon = $$props.icon,
	      icon = _$$props$icon === void 0 ? '' : _$$props$icon;
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? null : _$$props$className;
	  var _$$props$userId = $$props.userId,
	      userId = _$$props$userId === void 0 ? null : _$$props$userId;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var writable_props = ['key', 'icon', 'chat', 'className', 'userId', 'onClick'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChatListView> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
	    if ('chat' in $$props) $$invalidate(2, chat = $$props.chat);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('userId' in $$props) $$invalidate(4, userId = $$props.userId);
	    if ('onClick' in $$props) $$invalidate(5, onClick = $$props.onClick);
	  };

	  $$self.$capture_state = () => ({
	    key,
	    icon,
	    chat,
	    className,
	    userId,
	    onClick
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
	    if ('chat' in $$props) $$invalidate(2, chat = $$props.chat);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('userId' in $$props) $$invalidate(4, userId = $$props.userId);
	    if ('onClick' in $$props) $$invalidate(5, onClick = $$props.onClick);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [key, icon, chat, className, userId, onClick];
	}

	class ChatListView extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Y, create_fragment$Y, not_equal, {
	      key: 0,
	      icon: 1,
	      chat: 2,
	      className: 3,
	      userId: 4,
	      onClick: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ChatListView",
	      options,
	      id: create_fragment$Y.name
	    });
	  }

	  get key() {
	    return this.$$.ctx[0];
	  }

	  set key(key) {
	    this.$$set({
	      key
	    });
	    flush();
	  }

	  get icon() {
	    return this.$$.ctx[1];
	  }

	  set icon(icon) {
	    this.$$set({
	      icon
	    });
	    flush();
	  }

	  get chat() {
	    return this.$$.ctx[2];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get className() {
	    return this.$$.ctx[3];
	  }

	  set className(className) {
	    this.$$set({
	      className
	    });
	    flush();
	  }

	  get userId() {
	    return this.$$.ctx[4];
	  }

	  set userId(userId) {
	    this.$$set({
	      userId
	    });
	    flush();
	  }

	  get onClick() {
	    return this.$$.ctx[5];
	  }

	  set onClick(onClick) {
	    this.$$set({
	      onClick
	    });
	    flush();
	  }

	}

	var file$X = "src/widgets/ArchivedChats.svelte";

	function get_each_context$4(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[18] = list[i];
	  return child_ctx;
	} // (79:6) {#each options as option}


	function create_each_block$4(ctx) {
	  var chatlistview;
	  var current;
	  chatlistview = new ChatListView({
	    props: {
	      chat:
	      /*option*/
	      ctx[18],
	      className: navClass$3,
	      icon:
	      /*getThumb*/
	      ctx[2](
	      /*option*/
	      ctx[18])
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(chatlistview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(chatlistview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var chatlistview_changes = {};
	      if (dirty &
	      /*options*/
	      2) chatlistview_changes.chat =
	      /*option*/
	      ctx[18];
	      if (dirty &
	      /*options*/
	      2) chatlistview_changes.icon =
	      /*getThumb*/
	      ctx[2](
	      /*option*/
	      ctx[18]);
	      chatlistview.$set(chatlistview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(chatlistview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(chatlistview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(chatlistview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$4.name,
	    type: "each",
	    source: "(79:6) {#each options as option}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$X(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var each_value =
	  /*options*/
	  ctx[1];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-19odwqw");
	      add_location(div0, file$X, 76, 4, 2966);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-19odwqw");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$X, 77, 4, 3020);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-19odwqw");
	      add_location(div2, file$X, 75, 2, 2924);
	      attr_dev(div3, "class", "kai-option-menu svelte-19odwqw");
	      add_location(div3, file$X, 74, 0, 2892);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*options, navClass, getThumb*/
	      6) {
	        each_value =
	        /*options*/
	        ctx[1];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$4(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$4(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$X.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$3 = 'optionMenuNav';

	function instance$X($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('ArchivedChats', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Option Menu' : _$$props$title;
	  var _$$props$focusIndex = $$props.focusIndex,
	      focusIndex = _$$props$focusIndex === void 0 ? 0 : _$$props$focusIndex;
	  var options = $$props.options;
	  var _$$props$thumbs = $$props.thumbs,
	      thumbs = _$$props$thumbs === void 0 ? {} : _$$props$thumbs;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, scope) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, scope) => {} : _$$props$onBackspace;
	  var _$$props$onSoftkeyLef = $$props.onSoftkeyLeft,
	      onSoftkeyLeft = _$$props$onSoftkeyLef === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyLef;
	  var _$$props$onSoftkeyRig = $$props.onSoftkeyRight,
	      onSoftkeyRight = _$$props$onSoftkeyRig === void 0 ? (evt, scope) => {} : _$$props$onSoftkeyRig;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? scope => {} : _$$props$onClosed;
	  var softwareKey;

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    verticalNavClass: navClass$3,

	    softkeyLeftListener(evt) {
	      if (onSoftkeyLeft == null) return;
	      onSoftkeyLeft(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    softkeyRightListener(evt) {
	      if (onSoftkeyRight == null) return;
	      onSoftkeyRight(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt, {
	        index: this.verticalNavIndex,
	        selected: options[this.verticalNavIndex]
	      });
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function getThumb(chat) {
	    if (thumbs[chat.iconRef]) {
	      return `<img alt="icon" style="background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;"" src="${thumbs[chat.iconRef]}"/>`;
	    }

	    return `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;font-weight:bold;color:#fff;background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;">${chat.name.split(' ').map(text => text[0]).splice(0, 2).join('')}</div>`;
	  }

	  onMount(() => {
	    navInstance.attachListener(focusIndex + 1);
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed({
	      index: navInstance.verticalNavIndex,
	      selected: options[navInstance.verticalNavIndex]
	    });
	  });
	  var writable_props = ['title', 'focusIndex', 'options', 'thumbs', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onSoftkeyLeft', 'onSoftkeyRight', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArchivedChats> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('thumbs' in $$props) $$invalidate(4, thumbs = $$props.thumbs);
	    if ('softKeyLeftText' in $$props) $$invalidate(5, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(6, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(7, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(8, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(9, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(10, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(11, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(12, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(13, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    ChatListView,
	    navClass: navClass$3,
	    title,
	    focusIndex,
	    options,
	    thumbs,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onSoftkeyLeft,
	    onSoftkeyRight,
	    onOpened,
	    onClosed,
	    softwareKey,
	    setTitleText,
	    navOptions,
	    navInstance,
	    getThumb
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(3, focusIndex = $$props.focusIndex);
	    if ('options' in $$props) $$invalidate(1, options = $$props.options);
	    if ('thumbs' in $$props) $$invalidate(4, thumbs = $$props.thumbs);
	    if ('softKeyLeftText' in $$props) $$invalidate(5, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(6, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(7, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(8, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(9, onBackspace = $$props.onBackspace);
	    if ('onSoftkeyLeft' in $$props) $$invalidate(10, onSoftkeyLeft = $$props.onSoftkeyLeft);
	    if ('onSoftkeyRight' in $$props) $$invalidate(11, onSoftkeyRight = $$props.onSoftkeyRight);
	    if ('onOpened' in $$props) $$invalidate(12, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(13, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, options, getThumb, focusIndex, thumbs, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onSoftkeyLeft, onSoftkeyRight, onOpened, onClosed, setTitleText];
	}

	class ArchivedChats extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$X, create_fragment$X, not_equal, {
	      title: 0,
	      focusIndex: 3,
	      options: 1,
	      thumbs: 4,
	      softKeyLeftText: 5,
	      softKeyCenterText: 6,
	      softKeyRightText: 7,
	      onEnter: 8,
	      onBackspace: 9,
	      onSoftkeyLeft: 10,
	      onSoftkeyRight: 11,
	      onOpened: 12,
	      onClosed: 13,
	      setTitleText: 14
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ArchivedChats",
	      options,
	      id: create_fragment$X.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*options*/
	    ctx[1] === undefined && !('options' in props)) {
	      console.warn("<ArchivedChats> was created without expected prop 'options'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get focusIndex() {
	    return this.$$.ctx[3];
	  }

	  set focusIndex(focusIndex) {
	    this.$$set({
	      focusIndex
	    });
	    flush();
	  }

	  get options() {
	    return this.$$.ctx[1];
	  }

	  set options(options) {
	    this.$$set({
	      options
	    });
	    flush();
	  }

	  get thumbs() {
	    return this.$$.ctx[4];
	  }

	  set thumbs(thumbs) {
	    this.$$set({
	      thumbs
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[5];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[6];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[7];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[8];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[9];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onSoftkeyLeft() {
	    return this.$$.ctx[10];
	  }

	  set onSoftkeyLeft(onSoftkeyLeft) {
	    this.$$set({
	      onSoftkeyLeft
	    });
	    flush();
	  }

	  get onSoftkeyRight() {
	    return this.$$.ctx[11];
	  }

	  set onSoftkeyRight(onSoftkeyRight) {
	    this.$$set({
	      onSoftkeyRight
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[12];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[13];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[14];
	  }

	  set setTitleText(value) {
	    throw new Error("<ArchivedChats>: Cannot set read-only property 'setTitleText'");
	  }

	}

	var file$W = "src/widgets/ContactList.svelte";

	function get_each_context$3(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[22] = list[i];
	  return child_ctx;
	} // (158:6) {#each contactFeeds as contact}


	function create_each_block$3(ctx) {
	  var listview;
	  var current;
	  listview = new ListView({
	    props: {
	      title: [
	      /*contact*/
	      ctx[22].firstName || '',
	      /*contact*/
	      ctx[22].lastName || ''].join(' '),
	      subtitle: undefined,
	      className: navClass$2
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(listview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(listview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var listview_changes = {};
	      if (dirty &
	      /*contactFeeds*/
	      2) listview_changes.title = [
	      /*contact*/
	      ctx[22].firstName || '',
	      /*contact*/
	      ctx[22].lastName || ''].join(' ');
	      listview.$set(listview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(listview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(listview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(listview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$3.name,
	    type: "each",
	    source: "(158:6) {#each contactFeeds as contact}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$W(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var textinputfield;
	  var t2;
	  var current;
	  textinputfield = new TextInputField({
	    props: {
	      className: navClass$2,
	      label: "Search Contacts",
	      placeholder: "Enter search keyword",
	      value: "",
	      type: "text",
	      onInput,
	      onFocus:
	      /*onFocus*/
	      ctx[2],
	      onBlur:
	      /*onBlur*/
	      ctx[3]
	    },
	    $$inline: true
	  });
	  var each_value =
	  /*contactFeeds*/
	  ctx[1];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");
	      create_component(textinputfield.$$.fragment);
	      t2 = space();

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-19odwqw");
	      add_location(div0, file$W, 154, 4, 5446);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-19odwqw");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$W, 155, 4, 5500);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-19odwqw");
	      add_location(div2, file$W, 153, 2, 5404);
	      attr_dev(div3, "class", "kai-option-menu svelte-19odwqw");
	      add_location(div3, file$W, 152, 0, 5372);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);
	      mount_component(textinputfield, div1, null);
	      append_dev(div1, t2);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }

	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*contactFeeds, undefined, navClass*/
	      2) {
	        each_value =
	        /*contactFeeds*/
	        ctx[1];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$3(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$3(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(textinputfield.$$.fragment, local);

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(textinputfield.$$.fragment, local);
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_component(textinputfield);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$W.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$2 = 'optionMenuNav';
	var contactPerPage = 15;

	function onInput(evt) {}

	function instance$W($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('ContactList', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Option Menu' : _$$props$title;
	  var _$$props$focusIndex = $$props.focusIndex,
	      focusIndex = _$$props$focusIndex === void 0 ? 0 : _$$props$focusIndex;
	  var sources = $$props.sources;
	  var _$$props$thumbs = $$props.thumbs,
	      thumbs = _$$props$thumbs === void 0 ? {} : _$$props$thumbs;
	  var _$$props$softKeyLeftT = $$props.softKeyLeftText,
	      softKeyLeftText = _$$props$softKeyLeftT === void 0 ? '' : _$$props$softKeyLeftT;
	  var _$$props$softKeyCente = $$props.softKeyCenterText,
	      softKeyCenterText = _$$props$softKeyCente === void 0 ? 'Close' : _$$props$softKeyCente;
	  var _$$props$softKeyRight = $$props.softKeyRightText,
	      softKeyRightText = _$$props$softKeyRight === void 0 ? '' : _$$props$softKeyRight;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? (evt, scope) => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? (evt, scope) => {} : _$$props$onBackspace;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? scope => {} : _$$props$onClosed;
	  var softwareKey;
	  var contactPages = [];
	  var contactPagesCursor = 0;
	  var contactFeeds = [];

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    verticalNavClass: navClass$2,
	    arrowUpListener: evt => {
	      if (navInstance.verticalNavIndex !== 0) {
	        evt.preventDefault();
	        navInstance.navigateListNav(-1);
	      }
	    },
	    arrowDownListener: evt => {
	      if (contactFeeds.length - navInstance.verticalNavIndex === 2 && contactPages.length - 1 !== contactPagesCursor) $$invalidate(1, contactFeeds = [...contactFeeds, ...contactPages[++contactPagesCursor]]);

	      if (navInstance.verticalNavIndex !== contactFeeds.length) {
	        evt.preventDefault();
	        navInstance.navigateListNav(1);
	      }
	    },

	    softkeyLeftListener(evt) {
	      if (document.activeElement.tagName !== 'INPUT') {
	        setTimeout(() => {
	          navInstance.navigateListNav(-navInstance.verticalNavIndex);
	        }, 200);
	      } else if (document.activeElement.tagName === 'INPUT') {
	        searchContacts('');
	      }
	    },

	    softkeyRightListener(evt) {
	      if (document.activeElement.tagName === 'INPUT') {
	        searchContacts(document.activeElement.value);
	      }
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt, {
	        index: this.verticalNavIndex,
	        selected: contactFeeds[this.verticalNavIndex - 1] || null
	      });
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;

	      if (document.activeElement.tagName === 'INPUT') {
	        return;
	      }

	      onBackspace(evt, {
	        index: this.verticalNavIndex,
	        selected: sources[this.verticalNavIndex]
	      });
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function getThumb(chat) {
	    if (thumbs[chat.iconRef]) {
	      return `<img alt="icon" style="background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;"" src="${thumbs[chat.iconRef]}"/>`;
	    }

	    return `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;font-weight:bold;color:#fff;background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;">${chat.name.split(' ').map(text => text[0]).splice(0, 2).join('')}</div>`;
	  }

	  function onFocus(evt) {
	    if (softwareKey != null) {
	      softwareKey.setText({
	        left: 'Reset',
	        center: '',
	        right: 'Submit'
	      });
	    }
	  }

	  function onBlur(evt) {
	    if (softwareKey != null && typeof softwareKey.setText == 'function') {
	      softwareKey.setText({
	        left: softKeyLeftText,
	        center: softKeyCenterText,
	        right: softKeyRightText
	      });
	    }
	  }

	  function searchContacts() {
	    var keyword = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    contactPages = [];
	    contactPagesCursor = 0;
	    var page = [];

	    for (var i = 0; i < sources.length; i++) {
	      if (keyword == '') {
	        page.push(sources[i]);
	      } else {
	        var strings = [];
	        if (sources[i].firstName) strings.push(sources[i].firstName);
	        if (sources[i].lastName) strings.push(sources[i].lastName);
	        if (sources[i].phone) strings.push(sources[i].phone);
	        if (sources[i].username) strings.push(sources[i].username);

	        if (strings.join(' ').toLocaleLowerCase().indexOf(keyword.toLocaleLowerCase()) > -1) {
	          page.push(sources[i]);
	        }
	      }

	      if ((i === sources.length - 1 || (i + 1) % contactPerPage === 0) && page.length > 0) {
	        contactPages.push(page);
	        page = [];
	      }
	    }

	    $$invalidate(1, contactFeeds = contactPages[contactPagesCursor]);
	    setTimeout(() => {
	      navInstance.navigateListNav(1);
	    }, 500);
	  }

	  onMount(() => {
	    navInstance.attachListener(focusIndex + 1);
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: softKeyLeftText,
	        centerText: softKeyCenterText,
	        rightText: softKeyRightText
	      }
	    });
	    searchContacts('');
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed({
	      index: navInstance.verticalNavIndex,
	      selected: sources[navInstance.verticalNavIndex]
	    });
	  });
	  var writable_props = ['title', 'focusIndex', 'sources', 'thumbs', 'softKeyLeftText', 'softKeyCenterText', 'softKeyRightText', 'onEnter', 'onBackspace', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContactList> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(4, focusIndex = $$props.focusIndex);
	    if ('sources' in $$props) $$invalidate(5, sources = $$props.sources);
	    if ('thumbs' in $$props) $$invalidate(6, thumbs = $$props.thumbs);
	    if ('softKeyLeftText' in $$props) $$invalidate(7, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(8, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(9, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(10, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(11, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(12, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(13, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    ListView,
	    SoftwareKey,
	    TextInputField,
	    navClass: navClass$2,
	    title,
	    focusIndex,
	    sources,
	    thumbs,
	    softKeyLeftText,
	    softKeyCenterText,
	    softKeyRightText,
	    onEnter,
	    onBackspace,
	    onOpened,
	    onClosed,
	    softwareKey,
	    contactPerPage,
	    contactPages,
	    contactPagesCursor,
	    contactFeeds,
	    setTitleText,
	    navOptions,
	    navInstance,
	    getThumb,
	    onInput,
	    onFocus,
	    onBlur,
	    searchContacts
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('focusIndex' in $$props) $$invalidate(4, focusIndex = $$props.focusIndex);
	    if ('sources' in $$props) $$invalidate(5, sources = $$props.sources);
	    if ('thumbs' in $$props) $$invalidate(6, thumbs = $$props.thumbs);
	    if ('softKeyLeftText' in $$props) $$invalidate(7, softKeyLeftText = $$props.softKeyLeftText);
	    if ('softKeyCenterText' in $$props) $$invalidate(8, softKeyCenterText = $$props.softKeyCenterText);
	    if ('softKeyRightText' in $$props) $$invalidate(9, softKeyRightText = $$props.softKeyRightText);
	    if ('onEnter' in $$props) $$invalidate(10, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(11, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(12, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(13, onClosed = $$props.onClosed);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('contactPages' in $$props) contactPages = $$props.contactPages;
	    if ('contactPagesCursor' in $$props) contactPagesCursor = $$props.contactPagesCursor;
	    if ('contactFeeds' in $$props) $$invalidate(1, contactFeeds = $$props.contactFeeds);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, contactFeeds, onFocus, onBlur, focusIndex, sources, thumbs, softKeyLeftText, softKeyCenterText, softKeyRightText, onEnter, onBackspace, onOpened, onClosed, setTitleText];
	}

	class ContactList extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$W, create_fragment$W, not_equal, {
	      title: 0,
	      focusIndex: 4,
	      sources: 5,
	      thumbs: 6,
	      softKeyLeftText: 7,
	      softKeyCenterText: 8,
	      softKeyRightText: 9,
	      onEnter: 10,
	      onBackspace: 11,
	      onOpened: 12,
	      onClosed: 13,
	      setTitleText: 14
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ContactList",
	      options,
	      id: create_fragment$W.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*sources*/
	    ctx[5] === undefined && !('sources' in props)) {
	      console.warn("<ContactList> was created without expected prop 'sources'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get focusIndex() {
	    return this.$$.ctx[4];
	  }

	  set focusIndex(focusIndex) {
	    this.$$set({
	      focusIndex
	    });
	    flush();
	  }

	  get sources() {
	    return this.$$.ctx[5];
	  }

	  set sources(sources) {
	    this.$$set({
	      sources
	    });
	    flush();
	  }

	  get thumbs() {
	    return this.$$.ctx[6];
	  }

	  set thumbs(thumbs) {
	    this.$$set({
	      thumbs
	    });
	    flush();
	  }

	  get softKeyLeftText() {
	    return this.$$.ctx[7];
	  }

	  set softKeyLeftText(softKeyLeftText) {
	    this.$$set({
	      softKeyLeftText
	    });
	    flush();
	  }

	  get softKeyCenterText() {
	    return this.$$.ctx[8];
	  }

	  set softKeyCenterText(softKeyCenterText) {
	    this.$$set({
	      softKeyCenterText
	    });
	    flush();
	  }

	  get softKeyRightText() {
	    return this.$$.ctx[9];
	  }

	  set softKeyRightText(softKeyRightText) {
	    this.$$set({
	      softKeyRightText
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[10];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[11];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[12];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[13];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[14];
	  }

	  set setTitleText(value) {
	    throw new Error("<ContactList>: Cannot set read-only property 'setTitleText'");
	  }

	}

	/* src/routes/Home.svelte generated by Svelte v3.46.4 */
	var console_1$b = globals.console;
	var file$V = "src/routes/Home.svelte";

	function get_each_context$2(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[62] = list[i];
	  return child_ctx;
	} // (913:2) {:else}


	function create_else_block_1(ctx) {
	  var t;
	  var each_1_anchor;
	  var current;
	  var if_block =
	  /*archivedChatList*/
	  ctx[5].length > 0 && create_if_block_2$2(ctx);
	  var each_value =
	  /*chatList*/
	  ctx[8];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      t = space();

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, t, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (
	      /*archivedChatList*/
	      ctx[5].length > 0) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*archivedChatList*/
	          32) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_2$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t.parentNode, t);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }

	      if (dirty[0] &
	      /*user, chatList, getThumb, openRoom*/
	      786816) {
	        each_value =
	        /*chatList*/
	        ctx[8];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$2(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$2(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach_dev(t);
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach_dev(each_1_anchor);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block_1.name,
	    type: "else",
	    source: "(913:2) {:else}",
	    ctx
	  });
	  return block;
	} // (883:2) {#if authStatus === false }


	function create_if_block$b(ctx) {
	  var current_block_type_index;
	  var if_block;
	  var t;
	  var button;
	  var current;
	  var if_block_creators = [create_if_block_1$7, create_else_block$3];
	  var if_blocks = [];

	  function select_block_type_1(ctx, dirty) {
	    if (
	    /*phoneCodeHash*/
	    ctx[3] === null) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type_1(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  button = new Button({
	    props: {
	      className: navClass$1,
	      text: "Exit",
	      onClick:
	      /*func*/
	      ctx[23],
	      $$slots: {
	        rightWidget: [create_rightWidget_slot],
	        leftWidget: [create_leftWidget_slot]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      if_block.c();
	      t = space();
	      create_component(button.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, t, anchor);
	      mount_component(button, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type_1(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(t.parentNode, t);
	      }

	      var button_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button.$set(button_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      transition_in(button.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      transition_out(button.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach_dev(t);
	      destroy_component(button, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$b.name,
	    type: "if",
	    source: "(883:2) {#if authStatus === false }",
	    ctx
	  });
	  return block;
	} // (914:2) {#if archivedChatList.length > 0 }


	function create_if_block_2$2(ctx) {
	  var listview;
	  var current;
	  listview = new ListView({
	    props: {
	      className: navClass$1,
	      title: "Archived Chats",
	      subtitle:
	      /*archivedChatListName*/
	      ctx[6].join(', ').substring(0, 50),
	      onClick:
	      /*openArchivedChatListMenu*/
	      ctx[9],
	      $$slots: {
	        leftWidget: [create_leftWidget_slot_6]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(listview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(listview, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var listview_changes = {};
	      if (dirty[0] &
	      /*archivedChatListName*/
	      64) listview_changes.subtitle =
	      /*archivedChatListName*/
	      ctx[6].join(', ').substring(0, 50);

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        listview_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      listview.$set(listview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(listview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(listview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(listview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$2.name,
	    type: "if",
	    source: "(914:2) {#if archivedChatList.length > 0 }",
	    ctx
	  });
	  return block;
	} // (916:6) 


	function create_leftWidget_slot_6(ctx) {
	  var span;
	  var img;
	  var img_src_value;
	  var block = {
	    c: function create() {
	      span = element("span");
	      img = element("img");
	      attr_dev(img, "alt", "icon");
	      set_style(img, "background-color", "var(--themeColor)");
	      set_style(img, "width", "40px");
	      set_style(img, "height", "40px");
	      set_style(img, "box-sizing", "border-box");
	      set_style(img, "border-radius", "50%");
	      set_style(img, "border", "2px solid #fff");
	      if (!src_url_equal(img.src, img_src_value = "/icons/archived.png")) attr_dev(img, "src", img_src_value);
	      add_location(img, file$V, 915, 58, 36652);
	      attr_dev(span, "slot", "leftWidget");
	      set_style(span, "padding-right", "4px");
	      add_location(span, file$V, 915, 6, 36600);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	      append_dev(span, img);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_6.name,
	    type: "slot",
	    source: "(916:6) ",
	    ctx
	  });
	  return block;
	} // (919:2) {#each chatList as chat}


	function create_each_block$2(ctx) {
	  var chatlistview;
	  var current;

	  function func_1() {
	    return (
	      /*func_1*/
	      ctx[24](
	      /*chat*/
	      ctx[62])
	    );
	  }

	  chatlistview = new ChatListView({
	    props: {
	      userId:
	      /*user*/
	      ctx[7].length > 0 ?
	      /*user*/
	      ctx[7][0].id.value.toString() : null,
	      chat:
	      /*chat*/
	      ctx[62],
	      className: navClass$1,
	      icon:
	      /*getThumb*/
	      ctx[19](
	      /*chat*/
	      ctx[62]),
	      onClick: func_1
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(chatlistview.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(chatlistview, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      var chatlistview_changes = {};
	      if (dirty[0] &
	      /*user*/
	      128) chatlistview_changes.userId =
	      /*user*/
	      ctx[7].length > 0 ?
	      /*user*/
	      ctx[7][0].id.value.toString() : null;
	      if (dirty[0] &
	      /*chatList*/
	      256) chatlistview_changes.chat =
	      /*chat*/
	      ctx[62];
	      if (dirty[0] &
	      /*chatList*/
	      256) chatlistview_changes.icon =
	      /*getThumb*/
	      ctx[19](
	      /*chat*/
	      ctx[62]);
	      if (dirty[0] &
	      /*chatList*/
	      256) chatlistview_changes.onClick = func_1;
	      chatlistview.$set(chatlistview_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(chatlistview.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(chatlistview.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(chatlistview, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$2.name,
	    type: "each",
	    source: "(919:2) {#each chatList as chat}",
	    ctx
	  });
	  return block;
	} // (894:2) {:else}


	function create_else_block$3(ctx) {
	  var textinputfield;
	  var t0;
	  var button0;
	  var t1;
	  var button1;
	  var t2;
	  var button2;
	  var current;
	  textinputfield = new TextInputField({
	    props: {
	      className: navClass$1,
	      label: "Login Code",
	      placeholder: "Login Code",
	      value:
	      /*phoneCode*/
	      ctx[2],
	      type: "tel",
	      onInput:
	      /*onInputPhoneCode*/
	      ctx[11],
	      onFocus:
	      /*onFocus*/
	      ctx[12],
	      onBlur:
	      /*onBlur*/
	      ctx[13]
	    },
	    $$inline: true
	  });
	  button0 = new Button({
	    props: {
	      className: navClass$1,
	      text: "Open SMS",
	      onClick: openSMS,
	      $$slots: {
	        rightWidget: [create_rightWidget_slot_5],
	        leftWidget: [create_leftWidget_slot_5]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  button1 = new Button({
	    props: {
	      className: navClass$1,
	      text: "Sign In",
	      onClick:
	      /*signIn*/
	      ctx[15],
	      $$slots: {
	        rightWidget: [create_rightWidget_slot_4],
	        leftWidget: [create_leftWidget_slot_4]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  button2 = new Button({
	    props: {
	      className: navClass$1,
	      text: "Return",
	      onClick:
	      /*resetSignIn*/
	      ctx[17],
	      $$slots: {
	        rightWidget: [create_rightWidget_slot_3],
	        leftWidget: [create_leftWidget_slot_3]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(textinputfield.$$.fragment);
	      t0 = space();
	      create_component(button0.$$.fragment);
	      t1 = space();
	      create_component(button1.$$.fragment);
	      t2 = space();
	      create_component(button2.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(textinputfield, target, anchor);
	      insert_dev(target, t0, anchor);
	      mount_component(button0, target, anchor);
	      insert_dev(target, t1, anchor);
	      mount_component(button1, target, anchor);
	      insert_dev(target, t2, anchor);
	      mount_component(button2, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var textinputfield_changes = {};
	      if (dirty[0] &
	      /*phoneCode*/
	      4) textinputfield_changes.value =
	      /*phoneCode*/
	      ctx[2];
	      textinputfield.$set(textinputfield_changes);
	      var button0_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button0_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button0.$set(button0_changes);
	      var button1_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button1_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button1.$set(button1_changes);
	      var button2_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button2_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button2.$set(button2_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(textinputfield.$$.fragment, local);
	      transition_in(button0.$$.fragment, local);
	      transition_in(button1.$$.fragment, local);
	      transition_in(button2.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(textinputfield.$$.fragment, local);
	      transition_out(button0.$$.fragment, local);
	      transition_out(button1.$$.fragment, local);
	      transition_out(button2.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(textinputfield, detaching);
	      if (detaching) detach_dev(t0);
	      destroy_component(button0, detaching);
	      if (detaching) detach_dev(t1);
	      destroy_component(button1, detaching);
	      if (detaching) detach_dev(t2);
	      destroy_component(button2, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$3.name,
	    type: "else",
	    source: "(894:2) {:else}",
	    ctx
	  });
	  return block;
	} // (884:2) {#if phoneCodeHash === null}


	function create_if_block_1$7(ctx) {
	  var textinputfield;
	  var t0;
	  var button0;
	  var t1;
	  var button1;
	  var current;
	  textinputfield = new TextInputField({
	    props: {
	      className: navClass$1,
	      label: "Phone Number",
	      placeholder:
	      /*webWorkerStatus*/
	      ctx[0] ? 'Phone Number' : 'Connecting...',
	      value:
	      /*phoneNumber*/
	      ctx[1],
	      type: "tel",
	      onInput:
	      /*onInputPhoneNumber*/
	      ctx[10],
	      onFocus:
	      /*onFocus*/
	      ctx[12],
	      onBlur:
	      /*onBlur*/
	      ctx[13]
	    },
	    $$inline: true
	  });
	  button0 = new Button({
	    props: {
	      className: navClass$1,
	      text: "Send Code",
	      onClick:
	      /*sendCode*/
	      ctx[14],
	      $$slots: {
	        rightWidget: [create_rightWidget_slot_2],
	        leftWidget: [create_leftWidget_slot_2]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  button1 = new Button({
	    props: {
	      className: navClass$1,
	      text: "Log-In via QR Code",
	      onClick:
	      /*signInQR*/
	      ctx[16],
	      $$slots: {
	        rightWidget: [create_rightWidget_slot_1],
	        leftWidget: [create_leftWidget_slot_1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(textinputfield.$$.fragment);
	      t0 = space();
	      create_component(button0.$$.fragment);
	      t1 = space();
	      create_component(button1.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(textinputfield, target, anchor);
	      insert_dev(target, t0, anchor);
	      mount_component(button0, target, anchor);
	      insert_dev(target, t1, anchor);
	      mount_component(button1, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var textinputfield_changes = {};
	      if (dirty[0] &
	      /*webWorkerStatus*/
	      1) textinputfield_changes.placeholder =
	      /*webWorkerStatus*/
	      ctx[0] ? 'Phone Number' : 'Connecting...';
	      if (dirty[0] &
	      /*phoneNumber*/
	      2) textinputfield_changes.value =
	      /*phoneNumber*/
	      ctx[1];
	      textinputfield.$set(textinputfield_changes);
	      var button0_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button0_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button0.$set(button0_changes);
	      var button1_changes = {};

	      if (dirty[2] &
	      /*$$scope*/
	      8) {
	        button1_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      button1.$set(button1_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(textinputfield.$$.fragment, local);
	      transition_in(button0.$$.fragment, local);
	      transition_in(button1.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(textinputfield.$$.fragment, local);
	      transition_out(button0.$$.fragment, local);
	      transition_out(button1.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(textinputfield, detaching);
	      if (detaching) detach_dev(t0);
	      destroy_component(button0, detaching);
	      if (detaching) detach_dev(t1);
	      destroy_component(button1, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$7.name,
	    type: "if",
	    source: "(884:2) {#if phoneCodeHash === null}",
	    ctx
	  });
	  return block;
	} // (897:4) 


	function create_leftWidget_slot_5(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 896, 4, 34895);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_5.name,
	    type: "slot",
	    source: "(897:4) ",
	    ctx
	  });
	  return block;
	} // (898:4) 


	function create_rightWidget_slot_5(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 897, 4, 35118);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot_5.name,
	    type: "slot",
	    source: "(898:4) ",
	    ctx
	  });
	  return block;
	} // (901:4) 


	function create_leftWidget_slot_4(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 900, 4, 35280);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_4.name,
	    type: "slot",
	    source: "(901:4) ",
	    ctx
	  });
	  return block;
	} // (902:4) 


	function create_rightWidget_slot_4(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 901, 4, 35503);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot_4.name,
	    type: "slot",
	    source: "(902:4) ",
	    ctx
	  });
	  return block;
	} // (905:4) 


	function create_leftWidget_slot_3(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 904, 4, 35669);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_3.name,
	    type: "slot",
	    source: "(905:4) ",
	    ctx
	  });
	  return block;
	} // (906:4) 


	function create_rightWidget_slot_3(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 905, 4, 35892);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot_3.name,
	    type: "slot",
	    source: "(906:4) ",
	    ctx
	  });
	  return block;
	} // (887:4) 


	function create_leftWidget_slot_2(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 886, 4, 33935);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_2.name,
	    type: "slot",
	    source: "(887:4) ",
	    ctx
	  });
	  return block;
	} // (888:4) 


	function create_rightWidget_slot_2(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 887, 4, 34158);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot_2.name,
	    type: "slot",
	    source: "(888:4) ",
	    ctx
	  });
	  return block;
	} // (891:4) 


	function create_leftWidget_slot_1(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 890, 4, 34333);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot_1.name,
	    type: "slot",
	    source: "(891:4) ",
	    ctx
	  });
	  return block;
	} // (892:4) 


	function create_rightWidget_slot_1(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 891, 4, 34556);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot_1.name,
	    type: "slot",
	    source: "(892:4) ",
	    ctx
	  });
	  return block;
	} // (910:4) 


	function create_leftWidget_slot(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "leftWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      set_style(span, "-moz-transform", "scale(-1, 1)");
	      set_style(span, "-webkit-transform", "scale(-1, 1)");
	      set_style(span, "-o-transform", "scale(-1, 1)");
	      set_style(span, "-ms-transform", "scale(-1, 1)");
	      set_style(span, "transform", "scale(-1, 1)");
	      add_location(span, file$V, 909, 4, 36074);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_leftWidget_slot.name,
	    type: "slot",
	    source: "(910:4) ",
	    ctx
	  });
	  return block;
	} // (911:4) 


	function create_rightWidget_slot(ctx) {
	  var span;
	  var block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "slot", "rightWidget");
	      attr_dev(span, "class", "kai-icon-arrow");
	      set_style(span, "margin", "0px 5px");
	      add_location(span, file$V, 910, 4, 36297);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(span);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_rightWidget_slot.name,
	    type: "slot",
	    source: "(911:4) ",
	    ctx
	  });
	  return block;
	}

	function create_fragment$V(ctx) {
	  var main;
	  var current_block_type_index;
	  var if_block;
	  var current;
	  var if_block_creators = [create_if_block$b, create_else_block_1];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*authStatus*/
	    ctx[4] === false) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  var block = {
	    c: function create() {
	      main = element("main");
	      if_block.c();
	      attr_dev(main, "id", "home-screen");
	      attr_dev(main, "data-pad-top", "28");
	      attr_dev(main, "data-pad-bottom", "30");
	      attr_dev(main, "class", "svelte-k2v3lx");
	      add_location(main, file$V, 881, 0, 33524);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, main, anchor);
	      if_blocks[current_block_type_index].m(main, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(main, null);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(main);
	      if_blocks[current_block_type_index].d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$V.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass$1 = 'homeNav';

	function sign_up() {}

	function openSMS() {
	  window.open('sms://+1');
	}

	function instance$V($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Home', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var location = $$props.location;
	  var navigate$1 = $$props.navigate;
	  var getAppProp = $$props.getAppProp;
	  var loadingBar;
	  var inputSoftwareKey;
	  var qrModal;
	  var qrScanner;
	  var password2FA;
	  var authorizedMenu;
	  var archivedChatListMenu;
	  var contactListMenu;
	  var clearCacheSelector;
	  var undialogList;
	  var unauthorizationStatus;
	  var unconnectionStatus;
	  var uncachedThumbnails;
	  var unauthorizedUser;
	  var webWorkerStatus = false;
	  var name = 'Telekram';
	  var phoneNumber = '';
	  var phoneCode = '';
	  var phoneCodeHash = null;
	  var qrCode = null;
	  var authStatus = false;
	  var archivedChatList = [];
	  var archivedChatListName = [];
	  var user = [];
	  var chatList = [];
	  var thumbs = {};
	  var navOptions = {
	    verticalNavClass: navClass$1,

	    softkeyLeftListener(evt) {
	      if (inputSoftwareKey || qrModal || password2FA) return;
	      if (authStatus) openAuthorizedMenu();
	    },

	    softkeyRightListener(evt) {
	      if (inputSoftwareKey || qrModal || password2FA) return;
	    },

	    enterListener(evt) {
	      if (inputSoftwareKey || qrModal || password2FA) return;
	      var navClasses = document.getElementsByClassName(navClass$1);

	      if (navClasses[this.verticalNavIndex] != null) {
	        navClasses[this.verticalNavIndex].click();
	      }
	    },

	    backspaceListener(evt) {},

	    arrowLeftListener(evt) {},

	    arrowRightListener(evt) {}

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function openArchivedChatListMenu() {
	    archivedChatListMenu = new ArchivedChats({
	      target: document.body,
	      props: {
	        title: 'Archived Chats',
	        focusIndex: 0,
	        options: archivedChatList,
	        thumbs,
	        softKeyLeftText: 'Unarchive',
	        softKeyCenterText: 'Select',
	        softKeyRightText: '',
	        onSoftkeyRight: (evt, scope) => {
	          archivedChatListMenu.$destroy();
	        },
	        onSoftkeyLeft: (evt, scope) => {
	          archivedChatListMenu.$destroy();
	        },
	        onEnter: (evt, scope) => {
	          archivedChatListMenu.$destroy();
	          setTimeout(() => {
	            openRoom(scope.selected.name, scope.selected);
	          }, 100);
	        },
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          archivedChatListMenu.$destroy();
	        },
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: scope => {
	          navInstance.attachListener();
	          archivedChatListMenu = null;
	        }
	      }
	    });
	  }

	  function getContacts() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var result = yield client.invoke(new Api.contacts.GetContacts());
	        var sorted = result.users.sort((a, b) => {
	          return [a.firstName || '', a.lastName || '', a.phone || ''].join(' ').localeCompare([b.firstName || '', b.lastName || '', b.phone || ''].join(' '));
	        });
	        contactListMenu = new ContactList({
	          target: document.body,
	          props: {
	            title: 'Contact List',
	            focusIndex: 0,
	            sources: sorted,
	            thumbs,
	            softKeyLeftText: 'Search',
	            softKeyCenterText: 'Chat',
	            softKeyRightText: '',
	            onEnter: (evt, scope) => {
	              contactListMenu.$destroy();
	              setTimeout(() => __awaiter(this, void 0, void 0, function* () {
	                if (scope.selected) {
	                  var chat = [...chatList, ...archivedChatList].find(c => scope.selected.id.value.toString() === c.id.value.toString());

	                  if (chat != null) {
	                    openRoom(chat.name, chat);
	                  } else {
	                    var _name = '';
	                    if (scope.selected.firstName) _name = scope.selected.firstName;
	                    if (scope.selected.lastName) _name += ' ' + scope.selected.lastName;
	                    if (_name === '' && scope.selected.username) _name = scope.selected.username;else if (_name === '' && scope.selected.phone) _name = scope.selected.phone;else if (_name === '') _name = scope.selected.id.value.toString();
	                    openRoom(_name, {
	                      entity: scope.selected
	                    });
	                  }
	                }
	              }), 100);
	            },
	            onBackspace: (evt, scope) => {
	              evt.preventDefault();
	              evt.stopPropagation();
	              contactListMenu.$destroy();
	            },
	            onOpened: () => {
	              navInstance.detachListener();
	            },
	            onClosed: scope => {
	              navInstance.attachListener();
	              contactListMenu = null;
	            }
	          }
	        });
	      } catch (err) {
	        console.log(err);
	      }
	    });
	  }

	  function getSavedContacts() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var result = yield client.invoke(new Api.contacts.GetSaved());
	        console.log(result);
	      } catch (err) {
	        if (err.errorMessage === "TAKEOUT_REQUIRED") {
	          getContactsFallback();
	        }
	      }
	    });
	  }

	  function getSavedContactsFallback() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var result = yield client.invoke(new Api.account.InitTakeoutSession({
	          contacts: true
	        }));
	        result = yield client.invoke(new Api.InvokeWithTakeout({
	          takeoutId: result.id,
	          query: new Api.contacts.GetSaved()
	        }));
	        console.log(result);
	      } catch (err) {
	        console.log(err);
	      }
	    });
	  }

	  function clearCache() {
	    clearCacheSelector = new MultiSelector({
	      target: document.body,
	      props: {
	        title: 'Clear Cache',
	        focusIndex: 0,
	        options: [{
	          title: 'Profile Photos',
	          checked: false
	        }, {
	          title: 'Chat Preferences',
	          checked: false
	        }, {
	          title: 'Media Attachments',
	          checked: false
	        }, {
	          title: 'Offline Webpages',
	          checked: false
	        }],
	        softKeyLeftText: 'Cancel',
	        softKeyRightText: 'Done',
	        softKeyCenterTextSelect: 'select',
	        softKeyCenterTextDeselect: 'deselect',
	        onSoftkeyLeft: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          clearCacheSelector.$destroy();
	        },
	        onSoftkeyRight: (evt, scope) => {
	          scope.options.forEach(item => {
	            if (item.checked) {
	              var splits = item.title.split(' ');
	              splits[0] = splits[0].charAt(0).toLowerCase() + splits[0].slice(1);
	              cachedDatabase.then(db => {
	                db.clear(splits.join(''));
	              }).catch(err => {
	                console.log(err);
	              });
	            }
	          });
	          evt.preventDefault();
	          evt.stopPropagation();
	          clearCacheSelector.$destroy();
	        },
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          clearCacheSelector.$destroy();
	        },
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: scope => {
	          navInstance.attachListener();
	          clearCacheSelector = null;
	        }
	      }
	    });
	  }

	  function openAuthorizedMenu() {
	    return __awaiter(this, void 0, void 0, function* () {
	      authorizedMenu = new OptionMenu({
	        target: document.body,
	        props: {
	          title: user.length > 0 ? `Hi ${user[0].username}` : 'Menu',
	          focusIndex: 0,
	          options: [{
	            title: 'New Contact'
	          }, {
	            title: 'Contacts'
	          }, {
	            title: 'Settings'
	          }, // { title: 'Link Device' },
	          {
	            title: 'Subscribe Notification'
	          }, {
	            title: 'Clear Cache'
	          }, {
	            title: 'Logout'
	          }, {
	            title: 'Exit'
	          }],
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	            authorizedMenu.$destroy();

	            if (scope.selected.title === 'Contacts') {
	              getContacts();
	            } else if (scope.selected.title === 'Link Device') {
	              linkDevice();
	            } else if (scope.selected.title === 'Subscribe Notification') {
	              manuallySubscribePushNotification(client).then(() => {
	                alert('Success');
	              }).catch(err => {
	                alert('Fail: ' + err.toString());
	              });
	            } else if (scope.selected.title === 'Clear Cache') {
	              clearCache();
	            } else if (scope.selected.title === 'Logout') {
	              signOut();
	            } else if (scope.selected.title === 'Exit') {
	              window.close();
	            }
	          }),
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            authorizedMenu.$destroy();
	          },
	          onOpened: () => {
	            navInstance.detachListener();
	          },
	          onClosed: scope => {
	            navInstance.attachListener();
	            authorizedMenu = null;
	          }
	        }
	      });
	    });
	  }

	  function resetCursor() {
	    if (qrModal != null || password2FA != null) return;
	    navInstance.verticalNavIndex = 0;
	    setTimeout(() => {
	      navInstance.navigateListNav(0);
	      setTimeout(() => {
	        var cursor = document.getElementsByClassName(navClass$1)[navInstance.verticalNavIndex];

	        if (cursor) {
	          cursor.classList.add('focus');
	        }
	      }, 150);
	    }, 150);
	  }

	  function toastMessage() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'I\'m out after 2 second';
	    var t = new SvelteToast({
	      target: document.body,
	      props: {
	        options: {}
	      }
	    });
	    toast.push(text, {
	      dismissable: false,
	      intro: {
	        y: -64
	      },
	      duration: 2000,
	      onpop: () => {
	        setTimeout(() => {
	          t.$destroy();
	        }, 4000);
	      }
	    });
	  }

	  function showLoadingBar() {
	    loadingBar = new LoadingBar({
	      target: document.body,
	      props: {
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: () => {
	          navInstance.attachListener();
	          loadingBar = null;
	        }
	      }
	    });
	  }

	  function onInputPhoneNumber(evt) {
	    $$invalidate(1, phoneNumber = evt.target.value.trim().toString());
	  }

	  function onInputPhoneCode(evt) {
	    $$invalidate(2, phoneCode = evt.target.value.trim().toString());
	  }

	  function onFocus(evt) {
	    if (qrModal != null || password2FA != null) return;
	    inputSoftwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: '',
	        centerText: 'Enter',
	        rightText: ''
	      }
	    });
	  }

	  function onBlur(evt) {
	    if (inputSoftwareKey) {
	      inputSoftwareKey.$destroy();
	      inputSoftwareKey = null;
	    }
	  } // EVENT 2


	  function sendCode() {
	    if (!webWorkerStatus) return;
	    var params = {
	      type: 2,
	      params: {
	        phoneNumber,
	        apiId: TelegramKeyHash.api_id,
	        apiHash: TelegramKeyHash.api_hash,
	        settings: {
	          allowFlashcall: true,
	          currentNumber: true,
	          allowAppHash: true
	        }
	      }
	    };
	    if (loadingBar == null) showLoadingBar();
	    dispatchMessageToWorker.emit('message', params);
	  } // EVENT 3


	  function signIn() {
	    if (!webWorkerStatus) return;
	    var params = {
	      type: 3,
	      params: {
	        phoneNumber,
	        phoneCodeHash,
	        phoneCode
	      }
	    };
	    if (loadingBar == null) showLoadingBar();
	    dispatchMessageToWorker.emit('message', params);
	  } // EVENT 4


	  function signIn2FA() {
	    if (!webWorkerStatus) return;
	    password2FA = new TextInputDialog({
	      target: document.body,
	      props: {
	        title: '2FA Password',
	        softKeyCenterText: 'ok',
	        softKeyRightText: 'Cancel',
	        value: '',
	        placeholder: 'Password',
	        type: 'text',
	        onSoftkeyLeft: (evt, value) => {},
	        onSoftkeyRight: (evt, value) => {
	          password2FA.$destroy();
	        },
	        onEnter: (evt, password) => {
	          var params = {
	            type: 4,
	            params: {
	              apiId: TelegramKeyHash.api_id,
	              apiHash: TelegramKeyHash.api_hash,
	              password
	            }
	          };
	          if (loadingBar == null) showLoadingBar();
	          dispatchMessageToWorker.emit('message', params);
	        },
	        onBackspace: (evt, value) => {
	          evt.stopPropagation();
	        },
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: value => {
	          navInstance.attachListener();
	          password2FA = null;
	        }
	      }
	    });
	  } // EVENT 5


	  function signInQR() {
	    if (!webWorkerStatus) return;
	    setTimeout(() => {
	      qrModal = new QRModal({
	        target: document.body,
	        props: {
	          title: 'Log-In via QR Code',
	          onBackspace: evt => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            qrModal.$destroy();
	          },
	          onOpened: () => {
	            navInstance.detachListener();
	          },
	          onClosed: () => {
	            navInstance.attachListener();
	            qrModal = null;
	          }
	        }
	      });
	    }, 100);
	  } // EVENT 6


	  function exportLoginToken() {
	    if (!webWorkerStatus) return;
	    var params = {
	      type: 6,
	      params: {
	        apiId: TelegramKeyHash.api_id,
	        apiHash: TelegramKeyHash.api_hash,
	        exceptIds: []
	      }
	    };
	    if (loadingBar == null) showLoadingBar();
	    dispatchMessageToWorker.emit('message', params);
	  } // EVENT 7


	  function importLoginToken(token) {
	    if (!webWorkerStatus) return;
	    var params = {
	      type: 7,
	      params: {
	        token
	      }
	    };
	    if (loadingBar == null) showLoadingBar();
	    dispatchMessageToWorker.emit('message', params);
	  } // EVENT 8


	  function acceptLoginToken(token) {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        console.log(0, token);
	        token = token.padRight(token.length + (4 - token.length % 4) % 4, '=');
	        console.log(1, token);
	        console.log(2, base64url.parse(token), buffer.Buffer.from(token, "base64")); //return; // TODO DEBUG

	        var result = yield client.invoke(new Api.auth.AcceptLoginToken({
	          token: buffer.Buffer.from(token, "base64")
	        }));
	        console.log(result);
	        toastMessage('Success');
	      } catch (err) {
	        console.log(err);
	        toastMessage(err.errorMessage || "ERROR ACCEPT LOGIN TOKEN");
	      }
	    });
	  }

	  function resetSignIn() {
	    $$invalidate(3, phoneCodeHash = null);
	    resetCursor();
	  }

	  function signOut() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var pushSubscription = yield (yield cachedDatabase).get('appPreferences', 'pushSubscription');

	        if (pushSubscription != null) {
	          yield unregisterDevice(client, pushSubscription);

	          try {
	            yield unsubscribePush();
	          } catch (err) {}
	        }

	        var result = yield client.invoke(new Api.auth.LogOut({}));
	        isUserAuthorized();
	        $$invalidate(3, phoneCodeHash = null);
	      } catch (err) {
	        console.log(err);
	      }
	    });
	  }

	  function linkDevice() {
	    qrScanner = new QRScanner({
	      target: document.body,
	      props: {
	        title: 'Link Device',
	        onBackspace: evt => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          qrScanner.$destroy();
	        },
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: () => {
	          navInstance.attachListener();
	          qrScanner = null;
	        },
	        callback: token => {
	          qrScanner.$destroy();
	          acceptLoginToken(token);
	        }
	      }
	    });
	  }

	  function sortChats(chats) {
	    try {
	      $$invalidate(6, archivedChatListName = []);
	      $$invalidate(5, archivedChatList = []);
	      var tempChatList = [];
	      chats.forEach((chat, index) => {
	        if (chat.archived) {
	          if (archivedChatListName.length !== 3) {
	            archivedChatListName.push(chat.name);
	            if (archivedChatListName.length === 2) archivedChatListName.push('more...');
	          }

	          archivedChatList.push(chat);
	        } else {
	          tempChatList.push(chat);
	        }
	      });
	      $$invalidate(8, chatList = tempChatList);

	      if (window['HOME_LOADED'] == null) {
	        setTimeout(() => {
	          navInstance.navigateListNav(1);
	          setTimeout(() => {
	            navInstance.navigateListNav(-1);
	          }, 100);
	        }, 100);
	        window['HOME_LOADED'] = true;
	      }
	    } catch (err) {
	      console.log(err.toString());
	    }
	  }

	  function openRoom(name, chat) {
	    return __awaiter(this, void 0, void 0, function* () {
	      var scrollAt = null;

	      try {
	        var pref = yield (yield cachedDatabase).get('chatPreferences', chat.entity.id.value.toString());
	        scrollAt = pref['scrollAt'];
	      } catch (err) {
	        console.log(err);
	      } // console.log(chat.entity, chat.entity.bot, chat.entity.botNochats);


	      navigate('room', {
	        state: {
	          name,
	          entity: chat.entity.toJSON(),
	          scrollAt
	        }
	      });
	    });
	  }

	  function getThumb(chat) {
	    if (chat.entity.__isSavedMessages) {
	      return `<img alt="icon" style="background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;"" src="/icons/saved.png"/>`;
	    }

	    if (thumbs[chat.iconRef]) {
	      return `<img alt="icon" style="background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;"" src="${thumbs[chat.iconRef]}"/>`;
	    }

	    return `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;font-weight:bold;color:#fff;background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;">${chat.name.split(' ').map(text => text[0]).splice(0, 2).join('')}</div>`;
	  }

	  function handleWebWorkerMessage(data) {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        // console.log('dispatchMessageToClient:', data.type);
	        switch (data.type) {
	          case -1:
	            console.error('Error', data.params);
	            break;

	          case 0:
	            console.log('Connected to authenticationWebWorker');
	            break;

	          case 1:
	            console.log('authenticationWebWorker.client.event:', data.params);
	            if (data.params.state && data.params.state === 1) $$invalidate(0, webWorkerStatus = true);else if (data.params.state && data.params.state === -1) $$invalidate(0, webWorkerStatus = false);

	            if (data.params.data && data.params.data.className === "UpdateLoginToken") {
	              exportLoginToken();

	              if (qrModal) {
	                qrModal.$destroy();
	              }
	            }

	            break;

	          case 2:
	            if (loadingBar) loadingBar.$destroy();
	            console.log('sendCode:', data.params.phoneCodeHash);
	            $$invalidate(3, phoneCodeHash = data.params.phoneCodeHash);
	            resetCursor();
	            break;

	          case -2:
	            if (loadingBar) loadingBar.$destroy();
	            console.error('sendCode:', data.params);
	            toastMessage(data.params || "ERROR SEND CODE");
	            break;

	          case 3:
	            if (loadingBar) loadingBar.$destroy();
	            console.log('signIn:', data.params.session.authKey, data.params.session.dcId);
	            resetCursor();
	            $$invalidate(3, phoneCodeHash = null);

	            if (data.params.session) {
	              var authKey = new AuthKey(data.params.session.authKey._key, data.params.session.authKey._hash);
	              session.setDC(data.params.session.dcId, data.params.session.serverAddress, data.params.session.port);
	              session.setAuthKey(authKey);
	              session.authKey = authKey;
	              var typedArray = authKey.getKey();
	              var arr = Array.from ? Array.from(typedArray) : [].map.call(typedArray, v => v);
	              var str = JSON.stringify(arr);
	              window.localStorage.setItem('gramjs:authKey', `{ "type": "Buffer", "data": ${str} }`);
	              alert('Please re-launch the app');
	              window.close();
	            }

	            break;

	          case -3:
	            if (loadingBar) loadingBar.$destroy();
	            console.error('signIn:', data.params);

	            if (data.params !== 'SESSION_PASSWORD_NEEDED') {
	              console.error('signIn:', data.params);
	              toastMessage(data.params || "ERROR SIGN IN");
	              return;
	            }

	            signIn2FA();
	            break;

	          case 4:
	            if (loadingBar) loadingBar.$destroy();
	            console.log('signIn2FA:', data.params);

	            if (password2FA) {
	              password2FA.$destroy();
	            }

	            resetCursor();
	            $$invalidate(3, phoneCodeHash = null);

	            if (data.params.session) {
	              var _authKey = new AuthKey(data.params.session.authKey._key, data.params.session.authKey._hash);

	              session.setDC(data.params.session.dcId, data.params.session.serverAddress, data.params.session.port);
	              session.setAuthKey(_authKey);
	              session.authKey = _authKey;

	              var _typedArray = _authKey.getKey();

	              var _arr = Array.from ? Array.from(_typedArray) : [].map.call(_typedArray, v => v);

	              var _str = JSON.stringify(_arr);

	              window.localStorage.setItem('gramjs:authKey', `{ "type": "Buffer", "data": ${_str} }`);
	              alert('Please re-launch the app');
	              window.close();
	            }

	            break;

	          case -4:
	            if (loadingBar) loadingBar.$destroy();
	            console.error('signIn2FA:', data.params);
	            toastMessage(data.params || "ERROR SIGN IN 2FA");
	            break;

	          case 6:
	            if (loadingBar) loadingBar.$destroy();
	            console.log('exportLoginToken:', data.params);

	            if (data.params.result.className.toLocaleLowerCase() === 'auth.LoginTokenSuccess'.toLocaleLowerCase()) {
	              resetCursor();
	              $$invalidate(3, phoneCodeHash = null);

	              if (data.params.session) {
	                var _authKey2 = new AuthKey(data.params.session.authKey._key, data.params.session.authKey._hash);

	                session.setDC(data.params.session.dcId, data.params.session.serverAddress, data.params.session.port);
	                session.setAuthKey(_authKey2);
	                session.authKey = _authKey2;

	                var _typedArray2 = _authKey2.getKey();

	                var _arr2 = Array.from ? Array.from(_typedArray2) : [].map.call(_typedArray2, v => v);

	                var _str2 = JSON.stringify(_arr2);

	                window.localStorage.setItem('gramjs:authKey', `{ "type": "Buffer", "data": ${_str2} }`);
	                alert('Please re-launch the app');
	                window.close();
	              }
	            } else if (['auth.logintoken', 'auth.logintokensuccess', 'auth.logintokenmigrateto'].indexOf(data.params.result.className.toLocaleLowerCase() > -1)) {
	              importLoginToken(data.params.result.token);
	            } else {
	              console.error('importLoginToken', data.params.result);
	              toastMessage(data.params.result.className || "ERROR IMPORT LOGIN TOKEN"); // TODO DEBUG
	            }

	            break;

	          case -6:
	            if (loadingBar) loadingBar.$destroy();
	            console.log('exportLoginToken:', data.params);

	            if (data.params !== 'SESSION_PASSWORD_NEEDED') {
	              console.error('exportLoginToken:', data.params);
	              toastMessage(data.params || "ERROR EXPORT LOGIN TOKEN"); // TODO DEBUG

	              return;
	            }

	            signIn2FA();
	            break;

	          case 7:
	            console.log('importLoginToken:', data.params);
	            resetCursor();
	            $$invalidate(3, phoneCodeHash = null);

	            if (data.params.session) {
	              var _authKey3 = new AuthKey(data.params.session.authKey._key, data.params.session.authKey._hash);

	              session.setDC(data.params.session.dcId, data.params.session.serverAddress, data.params.session.port);
	              session.setAuthKey(_authKey3);
	              session.authKey = _authKey3;

	              var _typedArray3 = _authKey3.getKey();

	              var _arr3 = Array.from ? Array.from(_typedArray3) : [].map.call(_typedArray3, v => v);

	              var _str3 = JSON.stringify(_arr3);

	              window.localStorage.setItem('gramjs:authKey', `{ "type": "Buffer", "data": ${_str3} }`);
	              alert('Please re-launch the app');
	              window.close();
	            }

	            break;

	          case -7:
	            if (loadingBar) loadingBar.$destroy();
	            console.error('importLoginToken:', data.params);
	            toastMessage(data.params || "ERROR IMPORT LOGIN TOKEN");
	            break;
	        }
	      } catch (err) {
	        console.error('dispatchMessageToClient:', err);
	      }
	    });
	  }

	  onMount(() => {
	    var _getAppProp = getAppProp(),
	        appBar = _getAppProp.appBar,
	        softwareKey = _getAppProp.softwareKey;

	    appBar.setTitleText(name);
	    softwareKey.setText({
	      left: '',
	      center: 'SELECT',
	      right: ''
	    });
	    navInstance.attachListener();
	    undialogList = dialogList.subscribe(chats => {
	      if (client.connected) {
	        sortChats(chats);
	      }
	    });
	    unconnectionStatus = connectionStatus.subscribe(status => {}); // console.log(status);

	    unauthorizationStatus = authorizationStatus.subscribe(status => {
	      $$invalidate(4, authStatus = status);

	      if (status) {
	        softwareKey.setLeftText('Menu');
	        softwareKey.setRightText('Search');

	        if (inputSoftwareKey) {
	          inputSoftwareKey.$destroy();
	          inputSoftwareKey = null;
	        }

	        if (qrModal) {
	          qrModal.$destroy();
	          qrModal = null;
	        }

	        if (password2FA) {
	          password2FA.$destroy();
	          password2FA = null;
	        }
	      } else {
	        softwareKey.setLeftText('');
	        softwareKey.setRightText('');
	      }
	    });
	    uncachedThumbnails = cachedThumbnails.subscribe(data => {
	      thumbs = data;
	      $$invalidate(8, chatList = [...chatList]);
	    });
	    unauthorizedUser = authorizedUser.subscribe(data => {
	      $$invalidate(7, user = data);
	    });
	    dispatchMessageToClient.addListener('message', handleWebWorkerMessage);

	    if (get_store_value(shouldGetDialogs)) {
	      getDialogs();
	      shouldGetDialogs.update(n => false);
	    }
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    if (undialogList) undialogList();
	    if (unauthorizationStatus) unauthorizationStatus();
	    if (unconnectionStatus) unconnectionStatus();
	    if (uncachedThumbnails) uncachedThumbnails();
	    if (unauthorizedUser) unauthorizedUser();
	    dispatchMessageToClient.removeListener('message', handleWebWorkerMessage);
	  });
	  var writable_props = ['location', 'navigate', 'getAppProp'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$b.warn(`<Home> was created with unknown prop '${key}'`);
	  });

	  var func = () => window.close();

	  var func_1 = chat => openRoom(chat.name, chat);

	  $$self.$$set = $$props => {
	    if ('location' in $$props) $$invalidate(20, location = $$props.location);
	    if ('navigate' in $$props) $$invalidate(21, navigate$1 = $$props.navigate);
	    if ('getAppProp' in $$props) $$invalidate(22, getAppProp = $$props.getAppProp);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    goto: navigate,
	    get: get_store_value,
	    createKaiNavigator,
	    ListView,
	    LoadingBar,
	    Button,
	    TextInputField,
	    Toast: SvelteToast,
	    Toaster: toast,
	    SoftwareKey,
	    TextInputDialog,
	    OptionMenu,
	    MultiSelector,
	    onMount,
	    onDestroy,
	    base64url,
	    Buffer: buffer.Buffer,
	    TelegramKeyHash,
	    Api,
	    AuthKey,
	    client,
	    session,
	    cachedDatabase,
	    QRModal,
	    QRScanner,
	    ChatListView,
	    ArchivedChats,
	    ContactList,
	    connectionStatus,
	    authorizationStatus,
	    isUserAuthorized,
	    getDialogs,
	    shouldGetDialogs,
	    authorizedUser,
	    dialogList,
	    cachedThumbnails,
	    dispatchMessageToClient,
	    dispatchMessageToWorker,
	    unsubscribePush,
	    unregisterDevice,
	    manuallySubscribePushNotification,
	    navClass: navClass$1,
	    location,
	    navigate: navigate$1,
	    getAppProp,
	    loadingBar,
	    inputSoftwareKey,
	    qrModal,
	    qrScanner,
	    password2FA,
	    authorizedMenu,
	    archivedChatListMenu,
	    contactListMenu,
	    clearCacheSelector,
	    undialogList,
	    unauthorizationStatus,
	    unconnectionStatus,
	    uncachedThumbnails,
	    unauthorizedUser,
	    webWorkerStatus,
	    name,
	    phoneNumber,
	    phoneCode,
	    phoneCodeHash,
	    qrCode,
	    authStatus,
	    archivedChatList,
	    archivedChatListName,
	    user,
	    chatList,
	    thumbs,
	    navOptions,
	    navInstance,
	    openArchivedChatListMenu,
	    getContacts,
	    getSavedContacts,
	    getSavedContactsFallback,
	    clearCache,
	    openAuthorizedMenu,
	    resetCursor,
	    toastMessage,
	    showLoadingBar,
	    onInputPhoneNumber,
	    onInputPhoneCode,
	    onFocus,
	    onBlur,
	    sign_up,
	    sendCode,
	    signIn,
	    signIn2FA,
	    signInQR,
	    exportLoginToken,
	    importLoginToken,
	    acceptLoginToken,
	    resetSignIn,
	    signOut,
	    linkDevice,
	    openSMS,
	    sortChats,
	    openRoom,
	    getThumb,
	    handleWebWorkerMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('location' in $$props) $$invalidate(20, location = $$props.location);
	    if ('navigate' in $$props) $$invalidate(21, navigate$1 = $$props.navigate);
	    if ('getAppProp' in $$props) $$invalidate(22, getAppProp = $$props.getAppProp);
	    if ('loadingBar' in $$props) loadingBar = $$props.loadingBar;
	    if ('inputSoftwareKey' in $$props) inputSoftwareKey = $$props.inputSoftwareKey;
	    if ('qrModal' in $$props) qrModal = $$props.qrModal;
	    if ('qrScanner' in $$props) qrScanner = $$props.qrScanner;
	    if ('password2FA' in $$props) password2FA = $$props.password2FA;
	    if ('authorizedMenu' in $$props) authorizedMenu = $$props.authorizedMenu;
	    if ('archivedChatListMenu' in $$props) archivedChatListMenu = $$props.archivedChatListMenu;
	    if ('contactListMenu' in $$props) contactListMenu = $$props.contactListMenu;
	    if ('clearCacheSelector' in $$props) clearCacheSelector = $$props.clearCacheSelector;
	    if ('undialogList' in $$props) undialogList = $$props.undialogList;
	    if ('unauthorizationStatus' in $$props) unauthorizationStatus = $$props.unauthorizationStatus;
	    if ('unconnectionStatus' in $$props) unconnectionStatus = $$props.unconnectionStatus;
	    if ('uncachedThumbnails' in $$props) uncachedThumbnails = $$props.uncachedThumbnails;
	    if ('unauthorizedUser' in $$props) unauthorizedUser = $$props.unauthorizedUser;
	    if ('webWorkerStatus' in $$props) $$invalidate(0, webWorkerStatus = $$props.webWorkerStatus);
	    if ('name' in $$props) name = $$props.name;
	    if ('phoneNumber' in $$props) $$invalidate(1, phoneNumber = $$props.phoneNumber);
	    if ('phoneCode' in $$props) $$invalidate(2, phoneCode = $$props.phoneCode);
	    if ('phoneCodeHash' in $$props) $$invalidate(3, phoneCodeHash = $$props.phoneCodeHash);
	    if ('qrCode' in $$props) qrCode = $$props.qrCode;
	    if ('authStatus' in $$props) $$invalidate(4, authStatus = $$props.authStatus);
	    if ('archivedChatList' in $$props) $$invalidate(5, archivedChatList = $$props.archivedChatList);
	    if ('archivedChatListName' in $$props) $$invalidate(6, archivedChatListName = $$props.archivedChatListName);
	    if ('user' in $$props) $$invalidate(7, user = $$props.user);
	    if ('chatList' in $$props) $$invalidate(8, chatList = $$props.chatList);
	    if ('thumbs' in $$props) thumbs = $$props.thumbs;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [webWorkerStatus, phoneNumber, phoneCode, phoneCodeHash, authStatus, archivedChatList, archivedChatListName, user, chatList, openArchivedChatListMenu, onInputPhoneNumber, onInputPhoneCode, onFocus, onBlur, sendCode, signIn, signInQR, resetSignIn, openRoom, getThumb, location, navigate$1, getAppProp, func, func_1];
	}

	class Home extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$V, create_fragment$V, safe_not_equal, {
	      location: 20,
	      navigate: 21,
	      getAppProp: 22
	    }, null, [-1, -1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Home",
	      options,
	      id: create_fragment$V.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*location*/
	    ctx[20] === undefined && !('location' in props)) {
	      console_1$b.warn("<Home> was created without expected prop 'location'");
	    }

	    if (
	    /*navigate*/
	    ctx[21] === undefined && !('navigate' in props)) {
	      console_1$b.warn("<Home> was created without expected prop 'navigate'");
	    }

	    if (
	    /*getAppProp*/
	    ctx[22] === undefined && !('getAppProp' in props)) {
	      console_1$b.warn("<Home> was created without expected prop 'getAppProp'");
	    }
	  }

	  get location() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set location(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get navigate() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set navigate(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get getAppProp() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set getAppProp(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$U = "src/widgets/message/Dummy.svelte";

	function create_fragment$U(ctx) {
	  var div1;
	  var div0;
	  var p;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[1].action.className + "";
	  var t1;
	  var div1_class_value;
	  var mounted;
	  var dispose;
	  var block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      p = element("p");
	      t0 = text("Unsupported: ");
	      t1 = text(t1_value);
	      attr_dev(p, "class", "svelte-o6pczi");
	      add_location(p, file$U, 24, 4, 835);
	      attr_dev(div0, "class", "kai-list-view-content svelte-o6pczi");
	      add_location(div0, file$U, 23, 2, 795);
	      attr_dev(div1, "data-key",
	      /*key*/
	      ctx[0]);
	      attr_dev(div1, "class", div1_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[2] ?
	      /*className*/
	      ctx[2] : '') + " svelte-o6pczi");
	      add_location(div1, file$U, 22, 0, 700);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      append_dev(div0, p);
	      append_dev(p, t0);
	      append_dev(p, t1);

	      if (!mounted) {
	        dispose = listen_dev(div1, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[3]))
	            /*onClick*/
	            ctx[3].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;
	      if (dirty &
	      /*message*/
	      2 && t1_value !== (t1_value =
	      /*message*/
	      ctx[1].action.className + "")) set_data_dev(t1, t1_value);

	      if (dirty &
	      /*key*/
	      1) {
	        attr_dev(div1, "data-key",
	        /*key*/
	        ctx[0]);
	      }

	      if (dirty &
	      /*className*/
	      4 && div1_class_value !== (div1_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[2] ?
	      /*className*/
	      ctx[2] : '') + " svelte-o6pczi")) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div1);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$U.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$U($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Dummy', slots, []);
	  var _$$props$key = $$props.key,
	      key = _$$props$key === void 0 ? '' : _$$props$key;
	  var _$$props$entity = $$props.entity,
	      entity = _$$props$entity === void 0 ? {} : _$$props$entity;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? null : _$$props$className;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$destroyCallb = $$props.destroyCallback,
	      destroyCallback = _$$props$destroyCallb === void 0 ? () => {} : _$$props$destroyCallb;
	  var replyTo = $$props.replyTo;
	  var _$$props$short = $$props.short,
	      short = _$$props$short === void 0 ? false : _$$props$short;
	  var navOptions = {
	    softkeyLeftListener(evt) {},

	    softkeyRightListener(evt) {},

	    enterListener(evt) {},

	    backspaceListener(evt) {}

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {});
	  var writable_props = ['key', 'entity', 'message', 'className', 'onClick', 'parentNavInstance', 'registerCallButtonHandler', 'destroyCallback', 'replyTo', 'short'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dummy> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('entity' in $$props) $$invalidate(4, entity = $$props.entity);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('className' in $$props) $$invalidate(2, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(3, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('destroyCallback' in $$props) $$invalidate(7, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(8, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(9, short = $$props.short);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    createKaiNavigator,
	    key,
	    entity,
	    message,
	    className,
	    onClick,
	    parentNavInstance,
	    registerCallButtonHandler,
	    destroyCallback,
	    replyTo,
	    short,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('entity' in $$props) $$invalidate(4, entity = $$props.entity);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('className' in $$props) $$invalidate(2, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(3, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('destroyCallback' in $$props) $$invalidate(7, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(8, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(9, short = $$props.short);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [key, message, className, onClick, entity, parentNavInstance, registerCallButtonHandler, destroyCallback, replyTo, short];
	}

	class Dummy$2 extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$U, create_fragment$U, safe_not_equal, {
	      key: 0,
	      entity: 4,
	      message: 1,
	      className: 2,
	      onClick: 3,
	      parentNavInstance: 5,
	      registerCallButtonHandler: 6,
	      destroyCallback: 7,
	      replyTo: 8,
	      short: 9
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Dummy",
	      options,
	      id: create_fragment$U.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[5] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<Dummy> was created without expected prop 'parentNavInstance'");
	    }

	    if (
	    /*replyTo*/
	    ctx[8] === undefined && !('replyTo' in props)) {
	      console.warn("<Dummy> was created without expected prop 'replyTo'");
	    }
	  }

	  get key() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set key(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get entity() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set entity(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get className() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set className(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get onClick() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set onClick(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get destroyCallback() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set destroyCallback(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get replyTo() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set replyTo(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get short() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set short(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var FileSaver_min = createCommonjsModule(function (module, exports) {
	  (function (a, b) {
	    b();
	  })(commonjsGlobal, function () {

	    function b(a, b) {
	      return "undefined" == typeof b ? b = {
	        autoBom: !1
	      } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
	        autoBom: !b
	      }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], {
	        type: a.type
	      }) : a;
	    }

	    function c(a, b, c) {
	      var d = new XMLHttpRequest();
	      d.open("GET", a), d.responseType = "blob", d.onload = function () {
	        g(d.response, b, c);
	      }, d.onerror = function () {
	        console.error("could not download file");
	      }, d.send();
	    }

	    function d(a) {
	      var b = new XMLHttpRequest();
	      b.open("HEAD", a, !1);

	      try {
	        b.send();
	      } catch (a) {}

	      return 200 <= b.status && 299 >= b.status;
	    }

	    function e(a) {
	      try {
	        a.dispatchEvent(new MouseEvent("click"));
	      } catch (c) {
	        var b = document.createEvent("MouseEvents");
	        b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
	      }
	    }

	    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0,
	        a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
	        g = f.saveAs || ("object" != typeof window || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype && !a ? function (b, g, h) {
	      var i = f.URL || f.webkitURL,
	          j = document.createElement("a");
	      g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
	        i.revokeObjectURL(j.href);
	      }, 4E4), setTimeout(function () {
	        e(j);
	      }, 0));
	    } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
	      if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
	        var i = document.createElement("a");
	        i.href = f, i.target = "_blank", setTimeout(function () {
	          e(i);
	        });
	      }
	    } : function (b, d, e, g) {
	      if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
	      var h = "application/octet-stream" === b.type,
	          i = /constructor/i.test(f.HTMLElement) || f.safari,
	          j = /CriOS\/[\d]+/.test(navigator.userAgent);

	      if ((j || h && i || a) && "undefined" != typeof FileReader) {
	        var k = new FileReader();
	        k.onloadend = function () {
	          var a = k.result;
	          a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
	        }, k.readAsDataURL(b);
	      } else {
	        var l = f.URL || f.webkitURL,
	            m = l.createObjectURL(b);
	        g ? g.location = m : location.href = m, g = null, setTimeout(function () {
	          l.revokeObjectURL(m);
	        }, 4E4);
	      }
	    });
	    f.saveAs = g.saveAs = g, (module.exports = g);
	  });
	});

	var require$$0$1 = {
		"application/1d-interleaved-parityfec": {
		source: "iana"
	},
		"application/3gpdash-qoe-report+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/3gpp-ims+xml": {
		source: "iana",
		compressible: true
	},
		"application/3gpphal+json": {
		source: "iana",
		compressible: true
	},
		"application/3gpphalforms+json": {
		source: "iana",
		compressible: true
	},
		"application/a2l": {
		source: "iana"
	},
		"application/ace+cbor": {
		source: "iana"
	},
		"application/activemessage": {
		source: "iana"
	},
		"application/activity+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-costmap+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-costmapfilter+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-directory+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-endpointcost+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-endpointcostparams+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-endpointprop+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-endpointpropparams+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-error+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-networkmap+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-networkmapfilter+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-updatestreamcontrol+json": {
		source: "iana",
		compressible: true
	},
		"application/alto-updatestreamparams+json": {
		source: "iana",
		compressible: true
	},
		"application/aml": {
		source: "iana"
	},
		"application/andrew-inset": {
		source: "iana",
		extensions: [
			"ez"
		]
	},
		"application/applefile": {
		source: "iana"
	},
		"application/applixware": {
		source: "apache",
		extensions: [
			"aw"
		]
	},
		"application/at+jwt": {
		source: "iana"
	},
		"application/atf": {
		source: "iana"
	},
		"application/atfx": {
		source: "iana"
	},
		"application/atom+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"atom"
		]
	},
		"application/atomcat+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"atomcat"
		]
	},
		"application/atomdeleted+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"atomdeleted"
		]
	},
		"application/atomicmail": {
		source: "iana"
	},
		"application/atomsvc+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"atomsvc"
		]
	},
		"application/atsc-dwd+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"dwd"
		]
	},
		"application/atsc-dynamic-event-message": {
		source: "iana"
	},
		"application/atsc-held+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"held"
		]
	},
		"application/atsc-rdt+json": {
		source: "iana",
		compressible: true
	},
		"application/atsc-rsat+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rsat"
		]
	},
		"application/atxml": {
		source: "iana"
	},
		"application/auth-policy+xml": {
		source: "iana",
		compressible: true
	},
		"application/bacnet-xdd+zip": {
		source: "iana",
		compressible: false
	},
		"application/batch-smtp": {
		source: "iana"
	},
		"application/bdoc": {
		compressible: false,
		extensions: [
			"bdoc"
		]
	},
		"application/beep+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/calendar+json": {
		source: "iana",
		compressible: true
	},
		"application/calendar+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xcs"
		]
	},
		"application/call-completion": {
		source: "iana"
	},
		"application/cals-1840": {
		source: "iana"
	},
		"application/captive+json": {
		source: "iana",
		compressible: true
	},
		"application/cbor": {
		source: "iana"
	},
		"application/cbor-seq": {
		source: "iana"
	},
		"application/cccex": {
		source: "iana"
	},
		"application/ccmp+xml": {
		source: "iana",
		compressible: true
	},
		"application/ccxml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"ccxml"
		]
	},
		"application/cdfx+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"cdfx"
		]
	},
		"application/cdmi-capability": {
		source: "iana",
		extensions: [
			"cdmia"
		]
	},
		"application/cdmi-container": {
		source: "iana",
		extensions: [
			"cdmic"
		]
	},
		"application/cdmi-domain": {
		source: "iana",
		extensions: [
			"cdmid"
		]
	},
		"application/cdmi-object": {
		source: "iana",
		extensions: [
			"cdmio"
		]
	},
		"application/cdmi-queue": {
		source: "iana",
		extensions: [
			"cdmiq"
		]
	},
		"application/cdni": {
		source: "iana"
	},
		"application/cea": {
		source: "iana"
	},
		"application/cea-2018+xml": {
		source: "iana",
		compressible: true
	},
		"application/cellml+xml": {
		source: "iana",
		compressible: true
	},
		"application/cfw": {
		source: "iana"
	},
		"application/city+json": {
		source: "iana",
		compressible: true
	},
		"application/clr": {
		source: "iana"
	},
		"application/clue+xml": {
		source: "iana",
		compressible: true
	},
		"application/clue_info+xml": {
		source: "iana",
		compressible: true
	},
		"application/cms": {
		source: "iana"
	},
		"application/cnrp+xml": {
		source: "iana",
		compressible: true
	},
		"application/coap-group+json": {
		source: "iana",
		compressible: true
	},
		"application/coap-payload": {
		source: "iana"
	},
		"application/commonground": {
		source: "iana"
	},
		"application/conference-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/cose": {
		source: "iana"
	},
		"application/cose-key": {
		source: "iana"
	},
		"application/cose-key-set": {
		source: "iana"
	},
		"application/cpl+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"cpl"
		]
	},
		"application/csrattrs": {
		source: "iana"
	},
		"application/csta+xml": {
		source: "iana",
		compressible: true
	},
		"application/cstadata+xml": {
		source: "iana",
		compressible: true
	},
		"application/csvm+json": {
		source: "iana",
		compressible: true
	},
		"application/cu-seeme": {
		source: "apache",
		extensions: [
			"cu"
		]
	},
		"application/cwt": {
		source: "iana"
	},
		"application/cybercash": {
		source: "iana"
	},
		"application/dart": {
		compressible: true
	},
		"application/dash+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mpd"
		]
	},
		"application/dash-patch+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mpp"
		]
	},
		"application/dashdelta": {
		source: "iana"
	},
		"application/davmount+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"davmount"
		]
	},
		"application/dca-rft": {
		source: "iana"
	},
		"application/dcd": {
		source: "iana"
	},
		"application/dec-dx": {
		source: "iana"
	},
		"application/dialog-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/dicom": {
		source: "iana"
	},
		"application/dicom+json": {
		source: "iana",
		compressible: true
	},
		"application/dicom+xml": {
		source: "iana",
		compressible: true
	},
		"application/dii": {
		source: "iana"
	},
		"application/dit": {
		source: "iana"
	},
		"application/dns": {
		source: "iana"
	},
		"application/dns+json": {
		source: "iana",
		compressible: true
	},
		"application/dns-message": {
		source: "iana"
	},
		"application/docbook+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"dbk"
		]
	},
		"application/dots+cbor": {
		source: "iana"
	},
		"application/dskpp+xml": {
		source: "iana",
		compressible: true
	},
		"application/dssc+der": {
		source: "iana",
		extensions: [
			"dssc"
		]
	},
		"application/dssc+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xdssc"
		]
	},
		"application/dvcs": {
		source: "iana"
	},
		"application/ecmascript": {
		source: "iana",
		compressible: true,
		extensions: [
			"es",
			"ecma"
		]
	},
		"application/edi-consent": {
		source: "iana"
	},
		"application/edi-x12": {
		source: "iana",
		compressible: false
	},
		"application/edifact": {
		source: "iana",
		compressible: false
	},
		"application/efi": {
		source: "iana"
	},
		"application/elm+json": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/elm+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.cap+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/emergencycalldata.comment+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.control+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.deviceinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.ecall.msd": {
		source: "iana"
	},
		"application/emergencycalldata.providerinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.serviceinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.subscriberinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/emergencycalldata.veds+xml": {
		source: "iana",
		compressible: true
	},
		"application/emma+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"emma"
		]
	},
		"application/emotionml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"emotionml"
		]
	},
		"application/encaprtp": {
		source: "iana"
	},
		"application/epp+xml": {
		source: "iana",
		compressible: true
	},
		"application/epub+zip": {
		source: "iana",
		compressible: false,
		extensions: [
			"epub"
		]
	},
		"application/eshop": {
		source: "iana"
	},
		"application/exi": {
		source: "iana",
		extensions: [
			"exi"
		]
	},
		"application/expect-ct-report+json": {
		source: "iana",
		compressible: true
	},
		"application/express": {
		source: "iana",
		extensions: [
			"exp"
		]
	},
		"application/fastinfoset": {
		source: "iana"
	},
		"application/fastsoap": {
		source: "iana"
	},
		"application/fdt+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"fdt"
		]
	},
		"application/fhir+json": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/fhir+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/fido.trusted-apps+json": {
		compressible: true
	},
		"application/fits": {
		source: "iana"
	},
		"application/flexfec": {
		source: "iana"
	},
		"application/font-sfnt": {
		source: "iana"
	},
		"application/font-tdpfr": {
		source: "iana",
		extensions: [
			"pfr"
		]
	},
		"application/font-woff": {
		source: "iana",
		compressible: false
	},
		"application/framework-attributes+xml": {
		source: "iana",
		compressible: true
	},
		"application/geo+json": {
		source: "iana",
		compressible: true,
		extensions: [
			"geojson"
		]
	},
		"application/geo+json-seq": {
		source: "iana"
	},
		"application/geopackage+sqlite3": {
		source: "iana"
	},
		"application/geoxacml+xml": {
		source: "iana",
		compressible: true
	},
		"application/gltf-buffer": {
		source: "iana"
	},
		"application/gml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"gml"
		]
	},
		"application/gpx+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"gpx"
		]
	},
		"application/gxf": {
		source: "apache",
		extensions: [
			"gxf"
		]
	},
		"application/gzip": {
		source: "iana",
		compressible: false,
		extensions: [
			"gz"
		]
	},
		"application/h224": {
		source: "iana"
	},
		"application/held+xml": {
		source: "iana",
		compressible: true
	},
		"application/hjson": {
		extensions: [
			"hjson"
		]
	},
		"application/http": {
		source: "iana"
	},
		"application/hyperstudio": {
		source: "iana",
		extensions: [
			"stk"
		]
	},
		"application/ibe-key-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/ibe-pkg-reply+xml": {
		source: "iana",
		compressible: true
	},
		"application/ibe-pp-data": {
		source: "iana"
	},
		"application/iges": {
		source: "iana"
	},
		"application/im-iscomposing+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/index": {
		source: "iana"
	},
		"application/index.cmd": {
		source: "iana"
	},
		"application/index.obj": {
		source: "iana"
	},
		"application/index.response": {
		source: "iana"
	},
		"application/index.vnd": {
		source: "iana"
	},
		"application/inkml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"ink",
			"inkml"
		]
	},
		"application/iotp": {
		source: "iana"
	},
		"application/ipfix": {
		source: "iana",
		extensions: [
			"ipfix"
		]
	},
		"application/ipp": {
		source: "iana"
	},
		"application/isup": {
		source: "iana"
	},
		"application/its+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"its"
		]
	},
		"application/java-archive": {
		source: "apache",
		compressible: false,
		extensions: [
			"jar",
			"war",
			"ear"
		]
	},
		"application/java-serialized-object": {
		source: "apache",
		compressible: false,
		extensions: [
			"ser"
		]
	},
		"application/java-vm": {
		source: "apache",
		compressible: false,
		extensions: [
			"class"
		]
	},
		"application/javascript": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"js",
			"mjs"
		]
	},
		"application/jf2feed+json": {
		source: "iana",
		compressible: true
	},
		"application/jose": {
		source: "iana"
	},
		"application/jose+json": {
		source: "iana",
		compressible: true
	},
		"application/jrd+json": {
		source: "iana",
		compressible: true
	},
		"application/jscalendar+json": {
		source: "iana",
		compressible: true
	},
		"application/json": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"json",
			"map"
		]
	},
		"application/json-patch+json": {
		source: "iana",
		compressible: true
	},
		"application/json-seq": {
		source: "iana"
	},
		"application/json5": {
		extensions: [
			"json5"
		]
	},
		"application/jsonml+json": {
		source: "apache",
		compressible: true,
		extensions: [
			"jsonml"
		]
	},
		"application/jwk+json": {
		source: "iana",
		compressible: true
	},
		"application/jwk-set+json": {
		source: "iana",
		compressible: true
	},
		"application/jwt": {
		source: "iana"
	},
		"application/kpml-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/kpml-response+xml": {
		source: "iana",
		compressible: true
	},
		"application/ld+json": {
		source: "iana",
		compressible: true,
		extensions: [
			"jsonld"
		]
	},
		"application/lgr+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"lgr"
		]
	},
		"application/link-format": {
		source: "iana"
	},
		"application/load-control+xml": {
		source: "iana",
		compressible: true
	},
		"application/lost+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"lostxml"
		]
	},
		"application/lostsync+xml": {
		source: "iana",
		compressible: true
	},
		"application/lpf+zip": {
		source: "iana",
		compressible: false
	},
		"application/lxf": {
		source: "iana"
	},
		"application/mac-binhex40": {
		source: "iana",
		extensions: [
			"hqx"
		]
	},
		"application/mac-compactpro": {
		source: "apache",
		extensions: [
			"cpt"
		]
	},
		"application/macwriteii": {
		source: "iana"
	},
		"application/mads+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mads"
		]
	},
		"application/manifest+json": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"webmanifest"
		]
	},
		"application/marc": {
		source: "iana",
		extensions: [
			"mrc"
		]
	},
		"application/marcxml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mrcx"
		]
	},
		"application/mathematica": {
		source: "iana",
		extensions: [
			"ma",
			"nb",
			"mb"
		]
	},
		"application/mathml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mathml"
		]
	},
		"application/mathml-content+xml": {
		source: "iana",
		compressible: true
	},
		"application/mathml-presentation+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-associated-procedure-description+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-deregister+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-envelope+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-msk+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-msk-response+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-protection-description+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-reception-report+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-register+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-register-response+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-schedule+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbms-user-service-description+xml": {
		source: "iana",
		compressible: true
	},
		"application/mbox": {
		source: "iana",
		extensions: [
			"mbox"
		]
	},
		"application/media-policy-dataset+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mpf"
		]
	},
		"application/media_control+xml": {
		source: "iana",
		compressible: true
	},
		"application/mediaservercontrol+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mscml"
		]
	},
		"application/merge-patch+json": {
		source: "iana",
		compressible: true
	},
		"application/metalink+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"metalink"
		]
	},
		"application/metalink4+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"meta4"
		]
	},
		"application/mets+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mets"
		]
	},
		"application/mf4": {
		source: "iana"
	},
		"application/mikey": {
		source: "iana"
	},
		"application/mipc": {
		source: "iana"
	},
		"application/missing-blocks+cbor-seq": {
		source: "iana"
	},
		"application/mmt-aei+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"maei"
		]
	},
		"application/mmt-usd+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"musd"
		]
	},
		"application/mods+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mods"
		]
	},
		"application/moss-keys": {
		source: "iana"
	},
		"application/moss-signature": {
		source: "iana"
	},
		"application/mosskey-data": {
		source: "iana"
	},
		"application/mosskey-request": {
		source: "iana"
	},
		"application/mp21": {
		source: "iana",
		extensions: [
			"m21",
			"mp21"
		]
	},
		"application/mp4": {
		source: "iana",
		extensions: [
			"mp4s",
			"m4p"
		]
	},
		"application/mpeg4-generic": {
		source: "iana"
	},
		"application/mpeg4-iod": {
		source: "iana"
	},
		"application/mpeg4-iod-xmt": {
		source: "iana"
	},
		"application/mrb-consumer+xml": {
		source: "iana",
		compressible: true
	},
		"application/mrb-publish+xml": {
		source: "iana",
		compressible: true
	},
		"application/msc-ivr+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/msc-mixer+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/msword": {
		source: "iana",
		compressible: false,
		extensions: [
			"doc",
			"dot"
		]
	},
		"application/mud+json": {
		source: "iana",
		compressible: true
	},
		"application/multipart-core": {
		source: "iana"
	},
		"application/mxf": {
		source: "iana",
		extensions: [
			"mxf"
		]
	},
		"application/n-quads": {
		source: "iana",
		extensions: [
			"nq"
		]
	},
		"application/n-triples": {
		source: "iana",
		extensions: [
			"nt"
		]
	},
		"application/nasdata": {
		source: "iana"
	},
		"application/news-checkgroups": {
		source: "iana",
		charset: "US-ASCII"
	},
		"application/news-groupinfo": {
		source: "iana",
		charset: "US-ASCII"
	},
		"application/news-transmission": {
		source: "iana"
	},
		"application/nlsml+xml": {
		source: "iana",
		compressible: true
	},
		"application/node": {
		source: "iana",
		extensions: [
			"cjs"
		]
	},
		"application/nss": {
		source: "iana"
	},
		"application/oauth-authz-req+jwt": {
		source: "iana"
	},
		"application/oblivious-dns-message": {
		source: "iana"
	},
		"application/ocsp-request": {
		source: "iana"
	},
		"application/ocsp-response": {
		source: "iana"
	},
		"application/octet-stream": {
		source: "iana",
		compressible: false,
		extensions: [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"exe",
			"dll",
			"deb",
			"dmg",
			"iso",
			"img",
			"msi",
			"msp",
			"msm",
			"buffer"
		]
	},
		"application/oda": {
		source: "iana",
		extensions: [
			"oda"
		]
	},
		"application/odm+xml": {
		source: "iana",
		compressible: true
	},
		"application/odx": {
		source: "iana"
	},
		"application/oebps-package+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"opf"
		]
	},
		"application/ogg": {
		source: "iana",
		compressible: false,
		extensions: [
			"ogx"
		]
	},
		"application/omdoc+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"omdoc"
		]
	},
		"application/onenote": {
		source: "apache",
		extensions: [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		]
	},
		"application/opc-nodeset+xml": {
		source: "iana",
		compressible: true
	},
		"application/oscore": {
		source: "iana"
	},
		"application/oxps": {
		source: "iana",
		extensions: [
			"oxps"
		]
	},
		"application/p21": {
		source: "iana"
	},
		"application/p21+zip": {
		source: "iana",
		compressible: false
	},
		"application/p2p-overlay+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"relo"
		]
	},
		"application/parityfec": {
		source: "iana"
	},
		"application/passport": {
		source: "iana"
	},
		"application/patch-ops-error+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xer"
		]
	},
		"application/pdf": {
		source: "iana",
		compressible: false,
		extensions: [
			"pdf"
		]
	},
		"application/pdx": {
		source: "iana"
	},
		"application/pem-certificate-chain": {
		source: "iana"
	},
		"application/pgp-encrypted": {
		source: "iana",
		compressible: false,
		extensions: [
			"pgp"
		]
	},
		"application/pgp-keys": {
		source: "iana",
		extensions: [
			"asc"
		]
	},
		"application/pgp-signature": {
		source: "iana",
		extensions: [
			"asc",
			"sig"
		]
	},
		"application/pics-rules": {
		source: "apache",
		extensions: [
			"prf"
		]
	},
		"application/pidf+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/pidf-diff+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/pkcs10": {
		source: "iana",
		extensions: [
			"p10"
		]
	},
		"application/pkcs12": {
		source: "iana"
	},
		"application/pkcs7-mime": {
		source: "iana",
		extensions: [
			"p7m",
			"p7c"
		]
	},
		"application/pkcs7-signature": {
		source: "iana",
		extensions: [
			"p7s"
		]
	},
		"application/pkcs8": {
		source: "iana",
		extensions: [
			"p8"
		]
	},
		"application/pkcs8-encrypted": {
		source: "iana"
	},
		"application/pkix-attr-cert": {
		source: "iana",
		extensions: [
			"ac"
		]
	},
		"application/pkix-cert": {
		source: "iana",
		extensions: [
			"cer"
		]
	},
		"application/pkix-crl": {
		source: "iana",
		extensions: [
			"crl"
		]
	},
		"application/pkix-pkipath": {
		source: "iana",
		extensions: [
			"pkipath"
		]
	},
		"application/pkixcmp": {
		source: "iana",
		extensions: [
			"pki"
		]
	},
		"application/pls+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"pls"
		]
	},
		"application/poc-settings+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/postscript": {
		source: "iana",
		compressible: true,
		extensions: [
			"ai",
			"eps",
			"ps"
		]
	},
		"application/ppsp-tracker+json": {
		source: "iana",
		compressible: true
	},
		"application/problem+json": {
		source: "iana",
		compressible: true
	},
		"application/problem+xml": {
		source: "iana",
		compressible: true
	},
		"application/provenance+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"provx"
		]
	},
		"application/prs.alvestrand.titrax-sheet": {
		source: "iana"
	},
		"application/prs.cww": {
		source: "iana",
		extensions: [
			"cww"
		]
	},
		"application/prs.cyn": {
		source: "iana",
		charset: "7-BIT"
	},
		"application/prs.hpub+zip": {
		source: "iana",
		compressible: false
	},
		"application/prs.nprend": {
		source: "iana"
	},
		"application/prs.plucker": {
		source: "iana"
	},
		"application/prs.rdf-xml-crypt": {
		source: "iana"
	},
		"application/prs.xsf+xml": {
		source: "iana",
		compressible: true
	},
		"application/pskc+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"pskcxml"
		]
	},
		"application/pvd+json": {
		source: "iana",
		compressible: true
	},
		"application/qsig": {
		source: "iana"
	},
		"application/raml+yaml": {
		compressible: true,
		extensions: [
			"raml"
		]
	},
		"application/raptorfec": {
		source: "iana"
	},
		"application/rdap+json": {
		source: "iana",
		compressible: true
	},
		"application/rdf+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rdf",
			"owl"
		]
	},
		"application/reginfo+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rif"
		]
	},
		"application/relax-ng-compact-syntax": {
		source: "iana",
		extensions: [
			"rnc"
		]
	},
		"application/remote-printing": {
		source: "iana"
	},
		"application/reputon+json": {
		source: "iana",
		compressible: true
	},
		"application/resource-lists+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rl"
		]
	},
		"application/resource-lists-diff+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rld"
		]
	},
		"application/rfc+xml": {
		source: "iana",
		compressible: true
	},
		"application/riscos": {
		source: "iana"
	},
		"application/rlmi+xml": {
		source: "iana",
		compressible: true
	},
		"application/rls-services+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rs"
		]
	},
		"application/route-apd+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rapd"
		]
	},
		"application/route-s-tsid+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"sls"
		]
	},
		"application/route-usd+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rusd"
		]
	},
		"application/rpki-ghostbusters": {
		source: "iana",
		extensions: [
			"gbr"
		]
	},
		"application/rpki-manifest": {
		source: "iana",
		extensions: [
			"mft"
		]
	},
		"application/rpki-publication": {
		source: "iana"
	},
		"application/rpki-roa": {
		source: "iana",
		extensions: [
			"roa"
		]
	},
		"application/rpki-updown": {
		source: "iana"
	},
		"application/rsd+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"rsd"
		]
	},
		"application/rss+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"rss"
		]
	},
		"application/rtf": {
		source: "iana",
		compressible: true,
		extensions: [
			"rtf"
		]
	},
		"application/rtploopback": {
		source: "iana"
	},
		"application/rtx": {
		source: "iana"
	},
		"application/samlassertion+xml": {
		source: "iana",
		compressible: true
	},
		"application/samlmetadata+xml": {
		source: "iana",
		compressible: true
	},
		"application/sarif+json": {
		source: "iana",
		compressible: true
	},
		"application/sarif-external-properties+json": {
		source: "iana",
		compressible: true
	},
		"application/sbe": {
		source: "iana"
	},
		"application/sbml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"sbml"
		]
	},
		"application/scaip+xml": {
		source: "iana",
		compressible: true
	},
		"application/scim+json": {
		source: "iana",
		compressible: true
	},
		"application/scvp-cv-request": {
		source: "iana",
		extensions: [
			"scq"
		]
	},
		"application/scvp-cv-response": {
		source: "iana",
		extensions: [
			"scs"
		]
	},
		"application/scvp-vp-request": {
		source: "iana",
		extensions: [
			"spq"
		]
	},
		"application/scvp-vp-response": {
		source: "iana",
		extensions: [
			"spp"
		]
	},
		"application/sdp": {
		source: "iana",
		extensions: [
			"sdp"
		]
	},
		"application/secevent+jwt": {
		source: "iana"
	},
		"application/senml+cbor": {
		source: "iana"
	},
		"application/senml+json": {
		source: "iana",
		compressible: true
	},
		"application/senml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"senmlx"
		]
	},
		"application/senml-etch+cbor": {
		source: "iana"
	},
		"application/senml-etch+json": {
		source: "iana",
		compressible: true
	},
		"application/senml-exi": {
		source: "iana"
	},
		"application/sensml+cbor": {
		source: "iana"
	},
		"application/sensml+json": {
		source: "iana",
		compressible: true
	},
		"application/sensml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"sensmlx"
		]
	},
		"application/sensml-exi": {
		source: "iana"
	},
		"application/sep+xml": {
		source: "iana",
		compressible: true
	},
		"application/sep-exi": {
		source: "iana"
	},
		"application/session-info": {
		source: "iana"
	},
		"application/set-payment": {
		source: "iana"
	},
		"application/set-payment-initiation": {
		source: "iana",
		extensions: [
			"setpay"
		]
	},
		"application/set-registration": {
		source: "iana"
	},
		"application/set-registration-initiation": {
		source: "iana",
		extensions: [
			"setreg"
		]
	},
		"application/sgml": {
		source: "iana"
	},
		"application/sgml-open-catalog": {
		source: "iana"
	},
		"application/shf+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"shf"
		]
	},
		"application/sieve": {
		source: "iana",
		extensions: [
			"siv",
			"sieve"
		]
	},
		"application/simple-filter+xml": {
		source: "iana",
		compressible: true
	},
		"application/simple-message-summary": {
		source: "iana"
	},
		"application/simplesymbolcontainer": {
		source: "iana"
	},
		"application/sipc": {
		source: "iana"
	},
		"application/slate": {
		source: "iana"
	},
		"application/smil": {
		source: "iana"
	},
		"application/smil+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"smi",
			"smil"
		]
	},
		"application/smpte336m": {
		source: "iana"
	},
		"application/soap+fastinfoset": {
		source: "iana"
	},
		"application/soap+xml": {
		source: "iana",
		compressible: true
	},
		"application/sparql-query": {
		source: "iana",
		extensions: [
			"rq"
		]
	},
		"application/sparql-results+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"srx"
		]
	},
		"application/spdx+json": {
		source: "iana",
		compressible: true
	},
		"application/spirits-event+xml": {
		source: "iana",
		compressible: true
	},
		"application/sql": {
		source: "iana"
	},
		"application/srgs": {
		source: "iana",
		extensions: [
			"gram"
		]
	},
		"application/srgs+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"grxml"
		]
	},
		"application/sru+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"sru"
		]
	},
		"application/ssdl+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"ssdl"
		]
	},
		"application/ssml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"ssml"
		]
	},
		"application/stix+json": {
		source: "iana",
		compressible: true
	},
		"application/swid+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"swidtag"
		]
	},
		"application/tamp-apex-update": {
		source: "iana"
	},
		"application/tamp-apex-update-confirm": {
		source: "iana"
	},
		"application/tamp-community-update": {
		source: "iana"
	},
		"application/tamp-community-update-confirm": {
		source: "iana"
	},
		"application/tamp-error": {
		source: "iana"
	},
		"application/tamp-sequence-adjust": {
		source: "iana"
	},
		"application/tamp-sequence-adjust-confirm": {
		source: "iana"
	},
		"application/tamp-status-query": {
		source: "iana"
	},
		"application/tamp-status-response": {
		source: "iana"
	},
		"application/tamp-update": {
		source: "iana"
	},
		"application/tamp-update-confirm": {
		source: "iana"
	},
		"application/tar": {
		compressible: true
	},
		"application/taxii+json": {
		source: "iana",
		compressible: true
	},
		"application/td+json": {
		source: "iana",
		compressible: true
	},
		"application/tei+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"tei",
			"teicorpus"
		]
	},
		"application/tetra_isi": {
		source: "iana"
	},
		"application/thraud+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"tfi"
		]
	},
		"application/timestamp-query": {
		source: "iana"
	},
		"application/timestamp-reply": {
		source: "iana"
	},
		"application/timestamped-data": {
		source: "iana",
		extensions: [
			"tsd"
		]
	},
		"application/tlsrpt+gzip": {
		source: "iana"
	},
		"application/tlsrpt+json": {
		source: "iana",
		compressible: true
	},
		"application/tnauthlist": {
		source: "iana"
	},
		"application/token-introspection+jwt": {
		source: "iana"
	},
		"application/toml": {
		compressible: true,
		extensions: [
			"toml"
		]
	},
		"application/trickle-ice-sdpfrag": {
		source: "iana"
	},
		"application/trig": {
		source: "iana",
		extensions: [
			"trig"
		]
	},
		"application/ttml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"ttml"
		]
	},
		"application/tve-trigger": {
		source: "iana"
	},
		"application/tzif": {
		source: "iana"
	},
		"application/tzif-leap": {
		source: "iana"
	},
		"application/ubjson": {
		compressible: false,
		extensions: [
			"ubj"
		]
	},
		"application/ulpfec": {
		source: "iana"
	},
		"application/urc-grpsheet+xml": {
		source: "iana",
		compressible: true
	},
		"application/urc-ressheet+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"rsheet"
		]
	},
		"application/urc-targetdesc+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"td"
		]
	},
		"application/urc-uisocketdesc+xml": {
		source: "iana",
		compressible: true
	},
		"application/vcard+json": {
		source: "iana",
		compressible: true
	},
		"application/vcard+xml": {
		source: "iana",
		compressible: true
	},
		"application/vemmi": {
		source: "iana"
	},
		"application/vividence.scriptfile": {
		source: "apache"
	},
		"application/vnd.1000minds.decision-model+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"1km"
		]
	},
		"application/vnd.3gpp-prose+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp-prose-pc3ch+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp-v2x-local-service-information": {
		source: "iana"
	},
		"application/vnd.3gpp.5gnas": {
		source: "iana"
	},
		"application/vnd.3gpp.access-transfer-events+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.bsf+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.gmop+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.gtpc": {
		source: "iana"
	},
		"application/vnd.3gpp.interworking-data": {
		source: "iana"
	},
		"application/vnd.3gpp.lpp": {
		source: "iana"
	},
		"application/vnd.3gpp.mc-signalling-ear": {
		source: "iana"
	},
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcdata-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcdata-payload": {
		source: "iana"
	},
		"application/vnd.3gpp.mcdata-service-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcdata-signalling": {
		source: "iana"
	},
		"application/vnd.3gpp.mcdata-ue-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-location-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-service-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-signed+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.mid-call+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.ngap": {
		source: "iana"
	},
		"application/vnd.3gpp.pfcp": {
		source: "iana"
	},
		"application/vnd.3gpp.pic-bw-large": {
		source: "iana",
		extensions: [
			"plb"
		]
	},
		"application/vnd.3gpp.pic-bw-small": {
		source: "iana",
		extensions: [
			"psb"
		]
	},
		"application/vnd.3gpp.pic-bw-var": {
		source: "iana",
		extensions: [
			"pvb"
		]
	},
		"application/vnd.3gpp.s1ap": {
		source: "iana"
	},
		"application/vnd.3gpp.sms": {
		source: "iana"
	},
		"application/vnd.3gpp.sms+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.srvcc-ext+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.srvcc-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.state-and-event-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp.ussd+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.3gpp2.sms": {
		source: "iana"
	},
		"application/vnd.3gpp2.tcap": {
		source: "iana",
		extensions: [
			"tcap"
		]
	},
		"application/vnd.3lightssoftware.imagescal": {
		source: "iana"
	},
		"application/vnd.3m.post-it-notes": {
		source: "iana",
		extensions: [
			"pwn"
		]
	},
		"application/vnd.accpac.simply.aso": {
		source: "iana",
		extensions: [
			"aso"
		]
	},
		"application/vnd.accpac.simply.imp": {
		source: "iana",
		extensions: [
			"imp"
		]
	},
		"application/vnd.acucobol": {
		source: "iana",
		extensions: [
			"acu"
		]
	},
		"application/vnd.acucorp": {
		source: "iana",
		extensions: [
			"atc",
			"acutc"
		]
	},
		"application/vnd.adobe.air-application-installer-package+zip": {
		source: "apache",
		compressible: false,
		extensions: [
			"air"
		]
	},
		"application/vnd.adobe.flash.movie": {
		source: "iana"
	},
		"application/vnd.adobe.formscentral.fcdt": {
		source: "iana",
		extensions: [
			"fcdt"
		]
	},
		"application/vnd.adobe.fxp": {
		source: "iana",
		extensions: [
			"fxp",
			"fxpl"
		]
	},
		"application/vnd.adobe.partial-upload": {
		source: "iana"
	},
		"application/vnd.adobe.xdp+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xdp"
		]
	},
		"application/vnd.adobe.xfdf": {
		source: "iana",
		extensions: [
			"xfdf"
		]
	},
		"application/vnd.aether.imp": {
		source: "iana"
	},
		"application/vnd.afpc.afplinedata": {
		source: "iana"
	},
		"application/vnd.afpc.afplinedata-pagedef": {
		source: "iana"
	},
		"application/vnd.afpc.cmoca-cmresource": {
		source: "iana"
	},
		"application/vnd.afpc.foca-charset": {
		source: "iana"
	},
		"application/vnd.afpc.foca-codedfont": {
		source: "iana"
	},
		"application/vnd.afpc.foca-codepage": {
		source: "iana"
	},
		"application/vnd.afpc.modca": {
		source: "iana"
	},
		"application/vnd.afpc.modca-cmtable": {
		source: "iana"
	},
		"application/vnd.afpc.modca-formdef": {
		source: "iana"
	},
		"application/vnd.afpc.modca-mediummap": {
		source: "iana"
	},
		"application/vnd.afpc.modca-objectcontainer": {
		source: "iana"
	},
		"application/vnd.afpc.modca-overlay": {
		source: "iana"
	},
		"application/vnd.afpc.modca-pagesegment": {
		source: "iana"
	},
		"application/vnd.age": {
		source: "iana",
		extensions: [
			"age"
		]
	},
		"application/vnd.ah-barcode": {
		source: "iana"
	},
		"application/vnd.ahead.space": {
		source: "iana",
		extensions: [
			"ahead"
		]
	},
		"application/vnd.airzip.filesecure.azf": {
		source: "iana",
		extensions: [
			"azf"
		]
	},
		"application/vnd.airzip.filesecure.azs": {
		source: "iana",
		extensions: [
			"azs"
		]
	},
		"application/vnd.amadeus+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.amazon.ebook": {
		source: "apache",
		extensions: [
			"azw"
		]
	},
		"application/vnd.amazon.mobi8-ebook": {
		source: "iana"
	},
		"application/vnd.americandynamics.acc": {
		source: "iana",
		extensions: [
			"acc"
		]
	},
		"application/vnd.amiga.ami": {
		source: "iana",
		extensions: [
			"ami"
		]
	},
		"application/vnd.amundsen.maze+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.android.ota": {
		source: "iana"
	},
		"application/vnd.android.package-archive": {
		source: "apache",
		compressible: false,
		extensions: [
			"apk"
		]
	},
		"application/vnd.anki": {
		source: "iana"
	},
		"application/vnd.anser-web-certificate-issue-initiation": {
		source: "iana",
		extensions: [
			"cii"
		]
	},
		"application/vnd.anser-web-funds-transfer-initiation": {
		source: "apache",
		extensions: [
			"fti"
		]
	},
		"application/vnd.antix.game-component": {
		source: "iana",
		extensions: [
			"atx"
		]
	},
		"application/vnd.apache.arrow.file": {
		source: "iana"
	},
		"application/vnd.apache.arrow.stream": {
		source: "iana"
	},
		"application/vnd.apache.thrift.binary": {
		source: "iana"
	},
		"application/vnd.apache.thrift.compact": {
		source: "iana"
	},
		"application/vnd.apache.thrift.json": {
		source: "iana"
	},
		"application/vnd.api+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.aplextor.warrp+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.apothekende.reservation+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.apple.installer+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mpkg"
		]
	},
		"application/vnd.apple.keynote": {
		source: "iana",
		extensions: [
			"key"
		]
	},
		"application/vnd.apple.mpegurl": {
		source: "iana",
		extensions: [
			"m3u8"
		]
	},
		"application/vnd.apple.numbers": {
		source: "iana",
		extensions: [
			"numbers"
		]
	},
		"application/vnd.apple.pages": {
		source: "iana",
		extensions: [
			"pages"
		]
	},
		"application/vnd.apple.pkpass": {
		compressible: false,
		extensions: [
			"pkpass"
		]
	},
		"application/vnd.arastra.swi": {
		source: "iana"
	},
		"application/vnd.aristanetworks.swi": {
		source: "iana",
		extensions: [
			"swi"
		]
	},
		"application/vnd.artisan+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.artsquare": {
		source: "iana"
	},
		"application/vnd.astraea-software.iota": {
		source: "iana",
		extensions: [
			"iota"
		]
	},
		"application/vnd.audiograph": {
		source: "iana",
		extensions: [
			"aep"
		]
	},
		"application/vnd.autopackage": {
		source: "iana"
	},
		"application/vnd.avalon+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.avistar+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.balsamiq.bmml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"bmml"
		]
	},
		"application/vnd.balsamiq.bmpr": {
		source: "iana"
	},
		"application/vnd.banana-accounting": {
		source: "iana"
	},
		"application/vnd.bbf.usp.error": {
		source: "iana"
	},
		"application/vnd.bbf.usp.msg": {
		source: "iana"
	},
		"application/vnd.bbf.usp.msg+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.bekitzur-stech+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.bint.med-content": {
		source: "iana"
	},
		"application/vnd.biopax.rdf+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.blink-idb-value-wrapper": {
		source: "iana"
	},
		"application/vnd.blueice.multipass": {
		source: "iana",
		extensions: [
			"mpm"
		]
	},
		"application/vnd.bluetooth.ep.oob": {
		source: "iana"
	},
		"application/vnd.bluetooth.le.oob": {
		source: "iana"
	},
		"application/vnd.bmi": {
		source: "iana",
		extensions: [
			"bmi"
		]
	},
		"application/vnd.bpf": {
		source: "iana"
	},
		"application/vnd.bpf3": {
		source: "iana"
	},
		"application/vnd.businessobjects": {
		source: "iana",
		extensions: [
			"rep"
		]
	},
		"application/vnd.byu.uapi+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cab-jscript": {
		source: "iana"
	},
		"application/vnd.canon-cpdl": {
		source: "iana"
	},
		"application/vnd.canon-lips": {
		source: "iana"
	},
		"application/vnd.capasystems-pg+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cendio.thinlinc.clientconf": {
		source: "iana"
	},
		"application/vnd.century-systems.tcp_stream": {
		source: "iana"
	},
		"application/vnd.chemdraw+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"cdxml"
		]
	},
		"application/vnd.chess-pgn": {
		source: "iana"
	},
		"application/vnd.chipnuts.karaoke-mmd": {
		source: "iana",
		extensions: [
			"mmd"
		]
	},
		"application/vnd.ciedi": {
		source: "iana"
	},
		"application/vnd.cinderella": {
		source: "iana",
		extensions: [
			"cdy"
		]
	},
		"application/vnd.cirpack.isdn-ext": {
		source: "iana"
	},
		"application/vnd.citationstyles.style+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"csl"
		]
	},
		"application/vnd.claymore": {
		source: "iana",
		extensions: [
			"cla"
		]
	},
		"application/vnd.cloanto.rp9": {
		source: "iana",
		extensions: [
			"rp9"
		]
	},
		"application/vnd.clonk.c4group": {
		source: "iana",
		extensions: [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		]
	},
		"application/vnd.cluetrust.cartomobile-config": {
		source: "iana",
		extensions: [
			"c11amc"
		]
	},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
		source: "iana",
		extensions: [
			"c11amz"
		]
	},
		"application/vnd.coffeescript": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.document": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.document-template": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.presentation": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.presentation-template": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.spreadsheet": {
		source: "iana"
	},
		"application/vnd.collabio.xodocuments.spreadsheet-template": {
		source: "iana"
	},
		"application/vnd.collection+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.collection.doc+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.collection.next+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.comicbook+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.comicbook-rar": {
		source: "iana"
	},
		"application/vnd.commerce-battelle": {
		source: "iana"
	},
		"application/vnd.commonspace": {
		source: "iana",
		extensions: [
			"csp"
		]
	},
		"application/vnd.contact.cmsg": {
		source: "iana",
		extensions: [
			"cdbcmsg"
		]
	},
		"application/vnd.coreos.ignition+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cosmocaller": {
		source: "iana",
		extensions: [
			"cmc"
		]
	},
		"application/vnd.crick.clicker": {
		source: "iana",
		extensions: [
			"clkx"
		]
	},
		"application/vnd.crick.clicker.keyboard": {
		source: "iana",
		extensions: [
			"clkk"
		]
	},
		"application/vnd.crick.clicker.palette": {
		source: "iana",
		extensions: [
			"clkp"
		]
	},
		"application/vnd.crick.clicker.template": {
		source: "iana",
		extensions: [
			"clkt"
		]
	},
		"application/vnd.crick.clicker.wordbank": {
		source: "iana",
		extensions: [
			"clkw"
		]
	},
		"application/vnd.criticaltools.wbs+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"wbs"
		]
	},
		"application/vnd.cryptii.pipe+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.crypto-shade-file": {
		source: "iana"
	},
		"application/vnd.cryptomator.encrypted": {
		source: "iana"
	},
		"application/vnd.cryptomator.vault": {
		source: "iana"
	},
		"application/vnd.ctc-posml": {
		source: "iana",
		extensions: [
			"pml"
		]
	},
		"application/vnd.ctct.ws+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cups-pdf": {
		source: "iana"
	},
		"application/vnd.cups-postscript": {
		source: "iana"
	},
		"application/vnd.cups-ppd": {
		source: "iana",
		extensions: [
			"ppd"
		]
	},
		"application/vnd.cups-raster": {
		source: "iana"
	},
		"application/vnd.cups-raw": {
		source: "iana"
	},
		"application/vnd.curl": {
		source: "iana"
	},
		"application/vnd.curl.car": {
		source: "apache",
		extensions: [
			"car"
		]
	},
		"application/vnd.curl.pcurl": {
		source: "apache",
		extensions: [
			"pcurl"
		]
	},
		"application/vnd.cyan.dean.root+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cybank": {
		source: "iana"
	},
		"application/vnd.cyclonedx+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.cyclonedx+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.d2l.coursepackage1p0+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.d3m-dataset": {
		source: "iana"
	},
		"application/vnd.d3m-problem": {
		source: "iana"
	},
		"application/vnd.dart": {
		source: "iana",
		compressible: true,
		extensions: [
			"dart"
		]
	},
		"application/vnd.data-vision.rdz": {
		source: "iana",
		extensions: [
			"rdz"
		]
	},
		"application/vnd.datapackage+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dataresource+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dbf": {
		source: "iana",
		extensions: [
			"dbf"
		]
	},
		"application/vnd.debian.binary-package": {
		source: "iana"
	},
		"application/vnd.dece.data": {
		source: "iana",
		extensions: [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		]
	},
		"application/vnd.dece.ttml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"uvt",
			"uvvt"
		]
	},
		"application/vnd.dece.unspecified": {
		source: "iana",
		extensions: [
			"uvx",
			"uvvx"
		]
	},
		"application/vnd.dece.zip": {
		source: "iana",
		extensions: [
			"uvz",
			"uvvz"
		]
	},
		"application/vnd.denovo.fcselayout-link": {
		source: "iana",
		extensions: [
			"fe_launch"
		]
	},
		"application/vnd.desmume.movie": {
		source: "iana"
	},
		"application/vnd.dir-bi.plate-dl-nosuffix": {
		source: "iana"
	},
		"application/vnd.dm.delegation+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dna": {
		source: "iana",
		extensions: [
			"dna"
		]
	},
		"application/vnd.document+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dolby.mlp": {
		source: "apache",
		extensions: [
			"mlp"
		]
	},
		"application/vnd.dolby.mobile.1": {
		source: "iana"
	},
		"application/vnd.dolby.mobile.2": {
		source: "iana"
	},
		"application/vnd.doremir.scorecloud-binary-document": {
		source: "iana"
	},
		"application/vnd.dpgraph": {
		source: "iana",
		extensions: [
			"dpg"
		]
	},
		"application/vnd.dreamfactory": {
		source: "iana",
		extensions: [
			"dfac"
		]
	},
		"application/vnd.drive+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ds-keypoint": {
		source: "apache",
		extensions: [
			"kpxx"
		]
	},
		"application/vnd.dtg.local": {
		source: "iana"
	},
		"application/vnd.dtg.local.flash": {
		source: "iana"
	},
		"application/vnd.dtg.local.html": {
		source: "iana"
	},
		"application/vnd.dvb.ait": {
		source: "iana",
		extensions: [
			"ait"
		]
	},
		"application/vnd.dvb.dvbisl+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.dvbj": {
		source: "iana"
	},
		"application/vnd.dvb.esgcontainer": {
		source: "iana"
	},
		"application/vnd.dvb.ipdcdftnotifaccess": {
		source: "iana"
	},
		"application/vnd.dvb.ipdcesgaccess": {
		source: "iana"
	},
		"application/vnd.dvb.ipdcesgaccess2": {
		source: "iana"
	},
		"application/vnd.dvb.ipdcesgpdd": {
		source: "iana"
	},
		"application/vnd.dvb.ipdcroaming": {
		source: "iana"
	},
		"application/vnd.dvb.iptv.alfec-base": {
		source: "iana"
	},
		"application/vnd.dvb.iptv.alfec-enhancement": {
		source: "iana"
	},
		"application/vnd.dvb.notif-aggregate-root+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-container+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-generic+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-ia-msglist+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.notif-init+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.dvb.pfr": {
		source: "iana"
	},
		"application/vnd.dvb.service": {
		source: "iana",
		extensions: [
			"svc"
		]
	},
		"application/vnd.dxr": {
		source: "iana"
	},
		"application/vnd.dynageo": {
		source: "iana",
		extensions: [
			"geo"
		]
	},
		"application/vnd.dzr": {
		source: "iana"
	},
		"application/vnd.easykaraoke.cdgdownload": {
		source: "iana"
	},
		"application/vnd.ecdis-update": {
		source: "iana"
	},
		"application/vnd.ecip.rlp": {
		source: "iana"
	},
		"application/vnd.eclipse.ditto+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ecowin.chart": {
		source: "iana",
		extensions: [
			"mag"
		]
	},
		"application/vnd.ecowin.filerequest": {
		source: "iana"
	},
		"application/vnd.ecowin.fileupdate": {
		source: "iana"
	},
		"application/vnd.ecowin.series": {
		source: "iana"
	},
		"application/vnd.ecowin.seriesrequest": {
		source: "iana"
	},
		"application/vnd.ecowin.seriesupdate": {
		source: "iana"
	},
		"application/vnd.efi.img": {
		source: "iana"
	},
		"application/vnd.efi.iso": {
		source: "iana"
	},
		"application/vnd.emclient.accessrequest+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.enliven": {
		source: "iana",
		extensions: [
			"nml"
		]
	},
		"application/vnd.enphase.envoy": {
		source: "iana"
	},
		"application/vnd.eprints.data+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.epson.esf": {
		source: "iana",
		extensions: [
			"esf"
		]
	},
		"application/vnd.epson.msf": {
		source: "iana",
		extensions: [
			"msf"
		]
	},
		"application/vnd.epson.quickanime": {
		source: "iana",
		extensions: [
			"qam"
		]
	},
		"application/vnd.epson.salt": {
		source: "iana",
		extensions: [
			"slt"
		]
	},
		"application/vnd.epson.ssf": {
		source: "iana",
		extensions: [
			"ssf"
		]
	},
		"application/vnd.ericsson.quickcall": {
		source: "iana"
	},
		"application/vnd.espass-espass+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.eszigno3+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"es3",
			"et3"
		]
	},
		"application/vnd.etsi.aoc+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.asic-e+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.etsi.asic-s+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.etsi.cug+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvcommand+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvdiscovery+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvprofile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvsad-bc+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvsad-cod+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvsad-npvr+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvservice+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvsync+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.iptvueprofile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.mcid+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.mheg5": {
		source: "iana"
	},
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.pstn+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.sci+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.simservs+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.timestamp-token": {
		source: "iana"
	},
		"application/vnd.etsi.tsl+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.etsi.tsl.der": {
		source: "iana"
	},
		"application/vnd.eu.kasparian.car+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.eudora.data": {
		source: "iana"
	},
		"application/vnd.evolv.ecig.profile": {
		source: "iana"
	},
		"application/vnd.evolv.ecig.settings": {
		source: "iana"
	},
		"application/vnd.evolv.ecig.theme": {
		source: "iana"
	},
		"application/vnd.exstream-empower+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.exstream-package": {
		source: "iana"
	},
		"application/vnd.ezpix-album": {
		source: "iana",
		extensions: [
			"ez2"
		]
	},
		"application/vnd.ezpix-package": {
		source: "iana",
		extensions: [
			"ez3"
		]
	},
		"application/vnd.f-secure.mobile": {
		source: "iana"
	},
		"application/vnd.familysearch.gedcom+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.fastcopy-disk-image": {
		source: "iana"
	},
		"application/vnd.fdf": {
		source: "iana",
		extensions: [
			"fdf"
		]
	},
		"application/vnd.fdsn.mseed": {
		source: "iana",
		extensions: [
			"mseed"
		]
	},
		"application/vnd.fdsn.seed": {
		source: "iana",
		extensions: [
			"seed",
			"dataless"
		]
	},
		"application/vnd.ffsns": {
		source: "iana"
	},
		"application/vnd.ficlab.flb+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.filmit.zfc": {
		source: "iana"
	},
		"application/vnd.fints": {
		source: "iana"
	},
		"application/vnd.firemonkeys.cloudcell": {
		source: "iana"
	},
		"application/vnd.flographit": {
		source: "iana",
		extensions: [
			"gph"
		]
	},
		"application/vnd.fluxtime.clip": {
		source: "iana",
		extensions: [
			"ftc"
		]
	},
		"application/vnd.font-fontforge-sfd": {
		source: "iana"
	},
		"application/vnd.framemaker": {
		source: "iana",
		extensions: [
			"fm",
			"frame",
			"maker",
			"book"
		]
	},
		"application/vnd.frogans.fnc": {
		source: "iana",
		extensions: [
			"fnc"
		]
	},
		"application/vnd.frogans.ltf": {
		source: "iana",
		extensions: [
			"ltf"
		]
	},
		"application/vnd.fsc.weblaunch": {
		source: "iana",
		extensions: [
			"fsc"
		]
	},
		"application/vnd.fujifilm.fb.docuworks": {
		source: "iana"
	},
		"application/vnd.fujifilm.fb.docuworks.binder": {
		source: "iana"
	},
		"application/vnd.fujifilm.fb.docuworks.container": {
		source: "iana"
	},
		"application/vnd.fujifilm.fb.jfi+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.fujitsu.oasys": {
		source: "iana",
		extensions: [
			"oas"
		]
	},
		"application/vnd.fujitsu.oasys2": {
		source: "iana",
		extensions: [
			"oa2"
		]
	},
		"application/vnd.fujitsu.oasys3": {
		source: "iana",
		extensions: [
			"oa3"
		]
	},
		"application/vnd.fujitsu.oasysgp": {
		source: "iana",
		extensions: [
			"fg5"
		]
	},
		"application/vnd.fujitsu.oasysprs": {
		source: "iana",
		extensions: [
			"bh2"
		]
	},
		"application/vnd.fujixerox.art-ex": {
		source: "iana"
	},
		"application/vnd.fujixerox.art4": {
		source: "iana"
	},
		"application/vnd.fujixerox.ddd": {
		source: "iana",
		extensions: [
			"ddd"
		]
	},
		"application/vnd.fujixerox.docuworks": {
		source: "iana",
		extensions: [
			"xdw"
		]
	},
		"application/vnd.fujixerox.docuworks.binder": {
		source: "iana",
		extensions: [
			"xbd"
		]
	},
		"application/vnd.fujixerox.docuworks.container": {
		source: "iana"
	},
		"application/vnd.fujixerox.hbpl": {
		source: "iana"
	},
		"application/vnd.fut-misnet": {
		source: "iana"
	},
		"application/vnd.futoin+cbor": {
		source: "iana"
	},
		"application/vnd.futoin+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.fuzzysheet": {
		source: "iana",
		extensions: [
			"fzs"
		]
	},
		"application/vnd.genomatix.tuxedo": {
		source: "iana",
		extensions: [
			"txd"
		]
	},
		"application/vnd.gentics.grd+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.geo+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.geocube+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.geogebra.file": {
		source: "iana",
		extensions: [
			"ggb"
		]
	},
		"application/vnd.geogebra.slides": {
		source: "iana"
	},
		"application/vnd.geogebra.tool": {
		source: "iana",
		extensions: [
			"ggt"
		]
	},
		"application/vnd.geometry-explorer": {
		source: "iana",
		extensions: [
			"gex",
			"gre"
		]
	},
		"application/vnd.geonext": {
		source: "iana",
		extensions: [
			"gxt"
		]
	},
		"application/vnd.geoplan": {
		source: "iana",
		extensions: [
			"g2w"
		]
	},
		"application/vnd.geospace": {
		source: "iana",
		extensions: [
			"g3w"
		]
	},
		"application/vnd.gerber": {
		source: "iana"
	},
		"application/vnd.globalplatform.card-content-mgt": {
		source: "iana"
	},
		"application/vnd.globalplatform.card-content-mgt-response": {
		source: "iana"
	},
		"application/vnd.gmx": {
		source: "iana",
		extensions: [
			"gmx"
		]
	},
		"application/vnd.google-apps.document": {
		compressible: false,
		extensions: [
			"gdoc"
		]
	},
		"application/vnd.google-apps.presentation": {
		compressible: false,
		extensions: [
			"gslides"
		]
	},
		"application/vnd.google-apps.spreadsheet": {
		compressible: false,
		extensions: [
			"gsheet"
		]
	},
		"application/vnd.google-earth.kml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"kml"
		]
	},
		"application/vnd.google-earth.kmz": {
		source: "iana",
		compressible: false,
		extensions: [
			"kmz"
		]
	},
		"application/vnd.gov.sk.e-form+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.gov.sk.e-form+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.grafeq": {
		source: "iana",
		extensions: [
			"gqf",
			"gqs"
		]
	},
		"application/vnd.gridmp": {
		source: "iana"
	},
		"application/vnd.groove-account": {
		source: "iana",
		extensions: [
			"gac"
		]
	},
		"application/vnd.groove-help": {
		source: "iana",
		extensions: [
			"ghf"
		]
	},
		"application/vnd.groove-identity-message": {
		source: "iana",
		extensions: [
			"gim"
		]
	},
		"application/vnd.groove-injector": {
		source: "iana",
		extensions: [
			"grv"
		]
	},
		"application/vnd.groove-tool-message": {
		source: "iana",
		extensions: [
			"gtm"
		]
	},
		"application/vnd.groove-tool-template": {
		source: "iana",
		extensions: [
			"tpl"
		]
	},
		"application/vnd.groove-vcard": {
		source: "iana",
		extensions: [
			"vcg"
		]
	},
		"application/vnd.hal+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hal+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"hal"
		]
	},
		"application/vnd.handheld-entertainment+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"zmm"
		]
	},
		"application/vnd.hbci": {
		source: "iana",
		extensions: [
			"hbci"
		]
	},
		"application/vnd.hc+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hcl-bireports": {
		source: "iana"
	},
		"application/vnd.hdt": {
		source: "iana"
	},
		"application/vnd.heroku+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hhe.lesson-player": {
		source: "iana",
		extensions: [
			"les"
		]
	},
		"application/vnd.hl7cda+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.hl7v2+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.hp-hpgl": {
		source: "iana",
		extensions: [
			"hpgl"
		]
	},
		"application/vnd.hp-hpid": {
		source: "iana",
		extensions: [
			"hpid"
		]
	},
		"application/vnd.hp-hps": {
		source: "iana",
		extensions: [
			"hps"
		]
	},
		"application/vnd.hp-jlyt": {
		source: "iana",
		extensions: [
			"jlt"
		]
	},
		"application/vnd.hp-pcl": {
		source: "iana",
		extensions: [
			"pcl"
		]
	},
		"application/vnd.hp-pclxl": {
		source: "iana",
		extensions: [
			"pclxl"
		]
	},
		"application/vnd.httphone": {
		source: "iana"
	},
		"application/vnd.hydrostatix.sof-data": {
		source: "iana",
		extensions: [
			"sfd-hdstx"
		]
	},
		"application/vnd.hyper+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hyper-item+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hyperdrive+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.hzn-3d-crossword": {
		source: "iana"
	},
		"application/vnd.ibm.afplinedata": {
		source: "iana"
	},
		"application/vnd.ibm.electronic-media": {
		source: "iana"
	},
		"application/vnd.ibm.minipay": {
		source: "iana",
		extensions: [
			"mpy"
		]
	},
		"application/vnd.ibm.modcap": {
		source: "iana",
		extensions: [
			"afp",
			"listafp",
			"list3820"
		]
	},
		"application/vnd.ibm.rights-management": {
		source: "iana",
		extensions: [
			"irm"
		]
	},
		"application/vnd.ibm.secure-container": {
		source: "iana",
		extensions: [
			"sc"
		]
	},
		"application/vnd.iccprofile": {
		source: "iana",
		extensions: [
			"icc",
			"icm"
		]
	},
		"application/vnd.ieee.1905": {
		source: "iana"
	},
		"application/vnd.igloader": {
		source: "iana",
		extensions: [
			"igl"
		]
	},
		"application/vnd.imagemeter.folder+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.imagemeter.image+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.immervision-ivp": {
		source: "iana",
		extensions: [
			"ivp"
		]
	},
		"application/vnd.immervision-ivu": {
		source: "iana",
		extensions: [
			"ivu"
		]
	},
		"application/vnd.ims.imsccv1p1": {
		source: "iana"
	},
		"application/vnd.ims.imsccv1p2": {
		source: "iana"
	},
		"application/vnd.ims.imsccv1p3": {
		source: "iana"
	},
		"application/vnd.ims.lis.v2.result+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ims.lti.v2.toolproxy+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ims.lti.v2.toolsettings+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.informedcontrol.rms+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.informix-visionary": {
		source: "iana"
	},
		"application/vnd.infotech.project": {
		source: "iana"
	},
		"application/vnd.infotech.project+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.innopath.wamp.notification": {
		source: "iana"
	},
		"application/vnd.insors.igm": {
		source: "iana",
		extensions: [
			"igm"
		]
	},
		"application/vnd.intercon.formnet": {
		source: "iana",
		extensions: [
			"xpw",
			"xpx"
		]
	},
		"application/vnd.intergeo": {
		source: "iana",
		extensions: [
			"i2g"
		]
	},
		"application/vnd.intertrust.digibox": {
		source: "iana"
	},
		"application/vnd.intertrust.nncp": {
		source: "iana"
	},
		"application/vnd.intu.qbo": {
		source: "iana",
		extensions: [
			"qbo"
		]
	},
		"application/vnd.intu.qfx": {
		source: "iana",
		extensions: [
			"qfx"
		]
	},
		"application/vnd.iptc.g2.catalogitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.conceptitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.newsitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.newsmessage+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.packageitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.iptc.g2.planningitem+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ipunplugged.rcprofile": {
		source: "iana",
		extensions: [
			"rcprofile"
		]
	},
		"application/vnd.irepository.package+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"irp"
		]
	},
		"application/vnd.is-xpr": {
		source: "iana",
		extensions: [
			"xpr"
		]
	},
		"application/vnd.isac.fcs": {
		source: "iana",
		extensions: [
			"fcs"
		]
	},
		"application/vnd.iso11783-10+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.jam": {
		source: "iana",
		extensions: [
			"jam"
		]
	},
		"application/vnd.japannet-directory-service": {
		source: "iana"
	},
		"application/vnd.japannet-jpnstore-wakeup": {
		source: "iana"
	},
		"application/vnd.japannet-payment-wakeup": {
		source: "iana"
	},
		"application/vnd.japannet-registration": {
		source: "iana"
	},
		"application/vnd.japannet-registration-wakeup": {
		source: "iana"
	},
		"application/vnd.japannet-setstore-wakeup": {
		source: "iana"
	},
		"application/vnd.japannet-verification": {
		source: "iana"
	},
		"application/vnd.japannet-verification-wakeup": {
		source: "iana"
	},
		"application/vnd.jcp.javame.midlet-rms": {
		source: "iana",
		extensions: [
			"rms"
		]
	},
		"application/vnd.jisp": {
		source: "iana",
		extensions: [
			"jisp"
		]
	},
		"application/vnd.joost.joda-archive": {
		source: "iana",
		extensions: [
			"joda"
		]
	},
		"application/vnd.jsk.isdn-ngn": {
		source: "iana"
	},
		"application/vnd.kahootz": {
		source: "iana",
		extensions: [
			"ktz",
			"ktr"
		]
	},
		"application/vnd.kde.karbon": {
		source: "iana",
		extensions: [
			"karbon"
		]
	},
		"application/vnd.kde.kchart": {
		source: "iana",
		extensions: [
			"chrt"
		]
	},
		"application/vnd.kde.kformula": {
		source: "iana",
		extensions: [
			"kfo"
		]
	},
		"application/vnd.kde.kivio": {
		source: "iana",
		extensions: [
			"flw"
		]
	},
		"application/vnd.kde.kontour": {
		source: "iana",
		extensions: [
			"kon"
		]
	},
		"application/vnd.kde.kpresenter": {
		source: "iana",
		extensions: [
			"kpr",
			"kpt"
		]
	},
		"application/vnd.kde.kspread": {
		source: "iana",
		extensions: [
			"ksp"
		]
	},
		"application/vnd.kde.kword": {
		source: "iana",
		extensions: [
			"kwd",
			"kwt"
		]
	},
		"application/vnd.kenameaapp": {
		source: "iana",
		extensions: [
			"htke"
		]
	},
		"application/vnd.kidspiration": {
		source: "iana",
		extensions: [
			"kia"
		]
	},
		"application/vnd.kinar": {
		source: "iana",
		extensions: [
			"kne",
			"knp"
		]
	},
		"application/vnd.koan": {
		source: "iana",
		extensions: [
			"skp",
			"skd",
			"skt",
			"skm"
		]
	},
		"application/vnd.kodak-descriptor": {
		source: "iana",
		extensions: [
			"sse"
		]
	},
		"application/vnd.las": {
		source: "iana"
	},
		"application/vnd.las.las+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.las.las+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"lasxml"
		]
	},
		"application/vnd.laszip": {
		source: "iana"
	},
		"application/vnd.leap+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.liberty-request+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.llamagraphics.life-balance.desktop": {
		source: "iana",
		extensions: [
			"lbd"
		]
	},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"lbe"
		]
	},
		"application/vnd.logipipe.circuit+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.loom": {
		source: "iana"
	},
		"application/vnd.lotus-1-2-3": {
		source: "iana",
		extensions: [
			"123"
		]
	},
		"application/vnd.lotus-approach": {
		source: "iana",
		extensions: [
			"apr"
		]
	},
		"application/vnd.lotus-freelance": {
		source: "iana",
		extensions: [
			"pre"
		]
	},
		"application/vnd.lotus-notes": {
		source: "iana",
		extensions: [
			"nsf"
		]
	},
		"application/vnd.lotus-organizer": {
		source: "iana",
		extensions: [
			"org"
		]
	},
		"application/vnd.lotus-screencam": {
		source: "iana",
		extensions: [
			"scm"
		]
	},
		"application/vnd.lotus-wordpro": {
		source: "iana",
		extensions: [
			"lwp"
		]
	},
		"application/vnd.macports.portpkg": {
		source: "iana",
		extensions: [
			"portpkg"
		]
	},
		"application/vnd.mapbox-vector-tile": {
		source: "iana",
		extensions: [
			"mvt"
		]
	},
		"application/vnd.marlin.drm.actiontoken+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.marlin.drm.conftoken+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.marlin.drm.license+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.marlin.drm.mdcf": {
		source: "iana"
	},
		"application/vnd.mason+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.maxar.archive.3tz+zip": {
		source: "iana",
		compressible: false
	},
		"application/vnd.maxmind.maxmind-db": {
		source: "iana"
	},
		"application/vnd.mcd": {
		source: "iana",
		extensions: [
			"mcd"
		]
	},
		"application/vnd.medcalcdata": {
		source: "iana",
		extensions: [
			"mc1"
		]
	},
		"application/vnd.mediastation.cdkey": {
		source: "iana",
		extensions: [
			"cdkey"
		]
	},
		"application/vnd.meridian-slingshot": {
		source: "iana"
	},
		"application/vnd.mfer": {
		source: "iana",
		extensions: [
			"mwf"
		]
	},
		"application/vnd.mfmp": {
		source: "iana",
		extensions: [
			"mfm"
		]
	},
		"application/vnd.micro+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.micrografx.flo": {
		source: "iana",
		extensions: [
			"flo"
		]
	},
		"application/vnd.micrografx.igx": {
		source: "iana",
		extensions: [
			"igx"
		]
	},
		"application/vnd.microsoft.portable-executable": {
		source: "iana"
	},
		"application/vnd.microsoft.windows.thumbnail-cache": {
		source: "iana"
	},
		"application/vnd.miele+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.mif": {
		source: "iana",
		extensions: [
			"mif"
		]
	},
		"application/vnd.minisoft-hp3000-save": {
		source: "iana"
	},
		"application/vnd.mitsubishi.misty-guard.trustweb": {
		source: "iana"
	},
		"application/vnd.mobius.daf": {
		source: "iana",
		extensions: [
			"daf"
		]
	},
		"application/vnd.mobius.dis": {
		source: "iana",
		extensions: [
			"dis"
		]
	},
		"application/vnd.mobius.mbk": {
		source: "iana",
		extensions: [
			"mbk"
		]
	},
		"application/vnd.mobius.mqy": {
		source: "iana",
		extensions: [
			"mqy"
		]
	},
		"application/vnd.mobius.msl": {
		source: "iana",
		extensions: [
			"msl"
		]
	},
		"application/vnd.mobius.plc": {
		source: "iana",
		extensions: [
			"plc"
		]
	},
		"application/vnd.mobius.txf": {
		source: "iana",
		extensions: [
			"txf"
		]
	},
		"application/vnd.mophun.application": {
		source: "iana",
		extensions: [
			"mpn"
		]
	},
		"application/vnd.mophun.certificate": {
		source: "iana",
		extensions: [
			"mpc"
		]
	},
		"application/vnd.motorola.flexsuite": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.adsi": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.fis": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.gotap": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.kmr": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.ttc": {
		source: "iana"
	},
		"application/vnd.motorola.flexsuite.wem": {
		source: "iana"
	},
		"application/vnd.motorola.iprm": {
		source: "iana"
	},
		"application/vnd.mozilla.xul+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xul"
		]
	},
		"application/vnd.ms-3mfdocument": {
		source: "iana"
	},
		"application/vnd.ms-artgalry": {
		source: "iana",
		extensions: [
			"cil"
		]
	},
		"application/vnd.ms-asf": {
		source: "iana"
	},
		"application/vnd.ms-cab-compressed": {
		source: "iana",
		extensions: [
			"cab"
		]
	},
		"application/vnd.ms-color.iccprofile": {
		source: "apache"
	},
		"application/vnd.ms-excel": {
		source: "iana",
		compressible: false,
		extensions: [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		]
	},
		"application/vnd.ms-excel.addin.macroenabled.12": {
		source: "iana",
		extensions: [
			"xlam"
		]
	},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
		source: "iana",
		extensions: [
			"xlsb"
		]
	},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
		source: "iana",
		extensions: [
			"xlsm"
		]
	},
		"application/vnd.ms-excel.template.macroenabled.12": {
		source: "iana",
		extensions: [
			"xltm"
		]
	},
		"application/vnd.ms-fontobject": {
		source: "iana",
		compressible: true,
		extensions: [
			"eot"
		]
	},
		"application/vnd.ms-htmlhelp": {
		source: "iana",
		extensions: [
			"chm"
		]
	},
		"application/vnd.ms-ims": {
		source: "iana",
		extensions: [
			"ims"
		]
	},
		"application/vnd.ms-lrm": {
		source: "iana",
		extensions: [
			"lrm"
		]
	},
		"application/vnd.ms-office.activex+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ms-officetheme": {
		source: "iana",
		extensions: [
			"thmx"
		]
	},
		"application/vnd.ms-opentype": {
		source: "apache",
		compressible: true
	},
		"application/vnd.ms-outlook": {
		compressible: false,
		extensions: [
			"msg"
		]
	},
		"application/vnd.ms-package.obfuscated-opentype": {
		source: "apache"
	},
		"application/vnd.ms-pki.seccat": {
		source: "apache",
		extensions: [
			"cat"
		]
	},
		"application/vnd.ms-pki.stl": {
		source: "apache",
		extensions: [
			"stl"
		]
	},
		"application/vnd.ms-playready.initiator+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ms-powerpoint": {
		source: "iana",
		compressible: false,
		extensions: [
			"ppt",
			"pps",
			"pot"
		]
	},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
		source: "iana",
		extensions: [
			"ppam"
		]
	},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
		source: "iana",
		extensions: [
			"pptm"
		]
	},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
		source: "iana",
		extensions: [
			"sldm"
		]
	},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
		source: "iana",
		extensions: [
			"ppsm"
		]
	},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
		source: "iana",
		extensions: [
			"potm"
		]
	},
		"application/vnd.ms-printdevicecapabilities+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ms-printing.printticket+xml": {
		source: "apache",
		compressible: true
	},
		"application/vnd.ms-printschematicket+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ms-project": {
		source: "iana",
		extensions: [
			"mpp",
			"mpt"
		]
	},
		"application/vnd.ms-tnef": {
		source: "iana"
	},
		"application/vnd.ms-windows.devicepairing": {
		source: "iana"
	},
		"application/vnd.ms-windows.nwprinting.oob": {
		source: "iana"
	},
		"application/vnd.ms-windows.printerpairing": {
		source: "iana"
	},
		"application/vnd.ms-windows.wsd.oob": {
		source: "iana"
	},
		"application/vnd.ms-wmdrm.lic-chlg-req": {
		source: "iana"
	},
		"application/vnd.ms-wmdrm.lic-resp": {
		source: "iana"
	},
		"application/vnd.ms-wmdrm.meter-chlg-req": {
		source: "iana"
	},
		"application/vnd.ms-wmdrm.meter-resp": {
		source: "iana"
	},
		"application/vnd.ms-word.document.macroenabled.12": {
		source: "iana",
		extensions: [
			"docm"
		]
	},
		"application/vnd.ms-word.template.macroenabled.12": {
		source: "iana",
		extensions: [
			"dotm"
		]
	},
		"application/vnd.ms-works": {
		source: "iana",
		extensions: [
			"wps",
			"wks",
			"wcm",
			"wdb"
		]
	},
		"application/vnd.ms-wpl": {
		source: "iana",
		extensions: [
			"wpl"
		]
	},
		"application/vnd.ms-xpsdocument": {
		source: "iana",
		compressible: false,
		extensions: [
			"xps"
		]
	},
		"application/vnd.msa-disk-image": {
		source: "iana"
	},
		"application/vnd.mseq": {
		source: "iana",
		extensions: [
			"mseq"
		]
	},
		"application/vnd.msign": {
		source: "iana"
	},
		"application/vnd.multiad.creator": {
		source: "iana"
	},
		"application/vnd.multiad.creator.cif": {
		source: "iana"
	},
		"application/vnd.music-niff": {
		source: "iana"
	},
		"application/vnd.musician": {
		source: "iana",
		extensions: [
			"mus"
		]
	},
		"application/vnd.muvee.style": {
		source: "iana",
		extensions: [
			"msty"
		]
	},
		"application/vnd.mynfc": {
		source: "iana",
		extensions: [
			"taglet"
		]
	},
		"application/vnd.nacamar.ybrid+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.ncd.control": {
		source: "iana"
	},
		"application/vnd.ncd.reference": {
		source: "iana"
	},
		"application/vnd.nearst.inv+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nebumind.line": {
		source: "iana"
	},
		"application/vnd.nervana": {
		source: "iana"
	},
		"application/vnd.netfpx": {
		source: "iana"
	},
		"application/vnd.neurolanguage.nlu": {
		source: "iana",
		extensions: [
			"nlu"
		]
	},
		"application/vnd.nimn": {
		source: "iana"
	},
		"application/vnd.nintendo.nitro.rom": {
		source: "iana"
	},
		"application/vnd.nintendo.snes.rom": {
		source: "iana"
	},
		"application/vnd.nitf": {
		source: "iana",
		extensions: [
			"ntf",
			"nitf"
		]
	},
		"application/vnd.noblenet-directory": {
		source: "iana",
		extensions: [
			"nnd"
		]
	},
		"application/vnd.noblenet-sealer": {
		source: "iana",
		extensions: [
			"nns"
		]
	},
		"application/vnd.noblenet-web": {
		source: "iana",
		extensions: [
			"nnw"
		]
	},
		"application/vnd.nokia.catalogs": {
		source: "iana"
	},
		"application/vnd.nokia.conml+wbxml": {
		source: "iana"
	},
		"application/vnd.nokia.conml+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nokia.iptv.config+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nokia.isds-radio-presets": {
		source: "iana"
	},
		"application/vnd.nokia.landmark+wbxml": {
		source: "iana"
	},
		"application/vnd.nokia.landmark+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nokia.landmarkcollection+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nokia.n-gage.ac+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"ac"
		]
	},
		"application/vnd.nokia.n-gage.data": {
		source: "iana",
		extensions: [
			"ngdat"
		]
	},
		"application/vnd.nokia.n-gage.symbian.install": {
		source: "iana",
		extensions: [
			"n-gage"
		]
	},
		"application/vnd.nokia.ncd": {
		source: "iana"
	},
		"application/vnd.nokia.pcd+wbxml": {
		source: "iana"
	},
		"application/vnd.nokia.pcd+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.nokia.radio-preset": {
		source: "iana",
		extensions: [
			"rpst"
		]
	},
		"application/vnd.nokia.radio-presets": {
		source: "iana",
		extensions: [
			"rpss"
		]
	},
		"application/vnd.novadigm.edm": {
		source: "iana",
		extensions: [
			"edm"
		]
	},
		"application/vnd.novadigm.edx": {
		source: "iana",
		extensions: [
			"edx"
		]
	},
		"application/vnd.novadigm.ext": {
		source: "iana",
		extensions: [
			"ext"
		]
	},
		"application/vnd.ntt-local.content-share": {
		source: "iana"
	},
		"application/vnd.ntt-local.file-transfer": {
		source: "iana"
	},
		"application/vnd.ntt-local.ogw_remote-access": {
		source: "iana"
	},
		"application/vnd.ntt-local.sip-ta_remote": {
		source: "iana"
	},
		"application/vnd.ntt-local.sip-ta_tcp_stream": {
		source: "iana"
	},
		"application/vnd.oasis.opendocument.chart": {
		source: "iana",
		extensions: [
			"odc"
		]
	},
		"application/vnd.oasis.opendocument.chart-template": {
		source: "iana",
		extensions: [
			"otc"
		]
	},
		"application/vnd.oasis.opendocument.database": {
		source: "iana",
		extensions: [
			"odb"
		]
	},
		"application/vnd.oasis.opendocument.formula": {
		source: "iana",
		extensions: [
			"odf"
		]
	},
		"application/vnd.oasis.opendocument.formula-template": {
		source: "iana",
		extensions: [
			"odft"
		]
	},
		"application/vnd.oasis.opendocument.graphics": {
		source: "iana",
		compressible: false,
		extensions: [
			"odg"
		]
	},
		"application/vnd.oasis.opendocument.graphics-template": {
		source: "iana",
		extensions: [
			"otg"
		]
	},
		"application/vnd.oasis.opendocument.image": {
		source: "iana",
		extensions: [
			"odi"
		]
	},
		"application/vnd.oasis.opendocument.image-template": {
		source: "iana",
		extensions: [
			"oti"
		]
	},
		"application/vnd.oasis.opendocument.presentation": {
		source: "iana",
		compressible: false,
		extensions: [
			"odp"
		]
	},
		"application/vnd.oasis.opendocument.presentation-template": {
		source: "iana",
		extensions: [
			"otp"
		]
	},
		"application/vnd.oasis.opendocument.spreadsheet": {
		source: "iana",
		compressible: false,
		extensions: [
			"ods"
		]
	},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
		source: "iana",
		extensions: [
			"ots"
		]
	},
		"application/vnd.oasis.opendocument.text": {
		source: "iana",
		compressible: false,
		extensions: [
			"odt"
		]
	},
		"application/vnd.oasis.opendocument.text-master": {
		source: "iana",
		extensions: [
			"odm"
		]
	},
		"application/vnd.oasis.opendocument.text-template": {
		source: "iana",
		extensions: [
			"ott"
		]
	},
		"application/vnd.oasis.opendocument.text-web": {
		source: "iana",
		extensions: [
			"oth"
		]
	},
		"application/vnd.obn": {
		source: "iana"
	},
		"application/vnd.ocf+cbor": {
		source: "iana"
	},
		"application/vnd.oci.image.manifest.v1+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oftn.l10n+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.contentaccessdownload+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.contentaccessstreaming+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.cspg-hexbinary": {
		source: "iana"
	},
		"application/vnd.oipf.dae.svg+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.dae.xhtml+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.pae.gem": {
		source: "iana"
	},
		"application/vnd.oipf.spdiscovery+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.spdlist+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.ueprofile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oipf.userprofile+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.olpc-sugar": {
		source: "iana",
		extensions: [
			"xo"
		]
	},
		"application/vnd.oma-scws-config": {
		source: "iana"
	},
		"application/vnd.oma-scws-http-request": {
		source: "iana"
	},
		"application/vnd.oma-scws-http-response": {
		source: "iana"
	},
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.drm-trigger+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.imd+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.ltkm": {
		source: "iana"
	},
		"application/vnd.oma.bcast.notification+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.provisioningtrigger": {
		source: "iana"
	},
		"application/vnd.oma.bcast.sgboot": {
		source: "iana"
	},
		"application/vnd.oma.bcast.sgdd+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.sgdu": {
		source: "iana"
	},
		"application/vnd.oma.bcast.simple-symbol-container": {
		source: "iana"
	},
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.sprov+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.bcast.stkm": {
		source: "iana"
	},
		"application/vnd.oma.cab-address-book+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.cab-feature-handler+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.cab-pcc+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.cab-subs-invite+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.cab-user-prefs+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.dcd": {
		source: "iana"
	},
		"application/vnd.oma.dcdc": {
		source: "iana"
	},
		"application/vnd.oma.dd2+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"dd2"
		]
	},
		"application/vnd.oma.drm.risd+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.group-usage-list+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.lwm2m+cbor": {
		source: "iana"
	},
		"application/vnd.oma.lwm2m+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.lwm2m+tlv": {
		source: "iana"
	},
		"application/vnd.oma.pal+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.poc.final-report+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.poc.groups+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.push": {
		source: "iana"
	},
		"application/vnd.oma.scidm.messages+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oma.xcap-directory+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.omads-email+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.omads-file+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.omads-folder+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.omaloc-supl-init": {
		source: "iana"
	},
		"application/vnd.onepager": {
		source: "iana"
	},
		"application/vnd.onepagertamp": {
		source: "iana"
	},
		"application/vnd.onepagertamx": {
		source: "iana"
	},
		"application/vnd.onepagertat": {
		source: "iana"
	},
		"application/vnd.onepagertatp": {
		source: "iana"
	},
		"application/vnd.onepagertatx": {
		source: "iana"
	},
		"application/vnd.openblox.game+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"obgx"
		]
	},
		"application/vnd.openblox.game-binary": {
		source: "iana"
	},
		"application/vnd.openeye.oeb": {
		source: "iana"
	},
		"application/vnd.openofficeorg.extension": {
		source: "apache",
		extensions: [
			"oxt"
		]
	},
		"application/vnd.openstreetmap.data+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"osm"
		]
	},
		"application/vnd.opentimestamps.ots": {
		source: "iana"
	},
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
		source: "iana",
		compressible: false,
		extensions: [
			"pptx"
		]
	},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
		source: "iana",
		extensions: [
			"sldx"
		]
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
		source: "iana",
		extensions: [
			"ppsx"
		]
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
		source: "iana",
		extensions: [
			"potx"
		]
	},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
		source: "iana",
		compressible: false,
		extensions: [
			"xlsx"
		]
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
		source: "iana",
		extensions: [
			"xltx"
		]
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.vmldrawing": {
		source: "iana"
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
		source: "iana",
		compressible: false,
		extensions: [
			"docx"
		]
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
		source: "iana",
		extensions: [
			"dotx"
		]
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-package.core-properties+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.openxmlformats-package.relationships+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oracle.resource+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.orange.indata": {
		source: "iana"
	},
		"application/vnd.osa.netdeploy": {
		source: "iana"
	},
		"application/vnd.osgeo.mapguide.package": {
		source: "iana",
		extensions: [
			"mgp"
		]
	},
		"application/vnd.osgi.bundle": {
		source: "iana"
	},
		"application/vnd.osgi.dp": {
		source: "iana",
		extensions: [
			"dp"
		]
	},
		"application/vnd.osgi.subsystem": {
		source: "iana",
		extensions: [
			"esa"
		]
	},
		"application/vnd.otps.ct-kip+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.oxli.countgraph": {
		source: "iana"
	},
		"application/vnd.pagerduty+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.palm": {
		source: "iana",
		extensions: [
			"pdb",
			"pqa",
			"oprc"
		]
	},
		"application/vnd.panoply": {
		source: "iana"
	},
		"application/vnd.paos.xml": {
		source: "iana"
	},
		"application/vnd.patentdive": {
		source: "iana"
	},
		"application/vnd.patientecommsdoc": {
		source: "iana"
	},
		"application/vnd.pawaafile": {
		source: "iana",
		extensions: [
			"paw"
		]
	},
		"application/vnd.pcos": {
		source: "iana"
	},
		"application/vnd.pg.format": {
		source: "iana",
		extensions: [
			"str"
		]
	},
		"application/vnd.pg.osasli": {
		source: "iana",
		extensions: [
			"ei6"
		]
	},
		"application/vnd.piaccess.application-licence": {
		source: "iana"
	},
		"application/vnd.picsel": {
		source: "iana",
		extensions: [
			"efif"
		]
	},
		"application/vnd.pmi.widget": {
		source: "iana",
		extensions: [
			"wg"
		]
	},
		"application/vnd.poc.group-advertisement+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.pocketlearn": {
		source: "iana",
		extensions: [
			"plf"
		]
	},
		"application/vnd.powerbuilder6": {
		source: "iana",
		extensions: [
			"pbd"
		]
	},
		"application/vnd.powerbuilder6-s": {
		source: "iana"
	},
		"application/vnd.powerbuilder7": {
		source: "iana"
	},
		"application/vnd.powerbuilder7-s": {
		source: "iana"
	},
		"application/vnd.powerbuilder75": {
		source: "iana"
	},
		"application/vnd.powerbuilder75-s": {
		source: "iana"
	},
		"application/vnd.preminet": {
		source: "iana"
	},
		"application/vnd.previewsystems.box": {
		source: "iana",
		extensions: [
			"box"
		]
	},
		"application/vnd.proteus.magazine": {
		source: "iana",
		extensions: [
			"mgz"
		]
	},
		"application/vnd.psfs": {
		source: "iana"
	},
		"application/vnd.publishare-delta-tree": {
		source: "iana",
		extensions: [
			"qps"
		]
	},
		"application/vnd.pvi.ptid1": {
		source: "iana",
		extensions: [
			"ptid"
		]
	},
		"application/vnd.pwg-multiplexed": {
		source: "iana"
	},
		"application/vnd.pwg-xhtml-print+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.qualcomm.brew-app-res": {
		source: "iana"
	},
		"application/vnd.quarantainenet": {
		source: "iana"
	},
		"application/vnd.quark.quarkxpress": {
		source: "iana",
		extensions: [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		]
	},
		"application/vnd.quobject-quoxdocument": {
		source: "iana"
	},
		"application/vnd.radisys.moml+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-audit+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-audit-conf+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-audit-conn+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-audit-dialog+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-audit-stream+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-conf+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-base+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-group+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-speech+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.radisys.msml-dialog-transform+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.rainstor.data": {
		source: "iana"
	},
		"application/vnd.rapid": {
		source: "iana"
	},
		"application/vnd.rar": {
		source: "iana",
		extensions: [
			"rar"
		]
	},
		"application/vnd.realvnc.bed": {
		source: "iana",
		extensions: [
			"bed"
		]
	},
		"application/vnd.recordare.musicxml": {
		source: "iana",
		extensions: [
			"mxl"
		]
	},
		"application/vnd.recordare.musicxml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"musicxml"
		]
	},
		"application/vnd.renlearn.rlprint": {
		source: "iana"
	},
		"application/vnd.resilient.logic": {
		source: "iana"
	},
		"application/vnd.restful+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.rig.cryptonote": {
		source: "iana",
		extensions: [
			"cryptonote"
		]
	},
		"application/vnd.rim.cod": {
		source: "apache",
		extensions: [
			"cod"
		]
	},
		"application/vnd.rn-realmedia": {
		source: "apache",
		extensions: [
			"rm"
		]
	},
		"application/vnd.rn-realmedia-vbr": {
		source: "apache",
		extensions: [
			"rmvb"
		]
	},
		"application/vnd.route66.link66+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"link66"
		]
	},
		"application/vnd.rs-274x": {
		source: "iana"
	},
		"application/vnd.ruckus.download": {
		source: "iana"
	},
		"application/vnd.s3sms": {
		source: "iana"
	},
		"application/vnd.sailingtracker.track": {
		source: "iana",
		extensions: [
			"st"
		]
	},
		"application/vnd.sar": {
		source: "iana"
	},
		"application/vnd.sbm.cid": {
		source: "iana"
	},
		"application/vnd.sbm.mid2": {
		source: "iana"
	},
		"application/vnd.scribus": {
		source: "iana"
	},
		"application/vnd.sealed.3df": {
		source: "iana"
	},
		"application/vnd.sealed.csf": {
		source: "iana"
	},
		"application/vnd.sealed.doc": {
		source: "iana"
	},
		"application/vnd.sealed.eml": {
		source: "iana"
	},
		"application/vnd.sealed.mht": {
		source: "iana"
	},
		"application/vnd.sealed.net": {
		source: "iana"
	},
		"application/vnd.sealed.ppt": {
		source: "iana"
	},
		"application/vnd.sealed.tiff": {
		source: "iana"
	},
		"application/vnd.sealed.xls": {
		source: "iana"
	},
		"application/vnd.sealedmedia.softseal.html": {
		source: "iana"
	},
		"application/vnd.sealedmedia.softseal.pdf": {
		source: "iana"
	},
		"application/vnd.seemail": {
		source: "iana",
		extensions: [
			"see"
		]
	},
		"application/vnd.seis+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.sema": {
		source: "iana",
		extensions: [
			"sema"
		]
	},
		"application/vnd.semd": {
		source: "iana",
		extensions: [
			"semd"
		]
	},
		"application/vnd.semf": {
		source: "iana",
		extensions: [
			"semf"
		]
	},
		"application/vnd.shade-save-file": {
		source: "iana"
	},
		"application/vnd.shana.informed.formdata": {
		source: "iana",
		extensions: [
			"ifm"
		]
	},
		"application/vnd.shana.informed.formtemplate": {
		source: "iana",
		extensions: [
			"itp"
		]
	},
		"application/vnd.shana.informed.interchange": {
		source: "iana",
		extensions: [
			"iif"
		]
	},
		"application/vnd.shana.informed.package": {
		source: "iana",
		extensions: [
			"ipk"
		]
	},
		"application/vnd.shootproof+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.shopkick+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.shp": {
		source: "iana"
	},
		"application/vnd.shx": {
		source: "iana"
	},
		"application/vnd.sigrok.session": {
		source: "iana"
	},
		"application/vnd.simtech-mindmapper": {
		source: "iana",
		extensions: [
			"twd",
			"twds"
		]
	},
		"application/vnd.siren+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.smaf": {
		source: "iana",
		extensions: [
			"mmf"
		]
	},
		"application/vnd.smart.notebook": {
		source: "iana"
	},
		"application/vnd.smart.teacher": {
		source: "iana",
		extensions: [
			"teacher"
		]
	},
		"application/vnd.snesdev-page-table": {
		source: "iana"
	},
		"application/vnd.software602.filler.form+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"fo"
		]
	},
		"application/vnd.software602.filler.form-xml-zip": {
		source: "iana"
	},
		"application/vnd.solent.sdkm+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"sdkm",
			"sdkd"
		]
	},
		"application/vnd.spotfire.dxp": {
		source: "iana",
		extensions: [
			"dxp"
		]
	},
		"application/vnd.spotfire.sfs": {
		source: "iana",
		extensions: [
			"sfs"
		]
	},
		"application/vnd.sqlite3": {
		source: "iana"
	},
		"application/vnd.sss-cod": {
		source: "iana"
	},
		"application/vnd.sss-dtf": {
		source: "iana"
	},
		"application/vnd.sss-ntf": {
		source: "iana"
	},
		"application/vnd.stardivision.calc": {
		source: "apache",
		extensions: [
			"sdc"
		]
	},
		"application/vnd.stardivision.draw": {
		source: "apache",
		extensions: [
			"sda"
		]
	},
		"application/vnd.stardivision.impress": {
		source: "apache",
		extensions: [
			"sdd"
		]
	},
		"application/vnd.stardivision.math": {
		source: "apache",
		extensions: [
			"smf"
		]
	},
		"application/vnd.stardivision.writer": {
		source: "apache",
		extensions: [
			"sdw",
			"vor"
		]
	},
		"application/vnd.stardivision.writer-global": {
		source: "apache",
		extensions: [
			"sgl"
		]
	},
		"application/vnd.stepmania.package": {
		source: "iana",
		extensions: [
			"smzip"
		]
	},
		"application/vnd.stepmania.stepchart": {
		source: "iana",
		extensions: [
			"sm"
		]
	},
		"application/vnd.street-stream": {
		source: "iana"
	},
		"application/vnd.sun.wadl+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"wadl"
		]
	},
		"application/vnd.sun.xml.calc": {
		source: "apache",
		extensions: [
			"sxc"
		]
	},
		"application/vnd.sun.xml.calc.template": {
		source: "apache",
		extensions: [
			"stc"
		]
	},
		"application/vnd.sun.xml.draw": {
		source: "apache",
		extensions: [
			"sxd"
		]
	},
		"application/vnd.sun.xml.draw.template": {
		source: "apache",
		extensions: [
			"std"
		]
	},
		"application/vnd.sun.xml.impress": {
		source: "apache",
		extensions: [
			"sxi"
		]
	},
		"application/vnd.sun.xml.impress.template": {
		source: "apache",
		extensions: [
			"sti"
		]
	},
		"application/vnd.sun.xml.math": {
		source: "apache",
		extensions: [
			"sxm"
		]
	},
		"application/vnd.sun.xml.writer": {
		source: "apache",
		extensions: [
			"sxw"
		]
	},
		"application/vnd.sun.xml.writer.global": {
		source: "apache",
		extensions: [
			"sxg"
		]
	},
		"application/vnd.sun.xml.writer.template": {
		source: "apache",
		extensions: [
			"stw"
		]
	},
		"application/vnd.sus-calendar": {
		source: "iana",
		extensions: [
			"sus",
			"susp"
		]
	},
		"application/vnd.svd": {
		source: "iana",
		extensions: [
			"svd"
		]
	},
		"application/vnd.swiftview-ics": {
		source: "iana"
	},
		"application/vnd.sycle+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.syft+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.symbian.install": {
		source: "apache",
		extensions: [
			"sis",
			"sisx"
		]
	},
		"application/vnd.syncml+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"xsm"
		]
	},
		"application/vnd.syncml.dm+wbxml": {
		source: "iana",
		charset: "UTF-8",
		extensions: [
			"bdm"
		]
	},
		"application/vnd.syncml.dm+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"xdm"
		]
	},
		"application/vnd.syncml.dm.notification": {
		source: "iana"
	},
		"application/vnd.syncml.dmddf+wbxml": {
		source: "iana"
	},
		"application/vnd.syncml.dmddf+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"ddf"
		]
	},
		"application/vnd.syncml.dmtnds+wbxml": {
		source: "iana"
	},
		"application/vnd.syncml.dmtnds+xml": {
		source: "iana",
		charset: "UTF-8",
		compressible: true
	},
		"application/vnd.syncml.ds.notification": {
		source: "iana"
	},
		"application/vnd.tableschema+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.tao.intent-module-archive": {
		source: "iana",
		extensions: [
			"tao"
		]
	},
		"application/vnd.tcpdump.pcap": {
		source: "iana",
		extensions: [
			"pcap",
			"cap",
			"dmp"
		]
	},
		"application/vnd.think-cell.ppttc+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.tmd.mediaflex.api+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.tml": {
		source: "iana"
	},
		"application/vnd.tmobile-livetv": {
		source: "iana",
		extensions: [
			"tmo"
		]
	},
		"application/vnd.tri.onesource": {
		source: "iana"
	},
		"application/vnd.trid.tpt": {
		source: "iana",
		extensions: [
			"tpt"
		]
	},
		"application/vnd.triscape.mxs": {
		source: "iana",
		extensions: [
			"mxs"
		]
	},
		"application/vnd.trueapp": {
		source: "iana",
		extensions: [
			"tra"
		]
	},
		"application/vnd.truedoc": {
		source: "iana"
	},
		"application/vnd.ubisoft.webplayer": {
		source: "iana"
	},
		"application/vnd.ufdl": {
		source: "iana",
		extensions: [
			"ufd",
			"ufdl"
		]
	},
		"application/vnd.uiq.theme": {
		source: "iana",
		extensions: [
			"utz"
		]
	},
		"application/vnd.umajin": {
		source: "iana",
		extensions: [
			"umj"
		]
	},
		"application/vnd.unity": {
		source: "iana",
		extensions: [
			"unityweb"
		]
	},
		"application/vnd.uoml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"uoml"
		]
	},
		"application/vnd.uplanet.alert": {
		source: "iana"
	},
		"application/vnd.uplanet.alert-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.bearer-choice": {
		source: "iana"
	},
		"application/vnd.uplanet.bearer-choice-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.cacheop": {
		source: "iana"
	},
		"application/vnd.uplanet.cacheop-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.channel": {
		source: "iana"
	},
		"application/vnd.uplanet.channel-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.list": {
		source: "iana"
	},
		"application/vnd.uplanet.list-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.listcmd": {
		source: "iana"
	},
		"application/vnd.uplanet.listcmd-wbxml": {
		source: "iana"
	},
		"application/vnd.uplanet.signal": {
		source: "iana"
	},
		"application/vnd.uri-map": {
		source: "iana"
	},
		"application/vnd.valve.source.material": {
		source: "iana"
	},
		"application/vnd.vcx": {
		source: "iana",
		extensions: [
			"vcx"
		]
	},
		"application/vnd.vd-study": {
		source: "iana"
	},
		"application/vnd.vectorworks": {
		source: "iana"
	},
		"application/vnd.vel+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.verimatrix.vcas": {
		source: "iana"
	},
		"application/vnd.veritone.aion+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.veryant.thin": {
		source: "iana"
	},
		"application/vnd.ves.encrypted": {
		source: "iana"
	},
		"application/vnd.vidsoft.vidconference": {
		source: "iana"
	},
		"application/vnd.visio": {
		source: "iana",
		extensions: [
			"vsd",
			"vst",
			"vss",
			"vsw"
		]
	},
		"application/vnd.visionary": {
		source: "iana",
		extensions: [
			"vis"
		]
	},
		"application/vnd.vividence.scriptfile": {
		source: "iana"
	},
		"application/vnd.vsf": {
		source: "iana",
		extensions: [
			"vsf"
		]
	},
		"application/vnd.wap.sic": {
		source: "iana"
	},
		"application/vnd.wap.slc": {
		source: "iana"
	},
		"application/vnd.wap.wbxml": {
		source: "iana",
		charset: "UTF-8",
		extensions: [
			"wbxml"
		]
	},
		"application/vnd.wap.wmlc": {
		source: "iana",
		extensions: [
			"wmlc"
		]
	},
		"application/vnd.wap.wmlscriptc": {
		source: "iana",
		extensions: [
			"wmlsc"
		]
	},
		"application/vnd.webturbo": {
		source: "iana",
		extensions: [
			"wtb"
		]
	},
		"application/vnd.wfa.dpp": {
		source: "iana"
	},
		"application/vnd.wfa.p2p": {
		source: "iana"
	},
		"application/vnd.wfa.wsc": {
		source: "iana"
	},
		"application/vnd.windows.devicepairing": {
		source: "iana"
	},
		"application/vnd.wmc": {
		source: "iana"
	},
		"application/vnd.wmf.bootstrap": {
		source: "iana"
	},
		"application/vnd.wolfram.mathematica": {
		source: "iana"
	},
		"application/vnd.wolfram.mathematica.package": {
		source: "iana"
	},
		"application/vnd.wolfram.player": {
		source: "iana",
		extensions: [
			"nbp"
		]
	},
		"application/vnd.wordperfect": {
		source: "iana",
		extensions: [
			"wpd"
		]
	},
		"application/vnd.wqd": {
		source: "iana",
		extensions: [
			"wqd"
		]
	},
		"application/vnd.wrq-hp3000-labelled": {
		source: "iana"
	},
		"application/vnd.wt.stf": {
		source: "iana",
		extensions: [
			"stf"
		]
	},
		"application/vnd.wv.csp+wbxml": {
		source: "iana"
	},
		"application/vnd.wv.csp+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.wv.ssp+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.xacml+json": {
		source: "iana",
		compressible: true
	},
		"application/vnd.xara": {
		source: "iana",
		extensions: [
			"xar"
		]
	},
		"application/vnd.xfdl": {
		source: "iana",
		extensions: [
			"xfdl"
		]
	},
		"application/vnd.xfdl.webform": {
		source: "iana"
	},
		"application/vnd.xmi+xml": {
		source: "iana",
		compressible: true
	},
		"application/vnd.xmpie.cpkg": {
		source: "iana"
	},
		"application/vnd.xmpie.dpkg": {
		source: "iana"
	},
		"application/vnd.xmpie.plan": {
		source: "iana"
	},
		"application/vnd.xmpie.ppkg": {
		source: "iana"
	},
		"application/vnd.xmpie.xlim": {
		source: "iana"
	},
		"application/vnd.yamaha.hv-dic": {
		source: "iana",
		extensions: [
			"hvd"
		]
	},
		"application/vnd.yamaha.hv-script": {
		source: "iana",
		extensions: [
			"hvs"
		]
	},
		"application/vnd.yamaha.hv-voice": {
		source: "iana",
		extensions: [
			"hvp"
		]
	},
		"application/vnd.yamaha.openscoreformat": {
		source: "iana",
		extensions: [
			"osf"
		]
	},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"osfpvg"
		]
	},
		"application/vnd.yamaha.remote-setup": {
		source: "iana"
	},
		"application/vnd.yamaha.smaf-audio": {
		source: "iana",
		extensions: [
			"saf"
		]
	},
		"application/vnd.yamaha.smaf-phrase": {
		source: "iana",
		extensions: [
			"spf"
		]
	},
		"application/vnd.yamaha.through-ngn": {
		source: "iana"
	},
		"application/vnd.yamaha.tunnel-udpencap": {
		source: "iana"
	},
		"application/vnd.yaoweme": {
		source: "iana"
	},
		"application/vnd.yellowriver-custom-menu": {
		source: "iana",
		extensions: [
			"cmp"
		]
	},
		"application/vnd.youtube.yt": {
		source: "iana"
	},
		"application/vnd.zul": {
		source: "iana",
		extensions: [
			"zir",
			"zirz"
		]
	},
		"application/vnd.zzazz.deck+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"zaz"
		]
	},
		"application/voicexml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"vxml"
		]
	},
		"application/voucher-cms+json": {
		source: "iana",
		compressible: true
	},
		"application/vq-rtcpxr": {
		source: "iana"
	},
		"application/wasm": {
		source: "iana",
		compressible: true,
		extensions: [
			"wasm"
		]
	},
		"application/watcherinfo+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"wif"
		]
	},
		"application/webpush-options+json": {
		source: "iana",
		compressible: true
	},
		"application/whoispp-query": {
		source: "iana"
	},
		"application/whoispp-response": {
		source: "iana"
	},
		"application/widget": {
		source: "iana",
		extensions: [
			"wgt"
		]
	},
		"application/winhlp": {
		source: "apache",
		extensions: [
			"hlp"
		]
	},
		"application/wita": {
		source: "iana"
	},
		"application/wordperfect5.1": {
		source: "iana"
	},
		"application/wsdl+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"wsdl"
		]
	},
		"application/wspolicy+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"wspolicy"
		]
	},
		"application/x-7z-compressed": {
		source: "apache",
		compressible: false,
		extensions: [
			"7z"
		]
	},
		"application/x-abiword": {
		source: "apache",
		extensions: [
			"abw"
		]
	},
		"application/x-ace-compressed": {
		source: "apache",
		extensions: [
			"ace"
		]
	},
		"application/x-amf": {
		source: "apache"
	},
		"application/x-apple-diskimage": {
		source: "apache",
		extensions: [
			"dmg"
		]
	},
		"application/x-arj": {
		compressible: false,
		extensions: [
			"arj"
		]
	},
		"application/x-authorware-bin": {
		source: "apache",
		extensions: [
			"aab",
			"x32",
			"u32",
			"vox"
		]
	},
		"application/x-authorware-map": {
		source: "apache",
		extensions: [
			"aam"
		]
	},
		"application/x-authorware-seg": {
		source: "apache",
		extensions: [
			"aas"
		]
	},
		"application/x-bcpio": {
		source: "apache",
		extensions: [
			"bcpio"
		]
	},
		"application/x-bdoc": {
		compressible: false,
		extensions: [
			"bdoc"
		]
	},
		"application/x-bittorrent": {
		source: "apache",
		extensions: [
			"torrent"
		]
	},
		"application/x-blorb": {
		source: "apache",
		extensions: [
			"blb",
			"blorb"
		]
	},
		"application/x-bzip": {
		source: "apache",
		compressible: false,
		extensions: [
			"bz"
		]
	},
		"application/x-bzip2": {
		source: "apache",
		compressible: false,
		extensions: [
			"bz2",
			"boz"
		]
	},
		"application/x-cbr": {
		source: "apache",
		extensions: [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		]
	},
		"application/x-cdlink": {
		source: "apache",
		extensions: [
			"vcd"
		]
	},
		"application/x-cfs-compressed": {
		source: "apache",
		extensions: [
			"cfs"
		]
	},
		"application/x-chat": {
		source: "apache",
		extensions: [
			"chat"
		]
	},
		"application/x-chess-pgn": {
		source: "apache",
		extensions: [
			"pgn"
		]
	},
		"application/x-chrome-extension": {
		extensions: [
			"crx"
		]
	},
		"application/x-cocoa": {
		source: "nginx",
		extensions: [
			"cco"
		]
	},
		"application/x-compress": {
		source: "apache"
	},
		"application/x-conference": {
		source: "apache",
		extensions: [
			"nsc"
		]
	},
		"application/x-cpio": {
		source: "apache",
		extensions: [
			"cpio"
		]
	},
		"application/x-csh": {
		source: "apache",
		extensions: [
			"csh"
		]
	},
		"application/x-deb": {
		compressible: false
	},
		"application/x-debian-package": {
		source: "apache",
		extensions: [
			"deb",
			"udeb"
		]
	},
		"application/x-dgc-compressed": {
		source: "apache",
		extensions: [
			"dgc"
		]
	},
		"application/x-director": {
		source: "apache",
		extensions: [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		]
	},
		"application/x-doom": {
		source: "apache",
		extensions: [
			"wad"
		]
	},
		"application/x-dtbncx+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"ncx"
		]
	},
		"application/x-dtbook+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"dtb"
		]
	},
		"application/x-dtbresource+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"res"
		]
	},
		"application/x-dvi": {
		source: "apache",
		compressible: false,
		extensions: [
			"dvi"
		]
	},
		"application/x-envoy": {
		source: "apache",
		extensions: [
			"evy"
		]
	},
		"application/x-eva": {
		source: "apache",
		extensions: [
			"eva"
		]
	},
		"application/x-font-bdf": {
		source: "apache",
		extensions: [
			"bdf"
		]
	},
		"application/x-font-dos": {
		source: "apache"
	},
		"application/x-font-framemaker": {
		source: "apache"
	},
		"application/x-font-ghostscript": {
		source: "apache",
		extensions: [
			"gsf"
		]
	},
		"application/x-font-libgrx": {
		source: "apache"
	},
		"application/x-font-linux-psf": {
		source: "apache",
		extensions: [
			"psf"
		]
	},
		"application/x-font-pcf": {
		source: "apache",
		extensions: [
			"pcf"
		]
	},
		"application/x-font-snf": {
		source: "apache",
		extensions: [
			"snf"
		]
	},
		"application/x-font-speedo": {
		source: "apache"
	},
		"application/x-font-sunos-news": {
		source: "apache"
	},
		"application/x-font-type1": {
		source: "apache",
		extensions: [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		]
	},
		"application/x-font-vfont": {
		source: "apache"
	},
		"application/x-freearc": {
		source: "apache",
		extensions: [
			"arc"
		]
	},
		"application/x-futuresplash": {
		source: "apache",
		extensions: [
			"spl"
		]
	},
		"application/x-gca-compressed": {
		source: "apache",
		extensions: [
			"gca"
		]
	},
		"application/x-glulx": {
		source: "apache",
		extensions: [
			"ulx"
		]
	},
		"application/x-gnumeric": {
		source: "apache",
		extensions: [
			"gnumeric"
		]
	},
		"application/x-gramps-xml": {
		source: "apache",
		extensions: [
			"gramps"
		]
	},
		"application/x-gtar": {
		source: "apache",
		extensions: [
			"gtar"
		]
	},
		"application/x-gzip": {
		source: "apache"
	},
		"application/x-hdf": {
		source: "apache",
		extensions: [
			"hdf"
		]
	},
		"application/x-httpd-php": {
		compressible: true,
		extensions: [
			"php"
		]
	},
		"application/x-install-instructions": {
		source: "apache",
		extensions: [
			"install"
		]
	},
		"application/x-iso9660-image": {
		source: "apache",
		extensions: [
			"iso"
		]
	},
		"application/x-iwork-keynote-sffkey": {
		extensions: [
			"key"
		]
	},
		"application/x-iwork-numbers-sffnumbers": {
		extensions: [
			"numbers"
		]
	},
		"application/x-iwork-pages-sffpages": {
		extensions: [
			"pages"
		]
	},
		"application/x-java-archive-diff": {
		source: "nginx",
		extensions: [
			"jardiff"
		]
	},
		"application/x-java-jnlp-file": {
		source: "apache",
		compressible: false,
		extensions: [
			"jnlp"
		]
	},
		"application/x-javascript": {
		compressible: true
	},
		"application/x-keepass2": {
		extensions: [
			"kdbx"
		]
	},
		"application/x-latex": {
		source: "apache",
		compressible: false,
		extensions: [
			"latex"
		]
	},
		"application/x-lua-bytecode": {
		extensions: [
			"luac"
		]
	},
		"application/x-lzh-compressed": {
		source: "apache",
		extensions: [
			"lzh",
			"lha"
		]
	},
		"application/x-makeself": {
		source: "nginx",
		extensions: [
			"run"
		]
	},
		"application/x-mie": {
		source: "apache",
		extensions: [
			"mie"
		]
	},
		"application/x-mobipocket-ebook": {
		source: "apache",
		extensions: [
			"prc",
			"mobi"
		]
	},
		"application/x-mpegurl": {
		compressible: false
	},
		"application/x-ms-application": {
		source: "apache",
		extensions: [
			"application"
		]
	},
		"application/x-ms-shortcut": {
		source: "apache",
		extensions: [
			"lnk"
		]
	},
		"application/x-ms-wmd": {
		source: "apache",
		extensions: [
			"wmd"
		]
	},
		"application/x-ms-wmz": {
		source: "apache",
		extensions: [
			"wmz"
		]
	},
		"application/x-ms-xbap": {
		source: "apache",
		extensions: [
			"xbap"
		]
	},
		"application/x-msaccess": {
		source: "apache",
		extensions: [
			"mdb"
		]
	},
		"application/x-msbinder": {
		source: "apache",
		extensions: [
			"obd"
		]
	},
		"application/x-mscardfile": {
		source: "apache",
		extensions: [
			"crd"
		]
	},
		"application/x-msclip": {
		source: "apache",
		extensions: [
			"clp"
		]
	},
		"application/x-msdos-program": {
		extensions: [
			"exe"
		]
	},
		"application/x-msdownload": {
		source: "apache",
		extensions: [
			"exe",
			"dll",
			"com",
			"bat",
			"msi"
		]
	},
		"application/x-msmediaview": {
		source: "apache",
		extensions: [
			"mvb",
			"m13",
			"m14"
		]
	},
		"application/x-msmetafile": {
		source: "apache",
		extensions: [
			"wmf",
			"wmz",
			"emf",
			"emz"
		]
	},
		"application/x-msmoney": {
		source: "apache",
		extensions: [
			"mny"
		]
	},
		"application/x-mspublisher": {
		source: "apache",
		extensions: [
			"pub"
		]
	},
		"application/x-msschedule": {
		source: "apache",
		extensions: [
			"scd"
		]
	},
		"application/x-msterminal": {
		source: "apache",
		extensions: [
			"trm"
		]
	},
		"application/x-mswrite": {
		source: "apache",
		extensions: [
			"wri"
		]
	},
		"application/x-netcdf": {
		source: "apache",
		extensions: [
			"nc",
			"cdf"
		]
	},
		"application/x-ns-proxy-autoconfig": {
		compressible: true,
		extensions: [
			"pac"
		]
	},
		"application/x-nzb": {
		source: "apache",
		extensions: [
			"nzb"
		]
	},
		"application/x-perl": {
		source: "nginx",
		extensions: [
			"pl",
			"pm"
		]
	},
		"application/x-pilot": {
		source: "nginx",
		extensions: [
			"prc",
			"pdb"
		]
	},
		"application/x-pkcs12": {
		source: "apache",
		compressible: false,
		extensions: [
			"p12",
			"pfx"
		]
	},
		"application/x-pkcs7-certificates": {
		source: "apache",
		extensions: [
			"p7b",
			"spc"
		]
	},
		"application/x-pkcs7-certreqresp": {
		source: "apache",
		extensions: [
			"p7r"
		]
	},
		"application/x-pki-message": {
		source: "iana"
	},
		"application/x-rar-compressed": {
		source: "apache",
		compressible: false,
		extensions: [
			"rar"
		]
	},
		"application/x-redhat-package-manager": {
		source: "nginx",
		extensions: [
			"rpm"
		]
	},
		"application/x-research-info-systems": {
		source: "apache",
		extensions: [
			"ris"
		]
	},
		"application/x-sea": {
		source: "nginx",
		extensions: [
			"sea"
		]
	},
		"application/x-sh": {
		source: "apache",
		compressible: true,
		extensions: [
			"sh"
		]
	},
		"application/x-shar": {
		source: "apache",
		extensions: [
			"shar"
		]
	},
		"application/x-shockwave-flash": {
		source: "apache",
		compressible: false,
		extensions: [
			"swf"
		]
	},
		"application/x-silverlight-app": {
		source: "apache",
		extensions: [
			"xap"
		]
	},
		"application/x-sql": {
		source: "apache",
		extensions: [
			"sql"
		]
	},
		"application/x-stuffit": {
		source: "apache",
		compressible: false,
		extensions: [
			"sit"
		]
	},
		"application/x-stuffitx": {
		source: "apache",
		extensions: [
			"sitx"
		]
	},
		"application/x-subrip": {
		source: "apache",
		extensions: [
			"srt"
		]
	},
		"application/x-sv4cpio": {
		source: "apache",
		extensions: [
			"sv4cpio"
		]
	},
		"application/x-sv4crc": {
		source: "apache",
		extensions: [
			"sv4crc"
		]
	},
		"application/x-t3vm-image": {
		source: "apache",
		extensions: [
			"t3"
		]
	},
		"application/x-tads": {
		source: "apache",
		extensions: [
			"gam"
		]
	},
		"application/x-tar": {
		source: "apache",
		compressible: true,
		extensions: [
			"tar"
		]
	},
		"application/x-tcl": {
		source: "apache",
		extensions: [
			"tcl",
			"tk"
		]
	},
		"application/x-tex": {
		source: "apache",
		extensions: [
			"tex"
		]
	},
		"application/x-tex-tfm": {
		source: "apache",
		extensions: [
			"tfm"
		]
	},
		"application/x-texinfo": {
		source: "apache",
		extensions: [
			"texinfo",
			"texi"
		]
	},
		"application/x-tgif": {
		source: "apache",
		extensions: [
			"obj"
		]
	},
		"application/x-ustar": {
		source: "apache",
		extensions: [
			"ustar"
		]
	},
		"application/x-virtualbox-hdd": {
		compressible: true,
		extensions: [
			"hdd"
		]
	},
		"application/x-virtualbox-ova": {
		compressible: true,
		extensions: [
			"ova"
		]
	},
		"application/x-virtualbox-ovf": {
		compressible: true,
		extensions: [
			"ovf"
		]
	},
		"application/x-virtualbox-vbox": {
		compressible: true,
		extensions: [
			"vbox"
		]
	},
		"application/x-virtualbox-vbox-extpack": {
		compressible: false,
		extensions: [
			"vbox-extpack"
		]
	},
		"application/x-virtualbox-vdi": {
		compressible: true,
		extensions: [
			"vdi"
		]
	},
		"application/x-virtualbox-vhd": {
		compressible: true,
		extensions: [
			"vhd"
		]
	},
		"application/x-virtualbox-vmdk": {
		compressible: true,
		extensions: [
			"vmdk"
		]
	},
		"application/x-wais-source": {
		source: "apache",
		extensions: [
			"src"
		]
	},
		"application/x-web-app-manifest+json": {
		compressible: true,
		extensions: [
			"webapp"
		]
	},
		"application/x-www-form-urlencoded": {
		source: "iana",
		compressible: true
	},
		"application/x-x509-ca-cert": {
		source: "iana",
		extensions: [
			"der",
			"crt",
			"pem"
		]
	},
		"application/x-x509-ca-ra-cert": {
		source: "iana"
	},
		"application/x-x509-next-ca-cert": {
		source: "iana"
	},
		"application/x-xfig": {
		source: "apache",
		extensions: [
			"fig"
		]
	},
		"application/x-xliff+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"xlf"
		]
	},
		"application/x-xpinstall": {
		source: "apache",
		compressible: false,
		extensions: [
			"xpi"
		]
	},
		"application/x-xz": {
		source: "apache",
		extensions: [
			"xz"
		]
	},
		"application/x-zmachine": {
		source: "apache",
		extensions: [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		]
	},
		"application/x400-bp": {
		source: "iana"
	},
		"application/xacml+xml": {
		source: "iana",
		compressible: true
	},
		"application/xaml+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"xaml"
		]
	},
		"application/xcap-att+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xav"
		]
	},
		"application/xcap-caps+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xca"
		]
	},
		"application/xcap-diff+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xdf"
		]
	},
		"application/xcap-el+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xel"
		]
	},
		"application/xcap-error+xml": {
		source: "iana",
		compressible: true
	},
		"application/xcap-ns+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xns"
		]
	},
		"application/xcon-conference-info+xml": {
		source: "iana",
		compressible: true
	},
		"application/xcon-conference-info-diff+xml": {
		source: "iana",
		compressible: true
	},
		"application/xenc+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xenc"
		]
	},
		"application/xhtml+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xhtml",
			"xht"
		]
	},
		"application/xhtml-voice+xml": {
		source: "apache",
		compressible: true
	},
		"application/xliff+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xlf"
		]
	},
		"application/xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xml",
			"xsl",
			"xsd",
			"rng"
		]
	},
		"application/xml-dtd": {
		source: "iana",
		compressible: true,
		extensions: [
			"dtd"
		]
	},
		"application/xml-external-parsed-entity": {
		source: "iana"
	},
		"application/xml-patch+xml": {
		source: "iana",
		compressible: true
	},
		"application/xmpp+xml": {
		source: "iana",
		compressible: true
	},
		"application/xop+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xop"
		]
	},
		"application/xproc+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"xpl"
		]
	},
		"application/xslt+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xsl",
			"xslt"
		]
	},
		"application/xspf+xml": {
		source: "apache",
		compressible: true,
		extensions: [
			"xspf"
		]
	},
		"application/xv+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		]
	},
		"application/yang": {
		source: "iana",
		extensions: [
			"yang"
		]
	},
		"application/yang-data+json": {
		source: "iana",
		compressible: true
	},
		"application/yang-data+xml": {
		source: "iana",
		compressible: true
	},
		"application/yang-patch+json": {
		source: "iana",
		compressible: true
	},
		"application/yang-patch+xml": {
		source: "iana",
		compressible: true
	},
		"application/yin+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"yin"
		]
	},
		"application/zip": {
		source: "iana",
		compressible: false,
		extensions: [
			"zip"
		]
	},
		"application/zlib": {
		source: "iana"
	},
		"application/zstd": {
		source: "iana"
	},
		"audio/1d-interleaved-parityfec": {
		source: "iana"
	},
		"audio/32kadpcm": {
		source: "iana"
	},
		"audio/3gpp": {
		source: "iana",
		compressible: false,
		extensions: [
			"3gpp"
		]
	},
		"audio/3gpp2": {
		source: "iana"
	},
		"audio/aac": {
		source: "iana"
	},
		"audio/ac3": {
		source: "iana"
	},
		"audio/adpcm": {
		source: "apache",
		extensions: [
			"adp"
		]
	},
		"audio/amr": {
		source: "iana",
		extensions: [
			"amr"
		]
	},
		"audio/amr-wb": {
		source: "iana"
	},
		"audio/amr-wb+": {
		source: "iana"
	},
		"audio/aptx": {
		source: "iana"
	},
		"audio/asc": {
		source: "iana"
	},
		"audio/atrac-advanced-lossless": {
		source: "iana"
	},
		"audio/atrac-x": {
		source: "iana"
	},
		"audio/atrac3": {
		source: "iana"
	},
		"audio/basic": {
		source: "iana",
		compressible: false,
		extensions: [
			"au",
			"snd"
		]
	},
		"audio/bv16": {
		source: "iana"
	},
		"audio/bv32": {
		source: "iana"
	},
		"audio/clearmode": {
		source: "iana"
	},
		"audio/cn": {
		source: "iana"
	},
		"audio/dat12": {
		source: "iana"
	},
		"audio/dls": {
		source: "iana"
	},
		"audio/dsr-es201108": {
		source: "iana"
	},
		"audio/dsr-es202050": {
		source: "iana"
	},
		"audio/dsr-es202211": {
		source: "iana"
	},
		"audio/dsr-es202212": {
		source: "iana"
	},
		"audio/dv": {
		source: "iana"
	},
		"audio/dvi4": {
		source: "iana"
	},
		"audio/eac3": {
		source: "iana"
	},
		"audio/encaprtp": {
		source: "iana"
	},
		"audio/evrc": {
		source: "iana"
	},
		"audio/evrc-qcp": {
		source: "iana"
	},
		"audio/evrc0": {
		source: "iana"
	},
		"audio/evrc1": {
		source: "iana"
	},
		"audio/evrcb": {
		source: "iana"
	},
		"audio/evrcb0": {
		source: "iana"
	},
		"audio/evrcb1": {
		source: "iana"
	},
		"audio/evrcnw": {
		source: "iana"
	},
		"audio/evrcnw0": {
		source: "iana"
	},
		"audio/evrcnw1": {
		source: "iana"
	},
		"audio/evrcwb": {
		source: "iana"
	},
		"audio/evrcwb0": {
		source: "iana"
	},
		"audio/evrcwb1": {
		source: "iana"
	},
		"audio/evs": {
		source: "iana"
	},
		"audio/flexfec": {
		source: "iana"
	},
		"audio/fwdred": {
		source: "iana"
	},
		"audio/g711-0": {
		source: "iana"
	},
		"audio/g719": {
		source: "iana"
	},
		"audio/g722": {
		source: "iana"
	},
		"audio/g7221": {
		source: "iana"
	},
		"audio/g723": {
		source: "iana"
	},
		"audio/g726-16": {
		source: "iana"
	},
		"audio/g726-24": {
		source: "iana"
	},
		"audio/g726-32": {
		source: "iana"
	},
		"audio/g726-40": {
		source: "iana"
	},
		"audio/g728": {
		source: "iana"
	},
		"audio/g729": {
		source: "iana"
	},
		"audio/g7291": {
		source: "iana"
	},
		"audio/g729d": {
		source: "iana"
	},
		"audio/g729e": {
		source: "iana"
	},
		"audio/gsm": {
		source: "iana"
	},
		"audio/gsm-efr": {
		source: "iana"
	},
		"audio/gsm-hr-08": {
		source: "iana"
	},
		"audio/ilbc": {
		source: "iana"
	},
		"audio/ip-mr_v2.5": {
		source: "iana"
	},
		"audio/isac": {
		source: "apache"
	},
		"audio/l16": {
		source: "iana"
	},
		"audio/l20": {
		source: "iana"
	},
		"audio/l24": {
		source: "iana",
		compressible: false
	},
		"audio/l8": {
		source: "iana"
	},
		"audio/lpc": {
		source: "iana"
	},
		"audio/melp": {
		source: "iana"
	},
		"audio/melp1200": {
		source: "iana"
	},
		"audio/melp2400": {
		source: "iana"
	},
		"audio/melp600": {
		source: "iana"
	},
		"audio/mhas": {
		source: "iana"
	},
		"audio/midi": {
		source: "apache",
		extensions: [
			"mid",
			"midi",
			"kar",
			"rmi"
		]
	},
		"audio/mobile-xmf": {
		source: "iana",
		extensions: [
			"mxmf"
		]
	},
		"audio/mp3": {
		compressible: false,
		extensions: [
			"mp3"
		]
	},
		"audio/mp4": {
		source: "iana",
		compressible: false,
		extensions: [
			"m4a",
			"mp4a"
		]
	},
		"audio/mp4a-latm": {
		source: "iana"
	},
		"audio/mpa": {
		source: "iana"
	},
		"audio/mpa-robust": {
		source: "iana"
	},
		"audio/mpeg": {
		source: "iana",
		compressible: false,
		extensions: [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		]
	},
		"audio/mpeg4-generic": {
		source: "iana"
	},
		"audio/musepack": {
		source: "apache"
	},
		"audio/ogg": {
		source: "iana",
		compressible: false,
		extensions: [
			"oga",
			"ogg",
			"spx",
			"opus"
		]
	},
		"audio/opus": {
		source: "iana"
	},
		"audio/parityfec": {
		source: "iana"
	},
		"audio/pcma": {
		source: "iana"
	},
		"audio/pcma-wb": {
		source: "iana"
	},
		"audio/pcmu": {
		source: "iana"
	},
		"audio/pcmu-wb": {
		source: "iana"
	},
		"audio/prs.sid": {
		source: "iana"
	},
		"audio/qcelp": {
		source: "iana"
	},
		"audio/raptorfec": {
		source: "iana"
	},
		"audio/red": {
		source: "iana"
	},
		"audio/rtp-enc-aescm128": {
		source: "iana"
	},
		"audio/rtp-midi": {
		source: "iana"
	},
		"audio/rtploopback": {
		source: "iana"
	},
		"audio/rtx": {
		source: "iana"
	},
		"audio/s3m": {
		source: "apache",
		extensions: [
			"s3m"
		]
	},
		"audio/scip": {
		source: "iana"
	},
		"audio/silk": {
		source: "apache",
		extensions: [
			"sil"
		]
	},
		"audio/smv": {
		source: "iana"
	},
		"audio/smv-qcp": {
		source: "iana"
	},
		"audio/smv0": {
		source: "iana"
	},
		"audio/sofa": {
		source: "iana"
	},
		"audio/sp-midi": {
		source: "iana"
	},
		"audio/speex": {
		source: "iana"
	},
		"audio/t140c": {
		source: "iana"
	},
		"audio/t38": {
		source: "iana"
	},
		"audio/telephone-event": {
		source: "iana"
	},
		"audio/tetra_acelp": {
		source: "iana"
	},
		"audio/tetra_acelp_bb": {
		source: "iana"
	},
		"audio/tone": {
		source: "iana"
	},
		"audio/tsvcis": {
		source: "iana"
	},
		"audio/uemclip": {
		source: "iana"
	},
		"audio/ulpfec": {
		source: "iana"
	},
		"audio/usac": {
		source: "iana"
	},
		"audio/vdvi": {
		source: "iana"
	},
		"audio/vmr-wb": {
		source: "iana"
	},
		"audio/vnd.3gpp.iufp": {
		source: "iana"
	},
		"audio/vnd.4sb": {
		source: "iana"
	},
		"audio/vnd.audiokoz": {
		source: "iana"
	},
		"audio/vnd.celp": {
		source: "iana"
	},
		"audio/vnd.cisco.nse": {
		source: "iana"
	},
		"audio/vnd.cmles.radio-events": {
		source: "iana"
	},
		"audio/vnd.cns.anp1": {
		source: "iana"
	},
		"audio/vnd.cns.inf1": {
		source: "iana"
	},
		"audio/vnd.dece.audio": {
		source: "iana",
		extensions: [
			"uva",
			"uvva"
		]
	},
		"audio/vnd.digital-winds": {
		source: "iana",
		extensions: [
			"eol"
		]
	},
		"audio/vnd.dlna.adts": {
		source: "iana"
	},
		"audio/vnd.dolby.heaac.1": {
		source: "iana"
	},
		"audio/vnd.dolby.heaac.2": {
		source: "iana"
	},
		"audio/vnd.dolby.mlp": {
		source: "iana"
	},
		"audio/vnd.dolby.mps": {
		source: "iana"
	},
		"audio/vnd.dolby.pl2": {
		source: "iana"
	},
		"audio/vnd.dolby.pl2x": {
		source: "iana"
	},
		"audio/vnd.dolby.pl2z": {
		source: "iana"
	},
		"audio/vnd.dolby.pulse.1": {
		source: "iana"
	},
		"audio/vnd.dra": {
		source: "iana",
		extensions: [
			"dra"
		]
	},
		"audio/vnd.dts": {
		source: "iana",
		extensions: [
			"dts"
		]
	},
		"audio/vnd.dts.hd": {
		source: "iana",
		extensions: [
			"dtshd"
		]
	},
		"audio/vnd.dts.uhd": {
		source: "iana"
	},
		"audio/vnd.dvb.file": {
		source: "iana"
	},
		"audio/vnd.everad.plj": {
		source: "iana"
	},
		"audio/vnd.hns.audio": {
		source: "iana"
	},
		"audio/vnd.lucent.voice": {
		source: "iana",
		extensions: [
			"lvp"
		]
	},
		"audio/vnd.ms-playready.media.pya": {
		source: "iana",
		extensions: [
			"pya"
		]
	},
		"audio/vnd.nokia.mobile-xmf": {
		source: "iana"
	},
		"audio/vnd.nortel.vbk": {
		source: "iana"
	},
		"audio/vnd.nuera.ecelp4800": {
		source: "iana",
		extensions: [
			"ecelp4800"
		]
	},
		"audio/vnd.nuera.ecelp7470": {
		source: "iana",
		extensions: [
			"ecelp7470"
		]
	},
		"audio/vnd.nuera.ecelp9600": {
		source: "iana",
		extensions: [
			"ecelp9600"
		]
	},
		"audio/vnd.octel.sbc": {
		source: "iana"
	},
		"audio/vnd.presonus.multitrack": {
		source: "iana"
	},
		"audio/vnd.qcelp": {
		source: "iana"
	},
		"audio/vnd.rhetorex.32kadpcm": {
		source: "iana"
	},
		"audio/vnd.rip": {
		source: "iana",
		extensions: [
			"rip"
		]
	},
		"audio/vnd.rn-realaudio": {
		compressible: false
	},
		"audio/vnd.sealedmedia.softseal.mpeg": {
		source: "iana"
	},
		"audio/vnd.vmx.cvsd": {
		source: "iana"
	},
		"audio/vnd.wave": {
		compressible: false
	},
		"audio/vorbis": {
		source: "iana",
		compressible: false
	},
		"audio/vorbis-config": {
		source: "iana"
	},
		"audio/wav": {
		compressible: false,
		extensions: [
			"wav"
		]
	},
		"audio/wave": {
		compressible: false,
		extensions: [
			"wav"
		]
	},
		"audio/webm": {
		source: "apache",
		compressible: false,
		extensions: [
			"weba"
		]
	},
		"audio/x-aac": {
		source: "apache",
		compressible: false,
		extensions: [
			"aac"
		]
	},
		"audio/x-aiff": {
		source: "apache",
		extensions: [
			"aif",
			"aiff",
			"aifc"
		]
	},
		"audio/x-caf": {
		source: "apache",
		compressible: false,
		extensions: [
			"caf"
		]
	},
		"audio/x-flac": {
		source: "apache",
		extensions: [
			"flac"
		]
	},
		"audio/x-m4a": {
		source: "nginx",
		extensions: [
			"m4a"
		]
	},
		"audio/x-matroska": {
		source: "apache",
		extensions: [
			"mka"
		]
	},
		"audio/x-mpegurl": {
		source: "apache",
		extensions: [
			"m3u"
		]
	},
		"audio/x-ms-wax": {
		source: "apache",
		extensions: [
			"wax"
		]
	},
		"audio/x-ms-wma": {
		source: "apache",
		extensions: [
			"wma"
		]
	},
		"audio/x-pn-realaudio": {
		source: "apache",
		extensions: [
			"ram",
			"ra"
		]
	},
		"audio/x-pn-realaudio-plugin": {
		source: "apache",
		extensions: [
			"rmp"
		]
	},
		"audio/x-realaudio": {
		source: "nginx",
		extensions: [
			"ra"
		]
	},
		"audio/x-tta": {
		source: "apache"
	},
		"audio/x-wav": {
		source: "apache",
		extensions: [
			"wav"
		]
	},
		"audio/xm": {
		source: "apache",
		extensions: [
			"xm"
		]
	},
		"chemical/x-cdx": {
		source: "apache",
		extensions: [
			"cdx"
		]
	},
		"chemical/x-cif": {
		source: "apache",
		extensions: [
			"cif"
		]
	},
		"chemical/x-cmdf": {
		source: "apache",
		extensions: [
			"cmdf"
		]
	},
		"chemical/x-cml": {
		source: "apache",
		extensions: [
			"cml"
		]
	},
		"chemical/x-csml": {
		source: "apache",
		extensions: [
			"csml"
		]
	},
		"chemical/x-pdb": {
		source: "apache"
	},
		"chemical/x-xyz": {
		source: "apache",
		extensions: [
			"xyz"
		]
	},
		"font/collection": {
		source: "iana",
		extensions: [
			"ttc"
		]
	},
		"font/otf": {
		source: "iana",
		compressible: true,
		extensions: [
			"otf"
		]
	},
		"font/sfnt": {
		source: "iana"
	},
		"font/ttf": {
		source: "iana",
		compressible: true,
		extensions: [
			"ttf"
		]
	},
		"font/woff": {
		source: "iana",
		extensions: [
			"woff"
		]
	},
		"font/woff2": {
		source: "iana",
		extensions: [
			"woff2"
		]
	},
		"image/aces": {
		source: "iana",
		extensions: [
			"exr"
		]
	},
		"image/apng": {
		compressible: false,
		extensions: [
			"apng"
		]
	},
		"image/avci": {
		source: "iana",
		extensions: [
			"avci"
		]
	},
		"image/avcs": {
		source: "iana",
		extensions: [
			"avcs"
		]
	},
		"image/avif": {
		source: "iana",
		compressible: false,
		extensions: [
			"avif"
		]
	},
		"image/bmp": {
		source: "iana",
		compressible: true,
		extensions: [
			"bmp"
		]
	},
		"image/cgm": {
		source: "iana",
		extensions: [
			"cgm"
		]
	},
		"image/dicom-rle": {
		source: "iana",
		extensions: [
			"drle"
		]
	},
		"image/emf": {
		source: "iana",
		extensions: [
			"emf"
		]
	},
		"image/fits": {
		source: "iana",
		extensions: [
			"fits"
		]
	},
		"image/g3fax": {
		source: "iana",
		extensions: [
			"g3"
		]
	},
		"image/gif": {
		source: "iana",
		compressible: false,
		extensions: [
			"gif"
		]
	},
		"image/heic": {
		source: "iana",
		extensions: [
			"heic"
		]
	},
		"image/heic-sequence": {
		source: "iana",
		extensions: [
			"heics"
		]
	},
		"image/heif": {
		source: "iana",
		extensions: [
			"heif"
		]
	},
		"image/heif-sequence": {
		source: "iana",
		extensions: [
			"heifs"
		]
	},
		"image/hej2k": {
		source: "iana",
		extensions: [
			"hej2"
		]
	},
		"image/hsj2": {
		source: "iana",
		extensions: [
			"hsj2"
		]
	},
		"image/ief": {
		source: "iana",
		extensions: [
			"ief"
		]
	},
		"image/jls": {
		source: "iana",
		extensions: [
			"jls"
		]
	},
		"image/jp2": {
		source: "iana",
		compressible: false,
		extensions: [
			"jp2",
			"jpg2"
		]
	},
		"image/jpeg": {
		source: "iana",
		compressible: false,
		extensions: [
			"jpeg",
			"jpg",
			"jpe"
		]
	},
		"image/jph": {
		source: "iana",
		extensions: [
			"jph"
		]
	},
		"image/jphc": {
		source: "iana",
		extensions: [
			"jhc"
		]
	},
		"image/jpm": {
		source: "iana",
		compressible: false,
		extensions: [
			"jpm"
		]
	},
		"image/jpx": {
		source: "iana",
		compressible: false,
		extensions: [
			"jpx",
			"jpf"
		]
	},
		"image/jxr": {
		source: "iana",
		extensions: [
			"jxr"
		]
	},
		"image/jxra": {
		source: "iana",
		extensions: [
			"jxra"
		]
	},
		"image/jxrs": {
		source: "iana",
		extensions: [
			"jxrs"
		]
	},
		"image/jxs": {
		source: "iana",
		extensions: [
			"jxs"
		]
	},
		"image/jxsc": {
		source: "iana",
		extensions: [
			"jxsc"
		]
	},
		"image/jxsi": {
		source: "iana",
		extensions: [
			"jxsi"
		]
	},
		"image/jxss": {
		source: "iana",
		extensions: [
			"jxss"
		]
	},
		"image/ktx": {
		source: "iana",
		extensions: [
			"ktx"
		]
	},
		"image/ktx2": {
		source: "iana",
		extensions: [
			"ktx2"
		]
	},
		"image/naplps": {
		source: "iana"
	},
		"image/pjpeg": {
		compressible: false
	},
		"image/png": {
		source: "iana",
		compressible: false,
		extensions: [
			"png"
		]
	},
		"image/prs.btif": {
		source: "iana",
		extensions: [
			"btif"
		]
	},
		"image/prs.pti": {
		source: "iana",
		extensions: [
			"pti"
		]
	},
		"image/pwg-raster": {
		source: "iana"
	},
		"image/sgi": {
		source: "apache",
		extensions: [
			"sgi"
		]
	},
		"image/svg+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"svg",
			"svgz"
		]
	},
		"image/t38": {
		source: "iana",
		extensions: [
			"t38"
		]
	},
		"image/tiff": {
		source: "iana",
		compressible: false,
		extensions: [
			"tif",
			"tiff"
		]
	},
		"image/tiff-fx": {
		source: "iana",
		extensions: [
			"tfx"
		]
	},
		"image/vnd.adobe.photoshop": {
		source: "iana",
		compressible: true,
		extensions: [
			"psd"
		]
	},
		"image/vnd.airzip.accelerator.azv": {
		source: "iana",
		extensions: [
			"azv"
		]
	},
		"image/vnd.cns.inf2": {
		source: "iana"
	},
		"image/vnd.dece.graphic": {
		source: "iana",
		extensions: [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		]
	},
		"image/vnd.djvu": {
		source: "iana",
		extensions: [
			"djvu",
			"djv"
		]
	},
		"image/vnd.dvb.subtitle": {
		source: "iana",
		extensions: [
			"sub"
		]
	},
		"image/vnd.dwg": {
		source: "iana",
		extensions: [
			"dwg"
		]
	},
		"image/vnd.dxf": {
		source: "iana",
		extensions: [
			"dxf"
		]
	},
		"image/vnd.fastbidsheet": {
		source: "iana",
		extensions: [
			"fbs"
		]
	},
		"image/vnd.fpx": {
		source: "iana",
		extensions: [
			"fpx"
		]
	},
		"image/vnd.fst": {
		source: "iana",
		extensions: [
			"fst"
		]
	},
		"image/vnd.fujixerox.edmics-mmr": {
		source: "iana",
		extensions: [
			"mmr"
		]
	},
		"image/vnd.fujixerox.edmics-rlc": {
		source: "iana",
		extensions: [
			"rlc"
		]
	},
		"image/vnd.globalgraphics.pgb": {
		source: "iana"
	},
		"image/vnd.microsoft.icon": {
		source: "iana",
		compressible: true,
		extensions: [
			"ico"
		]
	},
		"image/vnd.mix": {
		source: "iana"
	},
		"image/vnd.mozilla.apng": {
		source: "iana"
	},
		"image/vnd.ms-dds": {
		compressible: true,
		extensions: [
			"dds"
		]
	},
		"image/vnd.ms-modi": {
		source: "iana",
		extensions: [
			"mdi"
		]
	},
		"image/vnd.ms-photo": {
		source: "apache",
		extensions: [
			"wdp"
		]
	},
		"image/vnd.net-fpx": {
		source: "iana",
		extensions: [
			"npx"
		]
	},
		"image/vnd.pco.b16": {
		source: "iana",
		extensions: [
			"b16"
		]
	},
		"image/vnd.radiance": {
		source: "iana"
	},
		"image/vnd.sealed.png": {
		source: "iana"
	},
		"image/vnd.sealedmedia.softseal.gif": {
		source: "iana"
	},
		"image/vnd.sealedmedia.softseal.jpg": {
		source: "iana"
	},
		"image/vnd.svf": {
		source: "iana"
	},
		"image/vnd.tencent.tap": {
		source: "iana",
		extensions: [
			"tap"
		]
	},
		"image/vnd.valve.source.texture": {
		source: "iana",
		extensions: [
			"vtf"
		]
	},
		"image/vnd.wap.wbmp": {
		source: "iana",
		extensions: [
			"wbmp"
		]
	},
		"image/vnd.xiff": {
		source: "iana",
		extensions: [
			"xif"
		]
	},
		"image/vnd.zbrush.pcx": {
		source: "iana",
		extensions: [
			"pcx"
		]
	},
		"image/webp": {
		source: "apache",
		extensions: [
			"webp"
		]
	},
		"image/wmf": {
		source: "iana",
		extensions: [
			"wmf"
		]
	},
		"image/x-3ds": {
		source: "apache",
		extensions: [
			"3ds"
		]
	},
		"image/x-cmu-raster": {
		source: "apache",
		extensions: [
			"ras"
		]
	},
		"image/x-cmx": {
		source: "apache",
		extensions: [
			"cmx"
		]
	},
		"image/x-freehand": {
		source: "apache",
		extensions: [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		]
	},
		"image/x-icon": {
		source: "apache",
		compressible: true,
		extensions: [
			"ico"
		]
	},
		"image/x-jng": {
		source: "nginx",
		extensions: [
			"jng"
		]
	},
		"image/x-mrsid-image": {
		source: "apache",
		extensions: [
			"sid"
		]
	},
		"image/x-ms-bmp": {
		source: "nginx",
		compressible: true,
		extensions: [
			"bmp"
		]
	},
		"image/x-pcx": {
		source: "apache",
		extensions: [
			"pcx"
		]
	},
		"image/x-pict": {
		source: "apache",
		extensions: [
			"pic",
			"pct"
		]
	},
		"image/x-portable-anymap": {
		source: "apache",
		extensions: [
			"pnm"
		]
	},
		"image/x-portable-bitmap": {
		source: "apache",
		extensions: [
			"pbm"
		]
	},
		"image/x-portable-graymap": {
		source: "apache",
		extensions: [
			"pgm"
		]
	},
		"image/x-portable-pixmap": {
		source: "apache",
		extensions: [
			"ppm"
		]
	},
		"image/x-rgb": {
		source: "apache",
		extensions: [
			"rgb"
		]
	},
		"image/x-tga": {
		source: "apache",
		extensions: [
			"tga"
		]
	},
		"image/x-xbitmap": {
		source: "apache",
		extensions: [
			"xbm"
		]
	},
		"image/x-xcf": {
		compressible: false
	},
		"image/x-xpixmap": {
		source: "apache",
		extensions: [
			"xpm"
		]
	},
		"image/x-xwindowdump": {
		source: "apache",
		extensions: [
			"xwd"
		]
	},
		"message/cpim": {
		source: "iana"
	},
		"message/delivery-status": {
		source: "iana"
	},
		"message/disposition-notification": {
		source: "iana",
		extensions: [
			"disposition-notification"
		]
	},
		"message/external-body": {
		source: "iana"
	},
		"message/feedback-report": {
		source: "iana"
	},
		"message/global": {
		source: "iana",
		extensions: [
			"u8msg"
		]
	},
		"message/global-delivery-status": {
		source: "iana",
		extensions: [
			"u8dsn"
		]
	},
		"message/global-disposition-notification": {
		source: "iana",
		extensions: [
			"u8mdn"
		]
	},
		"message/global-headers": {
		source: "iana",
		extensions: [
			"u8hdr"
		]
	},
		"message/http": {
		source: "iana",
		compressible: false
	},
		"message/imdn+xml": {
		source: "iana",
		compressible: true
	},
		"message/news": {
		source: "iana"
	},
		"message/partial": {
		source: "iana",
		compressible: false
	},
		"message/rfc822": {
		source: "iana",
		compressible: true,
		extensions: [
			"eml",
			"mime"
		]
	},
		"message/s-http": {
		source: "iana"
	},
		"message/sip": {
		source: "iana"
	},
		"message/sipfrag": {
		source: "iana"
	},
		"message/tracking-status": {
		source: "iana"
	},
		"message/vnd.si.simp": {
		source: "iana"
	},
		"message/vnd.wfa.wsc": {
		source: "iana",
		extensions: [
			"wsc"
		]
	},
		"model/3mf": {
		source: "iana",
		extensions: [
			"3mf"
		]
	},
		"model/e57": {
		source: "iana"
	},
		"model/gltf+json": {
		source: "iana",
		compressible: true,
		extensions: [
			"gltf"
		]
	},
		"model/gltf-binary": {
		source: "iana",
		compressible: true,
		extensions: [
			"glb"
		]
	},
		"model/iges": {
		source: "iana",
		compressible: false,
		extensions: [
			"igs",
			"iges"
		]
	},
		"model/mesh": {
		source: "iana",
		compressible: false,
		extensions: [
			"msh",
			"mesh",
			"silo"
		]
	},
		"model/mtl": {
		source: "iana",
		extensions: [
			"mtl"
		]
	},
		"model/obj": {
		source: "iana",
		extensions: [
			"obj"
		]
	},
		"model/step": {
		source: "iana"
	},
		"model/step+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"stpx"
		]
	},
		"model/step+zip": {
		source: "iana",
		compressible: false,
		extensions: [
			"stpz"
		]
	},
		"model/step-xml+zip": {
		source: "iana",
		compressible: false,
		extensions: [
			"stpxz"
		]
	},
		"model/stl": {
		source: "iana",
		extensions: [
			"stl"
		]
	},
		"model/vnd.collada+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"dae"
		]
	},
		"model/vnd.dwf": {
		source: "iana",
		extensions: [
			"dwf"
		]
	},
		"model/vnd.flatland.3dml": {
		source: "iana"
	},
		"model/vnd.gdl": {
		source: "iana",
		extensions: [
			"gdl"
		]
	},
		"model/vnd.gs-gdl": {
		source: "apache"
	},
		"model/vnd.gs.gdl": {
		source: "iana"
	},
		"model/vnd.gtw": {
		source: "iana",
		extensions: [
			"gtw"
		]
	},
		"model/vnd.moml+xml": {
		source: "iana",
		compressible: true
	},
		"model/vnd.mts": {
		source: "iana",
		extensions: [
			"mts"
		]
	},
		"model/vnd.opengex": {
		source: "iana",
		extensions: [
			"ogex"
		]
	},
		"model/vnd.parasolid.transmit.binary": {
		source: "iana",
		extensions: [
			"x_b"
		]
	},
		"model/vnd.parasolid.transmit.text": {
		source: "iana",
		extensions: [
			"x_t"
		]
	},
		"model/vnd.pytha.pyox": {
		source: "iana"
	},
		"model/vnd.rosette.annotated-data-model": {
		source: "iana"
	},
		"model/vnd.sap.vds": {
		source: "iana",
		extensions: [
			"vds"
		]
	},
		"model/vnd.usdz+zip": {
		source: "iana",
		compressible: false,
		extensions: [
			"usdz"
		]
	},
		"model/vnd.valve.source.compiled-map": {
		source: "iana",
		extensions: [
			"bsp"
		]
	},
		"model/vnd.vtu": {
		source: "iana",
		extensions: [
			"vtu"
		]
	},
		"model/vrml": {
		source: "iana",
		compressible: false,
		extensions: [
			"wrl",
			"vrml"
		]
	},
		"model/x3d+binary": {
		source: "apache",
		compressible: false,
		extensions: [
			"x3db",
			"x3dbz"
		]
	},
		"model/x3d+fastinfoset": {
		source: "iana",
		extensions: [
			"x3db"
		]
	},
		"model/x3d+vrml": {
		source: "apache",
		compressible: false,
		extensions: [
			"x3dv",
			"x3dvz"
		]
	},
		"model/x3d+xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"x3d",
			"x3dz"
		]
	},
		"model/x3d-vrml": {
		source: "iana",
		extensions: [
			"x3dv"
		]
	},
		"multipart/alternative": {
		source: "iana",
		compressible: false
	},
		"multipart/appledouble": {
		source: "iana"
	},
		"multipart/byteranges": {
		source: "iana"
	},
		"multipart/digest": {
		source: "iana"
	},
		"multipart/encrypted": {
		source: "iana",
		compressible: false
	},
		"multipart/form-data": {
		source: "iana",
		compressible: false
	},
		"multipart/header-set": {
		source: "iana"
	},
		"multipart/mixed": {
		source: "iana"
	},
		"multipart/multilingual": {
		source: "iana"
	},
		"multipart/parallel": {
		source: "iana"
	},
		"multipart/related": {
		source: "iana",
		compressible: false
	},
		"multipart/report": {
		source: "iana"
	},
		"multipart/signed": {
		source: "iana",
		compressible: false
	},
		"multipart/vnd.bint.med-plus": {
		source: "iana"
	},
		"multipart/voice-message": {
		source: "iana"
	},
		"multipart/x-mixed-replace": {
		source: "iana"
	},
		"text/1d-interleaved-parityfec": {
		source: "iana"
	},
		"text/cache-manifest": {
		source: "iana",
		compressible: true,
		extensions: [
			"appcache",
			"manifest"
		]
	},
		"text/calendar": {
		source: "iana",
		extensions: [
			"ics",
			"ifb"
		]
	},
		"text/calender": {
		compressible: true
	},
		"text/cmd": {
		compressible: true
	},
		"text/coffeescript": {
		extensions: [
			"coffee",
			"litcoffee"
		]
	},
		"text/cql": {
		source: "iana"
	},
		"text/cql-expression": {
		source: "iana"
	},
		"text/cql-identifier": {
		source: "iana"
	},
		"text/css": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"css"
		]
	},
		"text/csv": {
		source: "iana",
		compressible: true,
		extensions: [
			"csv"
		]
	},
		"text/csv-schema": {
		source: "iana"
	},
		"text/directory": {
		source: "iana"
	},
		"text/dns": {
		source: "iana"
	},
		"text/ecmascript": {
		source: "iana"
	},
		"text/encaprtp": {
		source: "iana"
	},
		"text/enriched": {
		source: "iana"
	},
		"text/fhirpath": {
		source: "iana"
	},
		"text/flexfec": {
		source: "iana"
	},
		"text/fwdred": {
		source: "iana"
	},
		"text/gff3": {
		source: "iana"
	},
		"text/grammar-ref-list": {
		source: "iana"
	},
		"text/html": {
		source: "iana",
		compressible: true,
		extensions: [
			"html",
			"htm",
			"shtml"
		]
	},
		"text/jade": {
		extensions: [
			"jade"
		]
	},
		"text/javascript": {
		source: "iana",
		compressible: true
	},
		"text/jcr-cnd": {
		source: "iana"
	},
		"text/jsx": {
		compressible: true,
		extensions: [
			"jsx"
		]
	},
		"text/less": {
		compressible: true,
		extensions: [
			"less"
		]
	},
		"text/markdown": {
		source: "iana",
		compressible: true,
		extensions: [
			"markdown",
			"md"
		]
	},
		"text/mathml": {
		source: "nginx",
		extensions: [
			"mml"
		]
	},
		"text/mdx": {
		compressible: true,
		extensions: [
			"mdx"
		]
	},
		"text/mizar": {
		source: "iana"
	},
		"text/n3": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"n3"
		]
	},
		"text/parameters": {
		source: "iana",
		charset: "UTF-8"
	},
		"text/parityfec": {
		source: "iana"
	},
		"text/plain": {
		source: "iana",
		compressible: true,
		extensions: [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		]
	},
		"text/provenance-notation": {
		source: "iana",
		charset: "UTF-8"
	},
		"text/prs.fallenstein.rst": {
		source: "iana"
	},
		"text/prs.lines.tag": {
		source: "iana",
		extensions: [
			"dsc"
		]
	},
		"text/prs.prop.logic": {
		source: "iana"
	},
		"text/raptorfec": {
		source: "iana"
	},
		"text/red": {
		source: "iana"
	},
		"text/rfc822-headers": {
		source: "iana"
	},
		"text/richtext": {
		source: "iana",
		compressible: true,
		extensions: [
			"rtx"
		]
	},
		"text/rtf": {
		source: "iana",
		compressible: true,
		extensions: [
			"rtf"
		]
	},
		"text/rtp-enc-aescm128": {
		source: "iana"
	},
		"text/rtploopback": {
		source: "iana"
	},
		"text/rtx": {
		source: "iana"
	},
		"text/sgml": {
		source: "iana",
		extensions: [
			"sgml",
			"sgm"
		]
	},
		"text/shaclc": {
		source: "iana"
	},
		"text/shex": {
		source: "iana",
		extensions: [
			"shex"
		]
	},
		"text/slim": {
		extensions: [
			"slim",
			"slm"
		]
	},
		"text/spdx": {
		source: "iana",
		extensions: [
			"spdx"
		]
	},
		"text/strings": {
		source: "iana"
	},
		"text/stylus": {
		extensions: [
			"stylus",
			"styl"
		]
	},
		"text/t140": {
		source: "iana"
	},
		"text/tab-separated-values": {
		source: "iana",
		compressible: true,
		extensions: [
			"tsv"
		]
	},
		"text/troff": {
		source: "iana",
		extensions: [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		]
	},
		"text/turtle": {
		source: "iana",
		charset: "UTF-8",
		extensions: [
			"ttl"
		]
	},
		"text/ulpfec": {
		source: "iana"
	},
		"text/uri-list": {
		source: "iana",
		compressible: true,
		extensions: [
			"uri",
			"uris",
			"urls"
		]
	},
		"text/vcard": {
		source: "iana",
		compressible: true,
		extensions: [
			"vcard"
		]
	},
		"text/vnd.a": {
		source: "iana"
	},
		"text/vnd.abc": {
		source: "iana"
	},
		"text/vnd.ascii-art": {
		source: "iana"
	},
		"text/vnd.curl": {
		source: "iana",
		extensions: [
			"curl"
		]
	},
		"text/vnd.curl.dcurl": {
		source: "apache",
		extensions: [
			"dcurl"
		]
	},
		"text/vnd.curl.mcurl": {
		source: "apache",
		extensions: [
			"mcurl"
		]
	},
		"text/vnd.curl.scurl": {
		source: "apache",
		extensions: [
			"scurl"
		]
	},
		"text/vnd.debian.copyright": {
		source: "iana",
		charset: "UTF-8"
	},
		"text/vnd.dmclientscript": {
		source: "iana"
	},
		"text/vnd.dvb.subtitle": {
		source: "iana",
		extensions: [
			"sub"
		]
	},
		"text/vnd.esmertec.theme-descriptor": {
		source: "iana",
		charset: "UTF-8"
	},
		"text/vnd.familysearch.gedcom": {
		source: "iana",
		extensions: [
			"ged"
		]
	},
		"text/vnd.ficlab.flt": {
		source: "iana"
	},
		"text/vnd.fly": {
		source: "iana",
		extensions: [
			"fly"
		]
	},
		"text/vnd.fmi.flexstor": {
		source: "iana",
		extensions: [
			"flx"
		]
	},
		"text/vnd.gml": {
		source: "iana"
	},
		"text/vnd.graphviz": {
		source: "iana",
		extensions: [
			"gv"
		]
	},
		"text/vnd.hans": {
		source: "iana"
	},
		"text/vnd.hgl": {
		source: "iana"
	},
		"text/vnd.in3d.3dml": {
		source: "iana",
		extensions: [
			"3dml"
		]
	},
		"text/vnd.in3d.spot": {
		source: "iana",
		extensions: [
			"spot"
		]
	},
		"text/vnd.iptc.newsml": {
		source: "iana"
	},
		"text/vnd.iptc.nitf": {
		source: "iana"
	},
		"text/vnd.latex-z": {
		source: "iana"
	},
		"text/vnd.motorola.reflex": {
		source: "iana"
	},
		"text/vnd.ms-mediapackage": {
		source: "iana"
	},
		"text/vnd.net2phone.commcenter.command": {
		source: "iana"
	},
		"text/vnd.radisys.msml-basic-layout": {
		source: "iana"
	},
		"text/vnd.senx.warpscript": {
		source: "iana"
	},
		"text/vnd.si.uricatalogue": {
		source: "iana"
	},
		"text/vnd.sosi": {
		source: "iana"
	},
		"text/vnd.sun.j2me.app-descriptor": {
		source: "iana",
		charset: "UTF-8",
		extensions: [
			"jad"
		]
	},
		"text/vnd.trolltech.linguist": {
		source: "iana",
		charset: "UTF-8"
	},
		"text/vnd.wap.si": {
		source: "iana"
	},
		"text/vnd.wap.sl": {
		source: "iana"
	},
		"text/vnd.wap.wml": {
		source: "iana",
		extensions: [
			"wml"
		]
	},
		"text/vnd.wap.wmlscript": {
		source: "iana",
		extensions: [
			"wmls"
		]
	},
		"text/vtt": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: [
			"vtt"
		]
	},
		"text/x-asm": {
		source: "apache",
		extensions: [
			"s",
			"asm"
		]
	},
		"text/x-c": {
		source: "apache",
		extensions: [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		]
	},
		"text/x-component": {
		source: "nginx",
		extensions: [
			"htc"
		]
	},
		"text/x-fortran": {
		source: "apache",
		extensions: [
			"f",
			"for",
			"f77",
			"f90"
		]
	},
		"text/x-gwt-rpc": {
		compressible: true
	},
		"text/x-handlebars-template": {
		extensions: [
			"hbs"
		]
	},
		"text/x-java-source": {
		source: "apache",
		extensions: [
			"java"
		]
	},
		"text/x-jquery-tmpl": {
		compressible: true
	},
		"text/x-lua": {
		extensions: [
			"lua"
		]
	},
		"text/x-markdown": {
		compressible: true,
		extensions: [
			"mkd"
		]
	},
		"text/x-nfo": {
		source: "apache",
		extensions: [
			"nfo"
		]
	},
		"text/x-opml": {
		source: "apache",
		extensions: [
			"opml"
		]
	},
		"text/x-org": {
		compressible: true,
		extensions: [
			"org"
		]
	},
		"text/x-pascal": {
		source: "apache",
		extensions: [
			"p",
			"pas"
		]
	},
		"text/x-processing": {
		compressible: true,
		extensions: [
			"pde"
		]
	},
		"text/x-sass": {
		extensions: [
			"sass"
		]
	},
		"text/x-scss": {
		extensions: [
			"scss"
		]
	},
		"text/x-setext": {
		source: "apache",
		extensions: [
			"etx"
		]
	},
		"text/x-sfv": {
		source: "apache",
		extensions: [
			"sfv"
		]
	},
		"text/x-suse-ymp": {
		compressible: true,
		extensions: [
			"ymp"
		]
	},
		"text/x-uuencode": {
		source: "apache",
		extensions: [
			"uu"
		]
	},
		"text/x-vcalendar": {
		source: "apache",
		extensions: [
			"vcs"
		]
	},
		"text/x-vcard": {
		source: "apache",
		extensions: [
			"vcf"
		]
	},
		"text/xml": {
		source: "iana",
		compressible: true,
		extensions: [
			"xml"
		]
	},
		"text/xml-external-parsed-entity": {
		source: "iana"
	},
		"text/yaml": {
		compressible: true,
		extensions: [
			"yaml",
			"yml"
		]
	},
		"video/1d-interleaved-parityfec": {
		source: "iana"
	},
		"video/3gpp": {
		source: "iana",
		extensions: [
			"3gp",
			"3gpp"
		]
	},
		"video/3gpp-tt": {
		source: "iana"
	},
		"video/3gpp2": {
		source: "iana",
		extensions: [
			"3g2"
		]
	},
		"video/av1": {
		source: "iana"
	},
		"video/bmpeg": {
		source: "iana"
	},
		"video/bt656": {
		source: "iana"
	},
		"video/celb": {
		source: "iana"
	},
		"video/dv": {
		source: "iana"
	},
		"video/encaprtp": {
		source: "iana"
	},
		"video/ffv1": {
		source: "iana"
	},
		"video/flexfec": {
		source: "iana"
	},
		"video/h261": {
		source: "iana",
		extensions: [
			"h261"
		]
	},
		"video/h263": {
		source: "iana",
		extensions: [
			"h263"
		]
	},
		"video/h263-1998": {
		source: "iana"
	},
		"video/h263-2000": {
		source: "iana"
	},
		"video/h264": {
		source: "iana",
		extensions: [
			"h264"
		]
	},
		"video/h264-rcdo": {
		source: "iana"
	},
		"video/h264-svc": {
		source: "iana"
	},
		"video/h265": {
		source: "iana"
	},
		"video/iso.segment": {
		source: "iana",
		extensions: [
			"m4s"
		]
	},
		"video/jpeg": {
		source: "iana",
		extensions: [
			"jpgv"
		]
	},
		"video/jpeg2000": {
		source: "iana"
	},
		"video/jpm": {
		source: "apache",
		extensions: [
			"jpm",
			"jpgm"
		]
	},
		"video/jxsv": {
		source: "iana"
	},
		"video/mj2": {
		source: "iana",
		extensions: [
			"mj2",
			"mjp2"
		]
	},
		"video/mp1s": {
		source: "iana"
	},
		"video/mp2p": {
		source: "iana"
	},
		"video/mp2t": {
		source: "iana",
		extensions: [
			"ts"
		]
	},
		"video/mp4": {
		source: "iana",
		compressible: false,
		extensions: [
			"mp4",
			"mp4v",
			"mpg4"
		]
	},
		"video/mp4v-es": {
		source: "iana"
	},
		"video/mpeg": {
		source: "iana",
		compressible: false,
		extensions: [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		]
	},
		"video/mpeg4-generic": {
		source: "iana"
	},
		"video/mpv": {
		source: "iana"
	},
		"video/nv": {
		source: "iana"
	},
		"video/ogg": {
		source: "iana",
		compressible: false,
		extensions: [
			"ogv"
		]
	},
		"video/parityfec": {
		source: "iana"
	},
		"video/pointer": {
		source: "iana"
	},
		"video/quicktime": {
		source: "iana",
		compressible: false,
		extensions: [
			"qt",
			"mov"
		]
	},
		"video/raptorfec": {
		source: "iana"
	},
		"video/raw": {
		source: "iana"
	},
		"video/rtp-enc-aescm128": {
		source: "iana"
	},
		"video/rtploopback": {
		source: "iana"
	},
		"video/rtx": {
		source: "iana"
	},
		"video/scip": {
		source: "iana"
	},
		"video/smpte291": {
		source: "iana"
	},
		"video/smpte292m": {
		source: "iana"
	},
		"video/ulpfec": {
		source: "iana"
	},
		"video/vc1": {
		source: "iana"
	},
		"video/vc2": {
		source: "iana"
	},
		"video/vnd.cctv": {
		source: "iana"
	},
		"video/vnd.dece.hd": {
		source: "iana",
		extensions: [
			"uvh",
			"uvvh"
		]
	},
		"video/vnd.dece.mobile": {
		source: "iana",
		extensions: [
			"uvm",
			"uvvm"
		]
	},
		"video/vnd.dece.mp4": {
		source: "iana"
	},
		"video/vnd.dece.pd": {
		source: "iana",
		extensions: [
			"uvp",
			"uvvp"
		]
	},
		"video/vnd.dece.sd": {
		source: "iana",
		extensions: [
			"uvs",
			"uvvs"
		]
	},
		"video/vnd.dece.video": {
		source: "iana",
		extensions: [
			"uvv",
			"uvvv"
		]
	},
		"video/vnd.directv.mpeg": {
		source: "iana"
	},
		"video/vnd.directv.mpeg-tts": {
		source: "iana"
	},
		"video/vnd.dlna.mpeg-tts": {
		source: "iana"
	},
		"video/vnd.dvb.file": {
		source: "iana",
		extensions: [
			"dvb"
		]
	},
		"video/vnd.fvt": {
		source: "iana",
		extensions: [
			"fvt"
		]
	},
		"video/vnd.hns.video": {
		source: "iana"
	},
		"video/vnd.iptvforum.1dparityfec-1010": {
		source: "iana"
	},
		"video/vnd.iptvforum.1dparityfec-2005": {
		source: "iana"
	},
		"video/vnd.iptvforum.2dparityfec-1010": {
		source: "iana"
	},
		"video/vnd.iptvforum.2dparityfec-2005": {
		source: "iana"
	},
		"video/vnd.iptvforum.ttsavc": {
		source: "iana"
	},
		"video/vnd.iptvforum.ttsmpeg2": {
		source: "iana"
	},
		"video/vnd.motorola.video": {
		source: "iana"
	},
		"video/vnd.motorola.videop": {
		source: "iana"
	},
		"video/vnd.mpegurl": {
		source: "iana",
		extensions: [
			"mxu",
			"m4u"
		]
	},
		"video/vnd.ms-playready.media.pyv": {
		source: "iana",
		extensions: [
			"pyv"
		]
	},
		"video/vnd.nokia.interleaved-multimedia": {
		source: "iana"
	},
		"video/vnd.nokia.mp4vr": {
		source: "iana"
	},
		"video/vnd.nokia.videovoip": {
		source: "iana"
	},
		"video/vnd.objectvideo": {
		source: "iana"
	},
		"video/vnd.radgamettools.bink": {
		source: "iana"
	},
		"video/vnd.radgamettools.smacker": {
		source: "iana"
	},
		"video/vnd.sealed.mpeg1": {
		source: "iana"
	},
		"video/vnd.sealed.mpeg4": {
		source: "iana"
	},
		"video/vnd.sealed.swf": {
		source: "iana"
	},
		"video/vnd.sealedmedia.softseal.mov": {
		source: "iana"
	},
		"video/vnd.uvvu.mp4": {
		source: "iana",
		extensions: [
			"uvu",
			"uvvu"
		]
	},
		"video/vnd.vivo": {
		source: "iana",
		extensions: [
			"viv"
		]
	},
		"video/vnd.youtube.yt": {
		source: "iana"
	},
		"video/vp8": {
		source: "iana"
	},
		"video/vp9": {
		source: "iana"
	},
		"video/webm": {
		source: "apache",
		compressible: false,
		extensions: [
			"webm"
		]
	},
		"video/x-f4v": {
		source: "apache",
		extensions: [
			"f4v"
		]
	},
		"video/x-fli": {
		source: "apache",
		extensions: [
			"fli"
		]
	},
		"video/x-flv": {
		source: "apache",
		compressible: false,
		extensions: [
			"flv"
		]
	},
		"video/x-m4v": {
		source: "apache",
		extensions: [
			"m4v"
		]
	},
		"video/x-matroska": {
		source: "apache",
		compressible: false,
		extensions: [
			"mkv",
			"mk3d",
			"mks"
		]
	},
		"video/x-mng": {
		source: "apache",
		extensions: [
			"mng"
		]
	},
		"video/x-ms-asf": {
		source: "apache",
		extensions: [
			"asf",
			"asx"
		]
	},
		"video/x-ms-vob": {
		source: "apache",
		extensions: [
			"vob"
		]
	},
		"video/x-ms-wm": {
		source: "apache",
		extensions: [
			"wm"
		]
	},
		"video/x-ms-wmv": {
		source: "apache",
		compressible: false,
		extensions: [
			"wmv"
		]
	},
		"video/x-ms-wmx": {
		source: "apache",
		extensions: [
			"wmx"
		]
	},
		"video/x-ms-wvx": {
		source: "apache",
		extensions: [
			"wvx"
		]
	},
		"video/x-msvideo": {
		source: "apache",
		extensions: [
			"avi"
		]
	},
		"video/x-sgi-movie": {
		source: "apache",
		extensions: [
			"movie"
		]
	},
		"video/x-smv": {
		source: "apache",
		extensions: [
			"smv"
		]
	},
		"x-conference/x-cooltalk": {
		source: "apache",
		extensions: [
			"ice"
		]
	},
		"x-shader/x-fragment": {
		compressible: true
	},
		"x-shader/x-vertex": {
		compressible: true
	}
	};

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015-2022 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	/**
	 * Module exports.
	 */

	var mimeDb = require$$0$1;

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	function resolve() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : '/';

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	}
	// path.normalize(path)
	// posix version
	function normalize(path) {
	  var isPathAbsolute = isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isPathAbsolute).join('/');

	  if (!path && !isPathAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isPathAbsolute ? '/' : '') + path;
	}
	// posix version
	function isAbsolute(path) {
	  return path.charAt(0) === '/';
	}

	// posix version
	function join() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	}


	// path.relative(from, to)
	// posix version
	function relative(from, to) {
	  from = resolve(from).substr(1);
	  to = resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	}

	var sep = '/';
	var delimiter = ':';

	function dirname(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	}

	function basename(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	}


	function extname(path) {
	  return splitPath(path)[3];
	}
	var _polyfillNode_path = {
	  extname: extname,
	  basename: basename,
	  dirname: dirname,
	  sep: sep,
	  delimiter: delimiter,
	  relative: relative,
	  join: join,
	  isAbsolute: isAbsolute,
	  normalize: normalize,
	  resolve: resolve
	};
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ?
	    function (str, start, len) { return str.substr(start, len) } :
	    function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		resolve: resolve,
		normalize: normalize,
		isAbsolute: isAbsolute,
		join: join,
		relative: relative,
		sep: sep,
		delimiter: delimiter,
		dirname: dirname,
		basename: basename,
		extname: extname,
		'default': _polyfillNode_path
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	var mimeTypes = createCommonjsModule(function (module, exports) {
	  /**
	   * Module dependencies.
	   * @private
	   */

	  var extname = require$$0.extname;
	  /**
	   * Module variables.
	   * @private
	   */

	  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	  var TEXT_TYPE_REGEXP = /^text\//i;
	  /**
	   * Module exports.
	   * @public
	   */

	  exports.charset = charset;
	  exports.charsets = {
	    lookup: charset
	  };
	  exports.contentType = contentType;
	  exports.extension = extension;
	  exports.extensions = Object.create(null);
	  exports.lookup = lookup;
	  exports.types = Object.create(null); // Populate the extensions/types maps

	  populateMaps(exports.extensions, exports.types);
	  /**
	   * Get the default charset for a MIME type.
	   *
	   * @param {string} type
	   * @return {boolean|string}
	   */

	  function charset(type) {
	    if (!type || typeof type !== 'string') {
	      return false;
	    } // TODO: use media-typer


	    var match = EXTRACT_TYPE_REGEXP.exec(type);
	    var mime = match && mimeDb[match[1].toLowerCase()];

	    if (mime && mime.charset) {
	      return mime.charset;
	    } // default text/* to utf-8


	    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
	      return 'UTF-8';
	    }

	    return false;
	  }
	  /**
	   * Create a full Content-Type header given a MIME type or extension.
	   *
	   * @param {string} str
	   * @return {boolean|string}
	   */


	  function contentType(str) {
	    // TODO: should this even be in this module?
	    if (!str || typeof str !== 'string') {
	      return false;
	    }

	    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

	    if (!mime) {
	      return false;
	    } // TODO: use content-type or other module


	    if (mime.indexOf('charset') === -1) {
	      var charset = exports.charset(mime);
	      if (charset) mime += '; charset=' + charset.toLowerCase();
	    }

	    return mime;
	  }
	  /**
	   * Get the default extension for a MIME type.
	   *
	   * @param {string} type
	   * @return {boolean|string}
	   */


	  function extension(type) {
	    if (!type || typeof type !== 'string') {
	      return false;
	    } // TODO: use media-typer


	    var match = EXTRACT_TYPE_REGEXP.exec(type); // get extensions

	    var exts = match && exports.extensions[match[1].toLowerCase()];

	    if (!exts || !exts.length) {
	      return false;
	    }

	    return exts[0];
	  }
	  /**
	   * Lookup the MIME type for a file path/extension.
	   *
	   * @param {string} path
	   * @return {boolean|string}
	   */


	  function lookup(path) {
	    if (!path || typeof path !== 'string') {
	      return false;
	    } // get the extension ("ext" or ".ext" or full path)


	    var extension = extname('x.' + path).toLowerCase().substr(1);

	    if (!extension) {
	      return false;
	    }

	    return exports.types[extension] || false;
	  }
	  /**
	   * Populate the extensions and types maps.
	   * @private
	   */


	  function populateMaps(extensions, types) {
	    // source preference (least -> most)
	    var preference = ['nginx', 'apache', undefined, 'iana'];
	    Object.keys(mimeDb).forEach(function forEachMimeType(type) {
	      var mime = mimeDb[type];
	      var exts = mime.extensions;

	      if (!exts || !exts.length) {
	        return;
	      } // mime -> extensions


	      extensions[type] = exts; // extension -> mime

	      for (var i = 0; i < exts.length; i++) {
	        var extension = exts[i];

	        if (types[extension]) {
	          var from = preference.indexOf(mimeDb[types[extension]].source);
	          var to = preference.indexOf(mime.source);

	          if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
	            // skip the remapping
	            continue;
	          }
	        } // set the extension -> mime


	        types[extension] = type;
	      }
	    });
	  }
	});

	var Mime = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({
		__proto__: null,
		'default': mimeTypes
	}, [mimeTypes]));

	function openFile(_x, _x2) {
	  return _openFile.apply(this, arguments);
	} // https://github.com/gram-js/gramjs/issues/223


	function _openFile() {
	  _openFile = _asyncToGenerator(function* (fileId, message) {
	    var blob = yield getCachedMedia(fileId, message);
	    var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;

	    if (navigator.b2g) {
	      return new Promise((resolve, reject) => {
	        var activity = new WebActivity("open", {
	          blob: blob,
	          type: mime
	        });
	        activity.start().then(() => {
	          resolve(null);
	        }).catch(err => {
	          reject(err.toString());
	        });
	      });
	    } else {
	      return new Promise((resolve, reject) => {
	        var activity = new MozActivity({
	          name: "open",
	          data: {
	            blob: blob,
	            type: mime
	          }
	        });

	        activity.onsuccess = () => {
	          resolve(null);
	        };

	        activity.onerror = err => {
	          reject(err.target.error.name);
	        };
	      });
	    }
	  });
	  return _openFile.apply(this, arguments);
	}

	function strippedPhotoToJpg(stripped) {
	  var JPEG_HEADER = buffer.Buffer.from('ffd8ffe000104a46494600010100000100010000ffdb004300281c1e231e1928' + '2321232d2b28303c64413c37373c7b585d4964918099968f808c8aa0b4e6c3a0aad' + 'aad8a8cc8ffcbdaeef5ffffff9bc1fffffffaffe6fdfff8ffdb0043012b2d2d3c35' + '3c76414176f8a58ca5f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f' + '8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8ffc0001108000000' + '0003012200021101031101ffc4001f0000010501010101010100000000000000000' + '102030405060708090a0bffc400b5100002010303020403050504040000017d0102' + '0300041105122131410613516107227114328191a1082342b1c11552d1f02433627' + '282090a161718191a25262728292a3435363738393a434445464748494a53545556' + '5758595a636465666768696a737475767778797a838485868788898a92939495969' + '798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4' + 'd5d6d7d8d9dae1e2e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8f9faffc4001f0100030' + '101010101010101010000000000000102030405060708090a0bffc400b511000201' + '0204040304070504040001027700010203110405213106124151076171132232810' + '8144291a1b1c109233352f0156272d10a162434e125f11718191a262728292a3536' + '3738393a434445464748494a535455565758595a636465666768696a73747576777' + '8797a82838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5' + 'b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae2e3e4e5e6e7e8e9eaf2f' + '3f4f5f6f7f8f9faffda000c03010002110311003f00', 'hex');
	  var JPEG_FOOTER = buffer.Buffer.from('ffd9', 'hex');

	  if (stripped.length < 3 || stripped[0] !== 1) {
	    return stripped;
	  }

	  var result = buffer.Buffer.concat([JPEG_HEADER, stripped.slice(3), JPEG_FOOTER]);
	  result[164] = stripped[1];
	  result[166] = stripped[2];
	  return result;
	}

	function humanFileSize(bytes) {
	  var si = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var dp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  var thresh = si ? 1000 : 1024;

	  if (Math.abs(bytes) < thresh) {
	    return bytes + ' Byte';
	  }

	  var units = si ? ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'] : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
	  var u = -1;
	  var r = Math.pow(10, dp);

	  do {
	    bytes /= thresh;
	    ++u;
	  } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);

	  return bytes.toFixed(dp) + ' ' + units[u];
	}

	function isMediaCached(_x3) {
	  return _isMediaCached.apply(this, arguments);
	}

	function _isMediaCached() {
	  _isMediaCached = _asyncToGenerator(function* (fileId) {
	    var keys = yield (yield cachedDatabase).getAllKeys('mediaAttachments');
	    return Promise.resolve(keys.indexOf(fileId) > -1);
	  });
	  return _isMediaCached.apply(this, arguments);
	}

	function getCachedMedia(_x4, _x5) {
	  return _getCachedMedia.apply(this, arguments);
	}

	function _getCachedMedia() {
	  _getCachedMedia = _asyncToGenerator(function* (fileId, message) {
	    return new Promise( /*#__PURE__*/function () {
	      var _ref = _asyncToGenerator(function* (resolve, reject) {
	        var bytes = yield (yield cachedDatabase).get('mediaAttachments', fileId);

	        if (bytes) {
	          var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;
	          resolve(new Blob([bytes], {
	            type: mime
	          })); // URL.revokeObjectURL()
	          // URL.createObjectURL()
	        } else {
	          reject(null);
	        }
	      });

	      return function (_x7, _x8) {
	        return _ref.apply(this, arguments);
	      };
	    }());
	  });
	  return _getCachedMedia.apply(this, arguments);
	}

	function getDocumentName(message) {
	  try {
	    var filename = null;

	    if (message.media.document) {
	      for (var j in message.media.document.attributes) {
	        var a = message.media.document.attributes[j];

	        if (a.className && a.className === "DocumentAttributeFilename") {
	          filename = a.fileName;
	          break;
	        }
	      }
	    }

	    if (filename) return filename;
	  } catch (err) {}

	  var strings = message.media.document.mimeType.split('/');
	  strings = strings[strings.length - 1];
	  return strings.charAt(0).toUpperCase() + strings.slice(1);
	}

	function removeCachedMedia(_x6) {
	  return _removeCachedMedia.apply(this, arguments);
	}

	function _removeCachedMedia() {
	  _removeCachedMedia = _asyncToGenerator(function* (fileId) {
	    return yield (yield cachedDatabase).delete('mediaAttachments', fileId);
	  });
	  return _removeCachedMedia.apply(this, arguments);
	}

	var console_1$a = globals.console;
	var file$T = "src/widgets/message/media/MessageMediaDocument/Audio.svelte"; // (168:9) {#if downloading > -1}

	function create_if_block_1$6(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*downloading*/
	      ctx[3]);
	      t1 = text("%");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*downloading*/
	      8) set_data_dev(t0,
	      /*downloading*/
	      ctx[3]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$6.name,
	    type: "if",
	    source: "(168:9) {#if downloading > -1}",
	    ctx
	  });
	  return block;
	} // (168:56) {#if !downloaded && downloading === -1}


	function create_if_block$a(ctx) {
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "download");
	      if (!src_url_equal(img.src, img_src_value = "/icons/download.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$T, 167, 95, 6809);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, img, anchor);
	      insert_dev(target, t, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(img);
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$a.name,
	    type: "if",
	    source: "(168:56) {#if !downloaded && downloading === -1}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$T(ctx) {
	  var div2;
	  var img;
	  var img_src_value;
	  var t0;
	  var small;
	  var div0;
	  var if_block0_anchor;
	  var t1_value = getDocumentName(
	  /*message*/
	  ctx[0]) + "";
	  var t1;
	  var t2;
	  var div1;
	  var t3;
	  var if_block0 =
	  /*downloading*/
	  ctx[3] > -1 && create_if_block_1$6(ctx);
	  var if_block1 = !
	  /*downloaded*/
	  ctx[2] &&
	  /*downloading*/
	  ctx[3] === -1 && create_if_block$a(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      img = element("img");
	      t0 = space();
	      small = element("small");
	      div0 = element("div");
	      if (if_block0) if_block0.c();
	      if_block0_anchor = empty();
	      if (if_block1) if_block1.c();
	      t1 = text(t1_value);
	      t2 = space();
	      div1 = element("div");
	      t3 = text(
	      /*size*/
	      ctx[1]);
	      attr_dev(img, "alt", "thumb");
	      if (!src_url_equal(img.src, img_src_value = "/icons/audio.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "class", "svelte-1lknwbb");
	      add_location(img, file$T, 165, 2, 6661);
	      add_location(div0, file$T, 167, 4, 6718);
	      add_location(div1, file$T, 168, 4, 6932);
	      attr_dev(small, "class", "svelte-1lknwbb");
	      add_location(small, file$T, 166, 2, 6706);
	      attr_dev(div2, "class", "media-container svelte-1lknwbb");
	      add_location(div2, file$T, 164, 0, 6629);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, img);
	      append_dev(div2, t0);
	      append_dev(div2, small);
	      append_dev(small, div0);
	      if (if_block0) if_block0.m(div0, null);
	      append_dev(div0, if_block0_anchor);
	      if (if_block1) if_block1.m(div0, null);
	      append_dev(div0, t1);
	      append_dev(small, t2);
	      append_dev(small, div1);
	      append_dev(div1, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*downloading*/
	      ctx[3] > -1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_1$6(ctx);
	          if_block0.c();
	          if_block0.m(div0, if_block0_anchor);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (!
	      /*downloaded*/
	      ctx[2] &&
	      /*downloading*/
	      ctx[3] === -1) {
	        if (if_block1) ; else {
	          if_block1 = create_if_block$a(ctx);
	          if_block1.c();
	          if_block1.m(div0, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value = getDocumentName(
	      /*message*/
	      ctx[0]) + "")) set_data_dev(t1, t1_value);
	      if (dirty &
	      /*size*/
	      2) set_data_dev(t3,
	      /*size*/
	      ctx[1]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$T.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function getFileType(string) {
	  var strings = string.split('/');
	  string = strings[strings.length - 1];
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

	function instance$T($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Audio', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var action;
	  var size;
	  var downloaded = false;
	  var fileId;
	  var downloading = -1;

	  function actionMenu() {
	    var menu = [];

	    if (downloaded) {
	      menu = [{
	        title: 'Open'
	      }, {
	        title: 'Save to Storage'
	      }, {
	        title: 'Remove from cache'
	      }];
	    } else {
	      menu = [{
	        title: 'Download'
	      }];
	    }

	    action = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Media Menu',
	        focusIndex: 0,
	        options: menu,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	          action.$destroy();

	          if (scope.selected.title === 'Open') {
	            try {
	              yield openFile(fileId, message);
	            } catch (err) {
	              console.log(err);
	            }
	          } else if (scope.selected.title === 'Download' && downloading === -1) {
	            if (window['authorizedWebWorker']) {
	              window['authorizedWebWorker'].postMessage({
	                type: 1,
	                params: {
	                  chatId: chat.id.value.toString(),
	                  messageId: message.id,
	                  fileId
	                }
	              });
	            }
	          } else if (scope.selected.title === 'Remove from cache') {
	            try {
	              yield removeCachedMedia(fileId);
	              $$invalidate(2, downloaded = false);
	              $$invalidate(3, downloading = -1);
	              downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	            } catch (err) {}
	          } else if (scope.selected.title === 'Save to Storage') {
	            try {
	              var blob = yield getCachedMedia(fileId, message);
	              var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;
	              var fn = null;

	              if (message.media.document) {
	                for (var j in message.media.document.attributes) {
	                  var a = message.media.document.attributes[j];

	                  if (a.className && a.className === "DocumentAttributeFilename") {
	                    fn = a.fileName;
	                    break;
	                  }
	                }
	              }

	              if (fn == null) {
	                fn = new Date().getTime().toString() + '.' + mimeTypes.extension(mime);
	              }

	              var _file = new File([blob], fn, {
	                type: mime
	              });

	              FileSaver_min.saveAs(_file);
	            } catch (err) {
	              console.log(err);
	            }
	          }
	        }),
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          action.$destroy();
	        },
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: scope => {
	          parentNavInstance.attachListener();
	          action = null;
	        }
	      }
	    });
	  }

	  function handleDownloadedMedia(evt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (evt.hash && evt.hash === fileId) {
	        if (evt.done != null) {
	          $$invalidate(2, downloaded = yield isMediaCached(fileId));
	          $$invalidate(3, downloading = -1);
	        } else if (evt.progress) {
	          $$invalidate(3, downloading = Math.round(evt.progress.received / evt.progress.total * 100));
	        } else if (evt.error) {
	          console.log(evt.error);
	          $$invalidate(3, downloading = -1);
	        } else if (evt.init) {
	          if (evt.init === 1) {
	            $$invalidate(3, downloading = 0);
	          } else {
	            $$invalidate(3, downloading = -1);
	          }
	        }
	      }
	    });
	  }

	  beforeUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
	    fileId = message.media.document.id.toString();
	    $$invalidate(2, downloaded = yield isMediaCached(fileId));
	    registerCallButtonHandler(message.id.toString(), actionMenu);

	    if (!downloaded) {
	      downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	    } else {
	      downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	    }

	    $$invalidate(1, size = humanFileSize(message.media.document.size.toJSNumber(), true));
	  }));
	  onMount(() => __awaiter(void 0, void 0, void 0, function* () {}));
	  onDestroy(() => {
	    downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$a.warn(`<Audio> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    saveAs: FileSaver_min.saveAs,
	    Mime,
	    openFile,
	    humanFileSize,
	    isMediaCached,
	    getCachedMedia,
	    removeCachedMedia,
	    getDocumentName,
	    downloadedMediaEmitter,
	    OptionMenu,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    action,
	    size,
	    downloaded,
	    fileId,
	    downloading,
	    actionMenu,
	    handleDownloadedMedia,
	    getFileType
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('action' in $$props) action = $$props.action;
	    if ('size' in $$props) $$invalidate(1, size = $$props.size);
	    if ('downloaded' in $$props) $$invalidate(2, downloaded = $$props.downloaded);
	    if ('fileId' in $$props) fileId = $$props.fileId;
	    if ('downloading' in $$props) $$invalidate(3, downloading = $$props.downloading);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, size, downloaded, downloading, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Audio extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$T, create_fragment$T, not_equal, {
	      chat: 4,
	      message: 0,
	      parentNavInstance: 5,
	      registerCallButtonHandler: 6,
	      refetchMessage: 7
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Audio",
	      options,
	      id: create_fragment$T.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[5] === undefined && !('parentNavInstance' in props)) {
	      console_1$a.warn("<Audio> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[4];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[5];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[6];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[7];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaDocument/Sticker.svelte generated by Svelte v3.46.4 */
	var file$S = "src/widgets/message/media/MessageMediaDocument/Sticker.svelte";

	function create_fragment$S(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: Sticker";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$S, 18, 2, 505);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$S, 17, 0, 473);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$S.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$9() {}

	function instance$S($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Sticker', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$9);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sticker> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$9
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Sticker extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$S, create_fragment$S, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Sticker",
	      options,
	      id: create_fragment$S.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<Sticker> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$9 = globals.console;
	var file$R = "src/widgets/message/media/MessageMediaDocument/Video.svelte"; // (175:9) {#if downloading > -1}

	function create_if_block_1$5(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*downloading*/
	      ctx[4]);
	      t1 = text("%");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*downloading*/
	      16) set_data_dev(t0,
	      /*downloading*/
	      ctx[4]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$5.name,
	    type: "if",
	    source: "(175:9) {#if downloading > -1}",
	    ctx
	  });
	  return block;
	} // (175:56) {#if !downloaded && downloading === -1}


	function create_if_block$9(ctx) {
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "download");
	      if (!src_url_equal(img.src, img_src_value = "/icons/download.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$R, 174, 95, 7056);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, img, anchor);
	      insert_dev(target, t, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(img);
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$9.name,
	    type: "if",
	    source: "(175:56) {#if !downloaded && downloading === -1}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$R(ctx) {
	  var div2;
	  var img;
	  var img_src_value;
	  var t0;
	  var small;
	  var div0;
	  var if_block0_anchor;
	  var t1_value = getDocumentName(
	  /*message*/
	  ctx[0]) + "";
	  var t1;
	  var t2;
	  var div1;
	  var t3;
	  var if_block0 =
	  /*downloading*/
	  ctx[4] > -1 && create_if_block_1$5(ctx);
	  var if_block1 = !
	  /*downloaded*/
	  ctx[3] &&
	  /*downloading*/
	  ctx[4] === -1 && create_if_block$9(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      img = element("img");
	      t0 = space();
	      small = element("small");
	      div0 = element("div");
	      if (if_block0) if_block0.c();
	      if_block0_anchor = empty();
	      if (if_block1) if_block1.c();
	      t1 = text(t1_value);
	      t2 = space();
	      div1 = element("div");
	      t3 = text(
	      /*size*/
	      ctx[2]);
	      attr_dev(img, "alt", "thumb");
	      if (!src_url_equal(img.src, img_src_value =
	      /*thumb*/
	      ctx[1])) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "class", "svelte-1lknwbb");
	      add_location(img, file$R, 172, 2, 6917);
	      add_location(div0, file$R, 174, 4, 6965);
	      add_location(div1, file$R, 175, 4, 7179);
	      attr_dev(small, "class", "svelte-1lknwbb");
	      add_location(small, file$R, 173, 2, 6953);
	      attr_dev(div2, "class", "media-container svelte-1lknwbb");
	      add_location(div2, file$R, 171, 0, 6885);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, img);
	      append_dev(div2, t0);
	      append_dev(div2, small);
	      append_dev(small, div0);
	      if (if_block0) if_block0.m(div0, null);
	      append_dev(div0, if_block0_anchor);
	      if (if_block1) if_block1.m(div0, null);
	      append_dev(div0, t1);
	      append_dev(small, t2);
	      append_dev(small, div1);
	      append_dev(div1, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*thumb*/
	      2 && !src_url_equal(img.src, img_src_value =
	      /*thumb*/
	      ctx[1])) {
	        attr_dev(img, "src", img_src_value);
	      }

	      if (
	      /*downloading*/
	      ctx[4] > -1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_1$5(ctx);
	          if_block0.c();
	          if_block0.m(div0, if_block0_anchor);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (!
	      /*downloaded*/
	      ctx[3] &&
	      /*downloading*/
	      ctx[4] === -1) {
	        if (if_block1) ; else {
	          if_block1 = create_if_block$9(ctx);
	          if_block1.c();
	          if_block1.m(div0, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value = getDocumentName(
	      /*message*/
	      ctx[0]) + "")) set_data_dev(t1, t1_value);
	      if (dirty &
	      /*size*/
	      4) set_data_dev(t3,
	      /*size*/
	      ctx[2]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$R.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$R($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Video', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var action;
	  var thumb = '/icons/document.svg';
	  var size;
	  var downloaded = false;
	  var fileId;
	  var downloading = -1;

	  function actionMenu() {
	    var menu = [];

	    if (downloaded) {
	      menu = [{
	        title: 'Open'
	      }, {
	        title: 'Save to Storage'
	      }, {
	        title: 'Remove from cache'
	      }];
	    } else {
	      menu = [{
	        title: 'Download'
	      }];
	    }

	    action = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Media Menu',
	        focusIndex: 0,
	        options: menu,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	          action.$destroy();

	          if (scope.selected.title === 'Open') {
	            try {
	              yield openFile(fileId, message);
	            } catch (err) {
	              console.log(err);
	            }
	          } else if (scope.selected.title === 'Download' && downloading === -1) {
	            if (window['authorizedWebWorker']) {
	              window['authorizedWebWorker'].postMessage({
	                type: 1,
	                params: {
	                  chatId: chat.id.value.toString(),
	                  messageId: message.id,
	                  fileId
	                }
	              });
	            }
	          } else if (scope.selected.title === 'Remove from cache') {
	            try {
	              yield removeCachedMedia(fileId);
	              $$invalidate(3, downloaded = false);
	              $$invalidate(4, downloading = -1);
	              downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	            } catch (err) {}
	          } else if (scope.selected.title === 'Save to Storage') {
	            try {
	              var blob = yield getCachedMedia(fileId, message);
	              var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;
	              var fn = null;

	              if (message.media.document) {
	                for (var j in message.media.document.attributes) {
	                  var a = message.media.document.attributes[j];

	                  if (a.className && a.className === "DocumentAttributeFilename") {
	                    fn = a.fileName;
	                    break;
	                  }
	                }
	              }

	              if (fn == null) {
	                fn = new Date().getTime().toString() + '.' + mimeTypes.extension(mime);
	              }

	              var _file = new File([blob], fn, {
	                type: mime
	              });

	              FileSaver_min.saveAs(_file);
	            } catch (err) {
	              console.log(err);
	            }
	          }
	        }),
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          action.$destroy();
	        },
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: scope => {
	          parentNavInstance.attachListener();
	          action = null;
	        }
	      }
	    });
	  }

	  function handleDownloadedMedia(evt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (evt.hash && evt.hash === fileId) {
	        if (evt.done != null) {
	          $$invalidate(3, downloaded = yield isMediaCached(fileId));
	          $$invalidate(4, downloading = -1);
	        } else if (evt.progress) {
	          $$invalidate(4, downloading = Math.round(evt.progress.received / evt.progress.total * 100));
	        } else if (evt.error) {
	          console.log(evt.error);
	          $$invalidate(4, downloading = -1);
	        } else if (evt.init) {
	          if (evt.init === 1) {
	            $$invalidate(4, downloading = 0);
	          } else {
	            $$invalidate(4, downloading = -1);
	          }
	        }
	      }
	    });
	  }

	  beforeUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
	    fileId = message.media.document.id.toString();
	    $$invalidate(3, downloaded = yield isMediaCached(fileId));
	    registerCallButtonHandler(message.id.toString(), actionMenu);

	    if (!downloaded) {
	      downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	    } else {
	      downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	    }

	    $$invalidate(2, size = humanFileSize(message.media.document.size.toJSNumber(), true));

	    try {
	      var arrBuff = strippedPhotoToJpg(buffer.Buffer.from(message.media.document.thumbs[0].originalArgs.bytes));
	      var reader = new FileReader();
	      reader.readAsDataURL(new Blob([arrBuff], {
	        type: 'image/jpeg'
	      }));

	      reader.onloadend = () => {
	        $$invalidate(1, thumb = reader.result);
	      };
	    } catch (err) {}
	  }));
	  onMount(() => __awaiter(void 0, void 0, void 0, function* () {}));
	  onDestroy(() => {
	    downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$9.warn(`<Video> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(5, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(6, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(7, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(8, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    Buffer: buffer.Buffer,
	    saveAs: FileSaver_min.saveAs,
	    Mime,
	    openFile,
	    strippedPhotoToJpg,
	    humanFileSize,
	    isMediaCached,
	    getCachedMedia,
	    removeCachedMedia,
	    getDocumentName,
	    downloadedMediaEmitter,
	    OptionMenu,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    action,
	    thumb,
	    size,
	    downloaded,
	    fileId,
	    downloading,
	    actionMenu,
	    handleDownloadedMedia
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(5, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(6, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(7, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(8, refetchMessage = $$props.refetchMessage);
	    if ('action' in $$props) action = $$props.action;
	    if ('thumb' in $$props) $$invalidate(1, thumb = $$props.thumb);
	    if ('size' in $$props) $$invalidate(2, size = $$props.size);
	    if ('downloaded' in $$props) $$invalidate(3, downloaded = $$props.downloaded);
	    if ('fileId' in $$props) fileId = $$props.fileId;
	    if ('downloading' in $$props) $$invalidate(4, downloading = $$props.downloading);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, thumb, size, downloaded, downloading, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Video extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$R, create_fragment$R, not_equal, {
	      chat: 5,
	      message: 0,
	      parentNavInstance: 6,
	      registerCallButtonHandler: 7,
	      refetchMessage: 8
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Video",
	      options,
	      id: create_fragment$R.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[6] === undefined && !('parentNavInstance' in props)) {
	      console_1$9.warn("<Video> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[5];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[6];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[7];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[8];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$8 = globals.console;
	var file$Q = "src/widgets/message/media/MessageMediaDocument/Doc.svelte"; // (164:9) {#if downloading > -1}

	function create_if_block_1$4(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*downloading*/
	      ctx[3]);
	      t1 = text("%");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*downloading*/
	      8) set_data_dev(t0,
	      /*downloading*/
	      ctx[3]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$4.name,
	    type: "if",
	    source: "(164:9) {#if downloading > -1}",
	    ctx
	  });
	  return block;
	} // (164:56) {#if !downloaded && downloading === -1}


	function create_if_block$8(ctx) {
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "download");
	      if (!src_url_equal(img.src, img_src_value = "/icons/download.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$Q, 163, 95, 6637);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, img, anchor);
	      insert_dev(target, t, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(img);
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$8.name,
	    type: "if",
	    source: "(164:56) {#if !downloaded && downloading === -1}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$Q(ctx) {
	  var div2;
	  var img;
	  var img_src_value;
	  var t0;
	  var small;
	  var div0;
	  var if_block0_anchor;
	  var t1_value = getDocumentName(
	  /*message*/
	  ctx[0]) + "";
	  var t1;
	  var t2;
	  var div1;
	  var t3;
	  var if_block0 =
	  /*downloading*/
	  ctx[3] > -1 && create_if_block_1$4(ctx);
	  var if_block1 = !
	  /*downloaded*/
	  ctx[2] &&
	  /*downloading*/
	  ctx[3] === -1 && create_if_block$8(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      img = element("img");
	      t0 = space();
	      small = element("small");
	      div0 = element("div");
	      if (if_block0) if_block0.c();
	      if_block0_anchor = empty();
	      if (if_block1) if_block1.c();
	      t1 = text(t1_value);
	      t2 = space();
	      div1 = element("div");
	      t3 = text(
	      /*size*/
	      ctx[1]);
	      attr_dev(img, "alt", "thumb");
	      if (!src_url_equal(img.src, img_src_value = "/icons/document.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "class", "svelte-1lknwbb");
	      add_location(img, file$Q, 161, 2, 6486);
	      add_location(div0, file$Q, 163, 4, 6546);
	      add_location(div1, file$Q, 164, 4, 6760);
	      attr_dev(small, "class", "svelte-1lknwbb");
	      add_location(small, file$Q, 162, 2, 6534);
	      attr_dev(div2, "class", "media-container svelte-1lknwbb");
	      add_location(div2, file$Q, 160, 0, 6454);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, img);
	      append_dev(div2, t0);
	      append_dev(div2, small);
	      append_dev(small, div0);
	      if (if_block0) if_block0.m(div0, null);
	      append_dev(div0, if_block0_anchor);
	      if (if_block1) if_block1.m(div0, null);
	      append_dev(div0, t1);
	      append_dev(small, t2);
	      append_dev(small, div1);
	      append_dev(div1, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*downloading*/
	      ctx[3] > -1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_1$4(ctx);
	          if_block0.c();
	          if_block0.m(div0, if_block0_anchor);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (!
	      /*downloaded*/
	      ctx[2] &&
	      /*downloading*/
	      ctx[3] === -1) {
	        if (if_block1) ; else {
	          if_block1 = create_if_block$8(ctx);
	          if_block1.c();
	          if_block1.m(div0, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value = getDocumentName(
	      /*message*/
	      ctx[0]) + "")) set_data_dev(t1, t1_value);
	      if (dirty &
	      /*size*/
	      2) set_data_dev(t3,
	      /*size*/
	      ctx[1]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Q.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$Q($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Doc', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var action;
	  var size;
	  var downloaded = false;
	  var fileId;
	  var downloading = -1;

	  function actionMenu() {
	    var menu = [];

	    if (downloaded) {
	      menu = [{
	        title: 'Open'
	      }, {
	        title: 'Save to Storage'
	      }, {
	        title: 'Remove from cache'
	      }];
	    } else {
	      menu = [{
	        title: 'Download'
	      }];
	    }

	    action = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Media Menu',
	        focusIndex: 0,
	        options: menu,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	          action.$destroy();

	          if (scope.selected.title === 'Open') {
	            try {
	              yield openFile(fileId, message);
	            } catch (err) {
	              console.log(err);
	            }
	          } else if (scope.selected.title === 'Download' && downloading === -1) {
	            if (window['authorizedWebWorker']) {
	              window['authorizedWebWorker'].postMessage({
	                type: 1,
	                params: {
	                  chatId: chat.id.value.toString(),
	                  messageId: message.id,
	                  fileId
	                }
	              });
	            }
	          } else if (scope.selected.title === 'Remove from cache') {
	            try {
	              yield removeCachedMedia(fileId);
	              $$invalidate(2, downloaded = false);
	              $$invalidate(3, downloading = -1);
	              downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	            } catch (err) {}
	          } else if (scope.selected.title === 'Save to Storage') {
	            try {
	              var blob = yield getCachedMedia(fileId, message);
	              var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;
	              var fn = null;

	              if (message.media.document) {
	                for (var j in message.media.document.attributes) {
	                  var a = message.media.document.attributes[j];

	                  if (a.className && a.className === "DocumentAttributeFilename") {
	                    fn = a.fileName;
	                    break;
	                  }
	                }
	              }

	              if (fn == null) {
	                fn = new Date().getTime().toString() + '.' + mimeTypes.extension(mime);
	              }

	              var _file = new File([blob], fn, {
	                type: mime
	              });

	              FileSaver_min.saveAs(_file);
	            } catch (err) {
	              console.log(err);
	            }
	          }
	        }),
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          action.$destroy();
	        },
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: scope => {
	          parentNavInstance.attachListener();
	          action = null;
	        }
	      }
	    });
	  }

	  function handleDownloadedMedia(evt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (evt.hash && evt.hash === fileId) {
	        if (evt.done != null) {
	          $$invalidate(2, downloaded = yield isMediaCached(fileId));
	          $$invalidate(3, downloading = -1);
	        } else if (evt.progress) {
	          $$invalidate(3, downloading = Math.round(evt.progress.received / evt.progress.total * 100));
	        } else if (evt.error) {
	          console.log(evt.error);
	          $$invalidate(3, downloading = -1);
	        } else if (evt.init) {
	          if (evt.init === 1) {
	            $$invalidate(3, downloading = 0);
	          } else {
	            $$invalidate(3, downloading = -1);
	          }
	        }
	      }
	    });
	  }

	  beforeUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
	    fileId = message.media.document.id.toString();
	    $$invalidate(2, downloaded = yield isMediaCached(fileId));
	    registerCallButtonHandler(message.id.toString(), actionMenu);

	    if (!downloaded) {
	      downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	    } else {
	      downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	    }

	    $$invalidate(1, size = humanFileSize(message.media.document.size.toJSNumber(), true));
	  }));
	  onMount(() => __awaiter(void 0, void 0, void 0, function* () {}));
	  onDestroy(() => {
	    downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$8.warn(`<Doc> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    saveAs: FileSaver_min.saveAs,
	    Mime,
	    openFile,
	    humanFileSize,
	    isMediaCached,
	    getCachedMedia,
	    removeCachedMedia,
	    getDocumentName,
	    downloadedMediaEmitter,
	    OptionMenu,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    action,
	    size,
	    downloaded,
	    fileId,
	    downloading,
	    actionMenu,
	    handleDownloadedMedia
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('action' in $$props) action = $$props.action;
	    if ('size' in $$props) $$invalidate(1, size = $$props.size);
	    if ('downloaded' in $$props) $$invalidate(2, downloaded = $$props.downloaded);
	    if ('fileId' in $$props) fileId = $$props.fileId;
	    if ('downloading' in $$props) $$invalidate(3, downloading = $$props.downloading);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, size, downloaded, downloading, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Doc extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Q, create_fragment$Q, not_equal, {
	      chat: 4,
	      message: 0,
	      parentNavInstance: 5,
	      registerCallButtonHandler: 6,
	      refetchMessage: 7
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Doc",
	      options,
	      id: create_fragment$Q.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[5] === undefined && !('parentNavInstance' in props)) {
	      console_1$8.warn("<Doc> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[4];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[5];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[6];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[7];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Audio: Audio,
		Sticker: Sticker,
		Video: Video,
		Doc: Doc
	});

	/* src/widgets/message/media/MessageMediaGeoLive.svelte generated by Svelte v3.46.4 */
	var file$P = "src/widgets/message/media/MessageMediaGeoLive.svelte";

	function create_fragment$P(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: GeoLive";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$P, 16, 2, 501);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$P, 15, 0, 469);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$P.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$8() {}

	function instance$P($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaGeoLive', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$8);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaGeoLive> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$8
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaGeoLive extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$P, create_fragment$P, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaGeoLive",
	      options,
	      id: create_fragment$P.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaGeoLive> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$O = "src/widgets/message/media/MessageMediaEmpty.svelte";

	function create_fragment$O(ctx) {
	  var div;
	  var span;
	  var t_value =
	  /*message*/
	  ctx[0].media.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      t = text(t_value);
	      set_style(span, "color", "#A20000");
	      add_location(span, file$O, 16, 2, 469);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$O, 15, 0, 437);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	      append_dev(span, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].media.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$O.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$7() {}

	function instance$O($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaEmpty', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$7);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaEmpty> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$7
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaEmpty extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$O, create_fragment$O, not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaEmpty",
	      options,
	      id: create_fragment$O.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaEmpty> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$7 = globals.console;
	var file$N = "src/widgets/message/media/MessageMediaPhoto.svelte"; // (190:9) {#if downloading > -1}

	function create_if_block_1$3(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*downloading*/
	      ctx[3]);
	      t1 = text("%");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*downloading*/
	      8) set_data_dev(t0,
	      /*downloading*/
	      ctx[3]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$3.name,
	    type: "if",
	    source: "(190:9) {#if downloading > -1}",
	    ctx
	  });
	  return block;
	} // (190:56) {#if !downloaded && downloading === -1}


	function create_if_block$7(ctx) {
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "download");
	      if (!src_url_equal(img.src, img_src_value = "/icons/download.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$N, 189, 95, 7668);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, img, anchor);
	      insert_dev(target, t, anchor);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(img);
	      if (detaching) detach_dev(t);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$7.name,
	    type: "if",
	    source: "(190:56) {#if !downloaded && downloading === -1}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$N(ctx) {
	  var div2;
	  var img;
	  var img_src_value;
	  var t0;
	  var small;
	  var div0;
	  var if_block0_anchor;
	  var t1;
	  var t2;
	  var div1;
	  var t3;
	  var if_block0 =
	  /*downloading*/
	  ctx[3] > -1 && create_if_block_1$3(ctx);
	  var if_block1 = !
	  /*downloaded*/
	  ctx[2] &&
	  /*downloading*/
	  ctx[3] === -1 && create_if_block$7(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      img = element("img");
	      t0 = space();
	      small = element("small");
	      div0 = element("div");
	      if (if_block0) if_block0.c();
	      if_block0_anchor = empty();
	      if (if_block1) if_block1.c();
	      t1 = text("Photo");
	      t2 = space();
	      div1 = element("div");
	      t3 = text(
	      /*size*/
	      ctx[1]);
	      attr_dev(img, "alt", "thumb");
	      if (!src_url_equal(img.src, img_src_value =
	      /*thumb*/
	      ctx[0])) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "class", "svelte-49hv9n");
	      add_location(img, file$N, 187, 2, 7529);
	      add_location(div0, file$N, 189, 4, 7577);
	      add_location(div1, file$N, 190, 4, 7770);
	      attr_dev(small, "class", "svelte-49hv9n");
	      add_location(small, file$N, 188, 2, 7565);
	      attr_dev(div2, "class", "media-container svelte-49hv9n");
	      add_location(div2, file$N, 186, 0, 7497);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, img);
	      append_dev(div2, t0);
	      append_dev(div2, small);
	      append_dev(small, div0);
	      if (if_block0) if_block0.m(div0, null);
	      append_dev(div0, if_block0_anchor);
	      if (if_block1) if_block1.m(div0, null);
	      append_dev(div0, t1);
	      append_dev(small, t2);
	      append_dev(small, div1);
	      append_dev(div1, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*thumb*/
	      1 && !src_url_equal(img.src, img_src_value =
	      /*thumb*/
	      ctx[0])) {
	        attr_dev(img, "src", img_src_value);
	      }

	      if (
	      /*downloading*/
	      ctx[3] > -1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_1$3(ctx);
	          if_block0.c();
	          if_block0.m(div0, if_block0_anchor);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (!
	      /*downloaded*/
	      ctx[2] &&
	      /*downloading*/
	      ctx[3] === -1) {
	        if (if_block1) ; else {
	          if_block1 = create_if_block$7(ctx);
	          if_block1.c();
	          if_block1.m(div0, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (dirty &
	      /*size*/
	      2) set_data_dev(t3,
	      /*size*/
	      ctx[1]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$N.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$N($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaPhoto', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var action;
	  var thumb = '/icons/document.svg';
	  var size;
	  var downloaded = false;
	  var fileId;
	  var downloading = -1;

	  function actionMenu() {
	    var menu = [];

	    if (downloaded) {
	      menu = [{
	        title: 'Open'
	      }, {
	        title: 'Save to Storage'
	      }, {
	        title: 'Remove from cache'
	      }];
	    } else {
	      menu = [{
	        title: 'Download'
	      }];
	    }

	    action = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Media Menu',
	        focusIndex: 0,
	        options: menu,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	          action.$destroy();

	          if (scope.selected.title === 'Open') {
	            try {
	              yield openFile(fileId, message);
	            } catch (err) {
	              console.log(err);
	            }
	          } else if (scope.selected.title === 'Download' && downloading === -1) {
	            if (window['authorizedWebWorker']) {
	              window['authorizedWebWorker'].postMessage({
	                type: 1,
	                params: {
	                  chatId: chat.id.value.toString(),
	                  messageId: message.id,
	                  fileId
	                }
	              });
	            }
	          } else if (scope.selected.title === 'Remove from cache') {
	            try {
	              yield removeCachedMedia(fileId);
	              $$invalidate(2, downloaded = false);
	              $$invalidate(3, downloading = -1);
	              downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	            } catch (err) {
	              console.log(err);
	            }
	          } else if (scope.selected.title === 'Save to Storage') {
	            try {
	              var blob = yield getCachedMedia(fileId, message);
	              var mime = message.media.photo ? 'image/jpeg' : message.media.document.mimeType;
	              var fn = null;

	              if (message.media.document) {
	                for (var j in message.media.document.attributes) {
	                  var a = message.media.document.attributes[j];

	                  if (a.className && a.className === "DocumentAttributeFilename") {
	                    fn = a.fileName;
	                    break;
	                  }
	                }
	              }

	              if (fn == null) {
	                fn = new Date().getTime().toString() + '.' + mimeTypes.extension(mime);
	              }

	              var _file = new File([blob], fn, {
	                type: mime
	              });

	              FileSaver_min.saveAs(_file);
	            } catch (err) {
	              console.log(err);
	            }
	          }
	        }),
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          action.$destroy();
	        },
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: scope => {
	          parentNavInstance.attachListener();
	          action = null;
	        }
	      }
	    });
	  }

	  function handleDownloadedMedia(evt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (evt.hash && evt.hash === fileId) {
	        if (evt.done != null) {
	          $$invalidate(2, downloaded = yield isMediaCached(fileId));
	          $$invalidate(3, downloading = -1);
	        } else if (evt.progress) {
	          $$invalidate(3, downloading = Math.round(evt.progress.received / evt.progress.total * 100));
	        } else if (evt.error) {
	          console.log(evt.error);
	          $$invalidate(3, downloading = -1);
	        } else if (evt.init) {
	          if (evt.init === 1) {
	            $$invalidate(3, downloading = 0);
	          } else {
	            $$invalidate(3, downloading = -1);
	          }
	        }
	      }
	    });
	  }

	  beforeUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
	    if (message.media.photo) {
	      fileId = message.media.photo.id.toString();
	    } else if (message.media.document) {
	      fileId = message.media.document.id.toString();
	    }

	    $$invalidate(2, downloaded = yield isMediaCached(fileId));
	    registerCallButtonHandler(message.id.toString(), actionMenu);

	    if (!downloaded) {
	      downloadedMediaEmitter.addListener('message', handleDownloadedMedia);
	    } else {
	      downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	    }

	    var byte;

	    if (message.media.className === 'MessageMediaPhoto') {
	      byte = message.media.photo.sizes[0].originalArgs.bytes;
	      var i = message.media.photo.sizes[message.media.photo.sizes.length - 1];
	      $$invalidate(1, size = humanFileSize(i.size ? i.size : i.sizes[i.sizes.length - 1], true));
	    } else if (message.media.className === 'MessageMediaDocument') {
	      byte = message.media.document.thumbs[0].originalArgs.bytes;
	      $$invalidate(1, size = humanFileSize(message.media.document.size.toJSNumber(), true));
	    }

	    try {
	      var arrBuff = strippedPhotoToJpg(buffer.Buffer.from(byte));
	      var reader = new FileReader();
	      reader.readAsDataURL(new Blob([arrBuff], {
	        type: 'image/jpeg'
	      }));

	      reader.onloadend = () => {
	        $$invalidate(0, thumb = reader.result);
	      };
	    } catch (err) {}
	  }));
	  onMount(() => __awaiter(void 0, void 0, void 0, function* () {}));
	  onDestroy(() => {
	    downloadedMediaEmitter.removeListener('message', handleDownloadedMedia);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$7.warn(`<MessageMediaPhoto> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(5, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(6, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(7, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(8, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    Buffer: buffer.Buffer,
	    saveAs: FileSaver_min.saveAs,
	    Mime,
	    openFile,
	    strippedPhotoToJpg,
	    humanFileSize,
	    isMediaCached,
	    getCachedMedia,
	    removeCachedMedia,
	    downloadedMediaEmitter,
	    OptionMenu,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    action,
	    thumb,
	    size,
	    downloaded,
	    fileId,
	    downloading,
	    actionMenu,
	    handleDownloadedMedia
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(4, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(5, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(6, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(7, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(8, refetchMessage = $$props.refetchMessage);
	    if ('action' in $$props) action = $$props.action;
	    if ('thumb' in $$props) $$invalidate(0, thumb = $$props.thumb);
	    if ('size' in $$props) $$invalidate(1, size = $$props.size);
	    if ('downloaded' in $$props) $$invalidate(2, downloaded = $$props.downloaded);
	    if ('fileId' in $$props) fileId = $$props.fileId;
	    if ('downloading' in $$props) $$invalidate(3, downloading = $$props.downloading);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [thumb, size, downloaded, downloading, chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaPhoto extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$N, create_fragment$N, not_equal, {
	      chat: 4,
	      message: 5,
	      parentNavInstance: 6,
	      registerCallButtonHandler: 7,
	      refetchMessage: 8
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaPhoto",
	      options,
	      id: create_fragment$N.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[6] === undefined && !('parentNavInstance' in props)) {
	      console_1$7.warn("<MessageMediaPhoto> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[4];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[5];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[6];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[7];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[8];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$M = "src/widgets/message/media/MessageMediaGeo.svelte";

	function create_fragment$M(ctx) {
	  var div1;
	  var div0;
	  var iframe;
	  var iframe_src_value;
	  var block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      iframe = element("iframe");
	      attr_dev(iframe, "width", "100%");
	      attr_dev(iframe, "height", "100");
	      attr_dev(iframe, "frameborder", "0");
	      attr_dev(iframe, "scrolling", "no");
	      attr_dev(iframe, "marginheight", "0");
	      attr_dev(iframe, "marginwidth", "0");
	      if (!src_url_equal(iframe.src, iframe_src_value =
	      /*url*/
	      ctx[0])) attr_dev(iframe, "src", iframe_src_value);
	      add_location(iframe, file$M, 83, 27, 3407);
	      set_style(div0, "width", "100%");
	      add_location(div0, file$M, 83, 2, 3382);
	      attr_dev(div1, "class", "media-container svelte-16i9emv");
	      add_location(div1, file$M, 82, 0, 3350);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      append_dev(div0, iframe);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*url*/
	      1 && !src_url_equal(iframe.src, iframe_src_value =
	      /*url*/
	      ctx[0])) {
	        attr_dev(iframe, "src", iframe_src_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$M.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function getCoordOffset($what, $lat, $lon, $offset) {
	  var $earthRadius = 6378137;
	  var $coord = [$lat, $lon];
	  var $radOff = $what === 0 ? $offset / $earthRadius : $offset / ($earthRadius * Math.cos(Math.PI * $coord[0] / 180));
	  return $coord[$what] + $radOff * 180 / Math.PI;
	}

	function getBBox($lat, $lon, $area) {
	  var $offset = $area / 2; // 0 = minlon, 1 = minlat, 2 = maxlon, 3 = maxlat, 4,5 = original val (marker)

	  return [getCoordOffset(1, $lat, $lon, -$offset), getCoordOffset(0, $lat, $lon, -$offset), getCoordOffset(1, $lat, $lon, $offset), getCoordOffset(0, $lat, $lon, $offset), $lat, $lon];
	}

	function getOpenStreetMapEmbed(lat, long) {
	  var result = getBBox(lat, long, 10);
	  return `https://www.openstreetmap.org/export/embed.html?bbox=${result[0]},${result[1]},${result[2]},${result[3]}&layer=mapnik&marker=${lat},${long}`;
	}

	function getGoogleMapEmbed(lat, long) {
	  return `https://maps.google.com/maps?width=100px;height=100px&hl=en&q=${lat},${long}+(Location)&t=&z=15&ie=UTF8&iwloc=B&output=embed`;
	}

	function instance$M($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaGeo', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var menu;
	  var url = '';

	  function actionMenu() {
	    setTimeout(() => {
	      menu = new OptionMenu({
	        target: document.body,
	        props: {
	          title: 'Action Menu',
	          focusIndex: 0,
	          options: [{
	            title: 'Open in Google Map'
	          }, {
	            title: 'Open in OpenStreetMap'
	          }],
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => {
	            menu.$destroy();

	            if (scope.selected.title === 'Open in Google Map') {
	              window.open(`https://www.google.com/maps/search/?api=1&query=${message.media.geo.lat},${message.media.geo.long}`, '_blank').focus();
	            } else if (scope.selected.title === 'Open in OpenStreetMap') {
	              var _url = getOpenStreetMapEmbed(message.media.geo.lat, message.media.geo.long);

	              window.open(_url, '_blank').focus();
	            }
	          },
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            menu.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: scope => {
	            parentNavInstance.attachListener();
	            menu = null;
	          }
	        }
	      });
	    }, 100);
	  }

	  beforeUpdate(() => {
	    $$invalidate(0, url = getGoogleMapEmbed(message.media.geo.lat, message.media.geo.long));
	  });
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaGeo> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    beforeUpdate,
	    OptionMenu,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    menu,
	    url,
	    getCoordOffset,
	    getBBox,
	    getOpenStreetMapEmbed,
	    getGoogleMapEmbed,
	    actionMenu
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	    if ('menu' in $$props) menu = $$props.menu;
	    if ('url' in $$props) $$invalidate(0, url = $$props.url);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [url, chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaGeo extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$M, create_fragment$M, not_equal, {
	      chat: 1,
	      message: 2,
	      parentNavInstance: 3,
	      registerCallButtonHandler: 4,
	      refetchMessage: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaGeo",
	      options,
	      id: create_fragment$M.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[3] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaGeo> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[3];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[4];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[5];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$6 = globals.console;
	var file$L = "src/widgets/message/media/MessageMediaPoll.svelte"; // (284:2) {:else}

	function create_else_block$2(ctx) {
	  var small;
	  var i;
	  var block = {
	    c: function create() {
	      small = element("small");
	      i = element("i");
	      i.textContent = "Status: Available";
	      add_location(i, file$L, 284, 9, 10353);
	      add_location(small, file$L, 284, 2, 10346);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, i);
	    },
	    p: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$2.name,
	    type: "else",
	    source: "(284:2) {:else}",
	    ctx
	  });
	  return block;
	} // (282:2) {#if !available}


	function create_if_block$6(ctx) {
	  var small;
	  var i;
	  var t0;
	  var t1_value = (
	  /*answeredOrVoted*/
	  ctx[2] ?
	  /*message*/
	  ctx[0].media.poll.quiz ? 'Answered' : 'Voted' : 'Ended') + "";
	  var t1;
	  var block = {
	    c: function create() {
	      small = element("small");
	      i = element("i");
	      t0 = text("Status: ");
	      t1 = text(t1_value);
	      add_location(i, file$L, 282, 9, 10232);
	      add_location(small, file$L, 282, 2, 10225);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, i);
	      append_dev(i, t0);
	      append_dev(i, t1);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*answeredOrVoted, message*/
	      5 && t1_value !== (t1_value = (
	      /*answeredOrVoted*/
	      ctx[2] ?
	      /*message*/
	      ctx[0].media.poll.quiz ? 'Answered' : 'Voted' : 'Ended') + "")) set_data_dev(t1, t1_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$6.name,
	    type: "if",
	    source: "(282:2) {#if !available}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$L(ctx) {
	  var div;
	  var b;
	  var t0_value = (
	  /*message*/
	  ctx[0].media.poll.quiz ? 'Quiz' : 'Poll') + "";
	  var t0;
	  var t1;
	  var t2;
	  var p;
	  var t3_value =
	  /*message*/
	  ctx[0].media.poll.question + "";
	  var t3;
	  var t4;

	  function select_block_type(ctx, dirty) {
	    if (!
	    /*available*/
	    ctx[1]) return create_if_block$6;
	    return create_else_block$2;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      b = element("b");
	      t0 = text(t0_value);
	      t1 = text(":");
	      t2 = space();
	      p = element("p");
	      t3 = text(t3_value);
	      t4 = space();
	      if_block.c();
	      add_location(b, file$L, 279, 2, 10113);
	      attr_dev(p, "class", "svelte-1x2nbdi");
	      add_location(p, file$L, 280, 2, 10167);
	      attr_dev(div, "class", "media-container svelte-1x2nbdi");
	      add_location(div, file$L, 278, 0, 10081);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, b);
	      append_dev(b, t0);
	      append_dev(b, t1);
	      append_dev(div, t2);
	      append_dev(div, p);
	      append_dev(p, t3);
	      append_dev(div, t4);
	      if_block.m(div, null);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value = (
	      /*message*/
	      ctx[0].media.poll.quiz ? 'Quiz' : 'Poll') + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t3_value !== (t3_value =
	      /*message*/
	      ctx[0].media.poll.question + "")) set_data_dev(t3, t3_value);

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(div, null);
	        }
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$L.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$L($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaPoll', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var available = true;
	  var answeredOrVoted = false;
	  var pollResults;
	  var singleSelector;
	  var multiSelector;
	  var menu;

	  function singleChoice() {
	    try {
	      var answers = [];
	      message.media.poll.answers.forEach(answer => {
	        answers.push({
	          title: answer.text
	        });
	      });
	      singleSelector = new SingleSelector({
	        target: document.body,
	        props: {
	          title: message.media.poll.quiz ? 'Submit answer' : 'Cast vote',
	          focusIndex: 0,
	          options: answers,
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	            singleSelector.$destroy();
	            var vote;

	            for (var i in scope.options) {
	              if (scope.options[i].selected) {
	                vote = message.media.poll.answers[i];
	                break;
	              }
	            }

	            if (vote) {
	              var result = yield client.invoke(new Api.messages.SendVote({
	                peer: chat,
	                msgId: message.id,
	                options: [vote.option]
	              }));
	              refetchMessage(message.id);
	            }
	          }),
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            singleSelector.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: scope => {
	            parentNavInstance.attachListener();
	            singleSelector = null;
	          }
	        }
	      });
	    } catch (err) {
	      console.log('singleChoice:', err);
	    }
	  }

	  function multipleChoice() {
	    try {
	      var answers = [];
	      message.media.poll.answers.forEach(answer => {
	        answers.push({
	          title: answer.text
	        });
	      });
	      multiSelector = new MultiSelector({
	        target: document.body,
	        props: {
	          title: 'Cast votes',
	          focusIndex: 0,
	          options: answers,
	          softKeyLeftText: 'Cancel',
	          softKeyRightText: 'Done',
	          softKeyCenterTextSelect: 'select',
	          softKeyCenterTextDeselect: 'deselect',
	          onSoftkeyLeft: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            multiSelector.$destroy();
	          },
	          onSoftkeyRight: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	            evt.preventDefault();
	            evt.stopPropagation();
	            multiSelector.$destroy();
	            var votes = [];
	            scope.options.forEach((o, i) => {
	              if (o.checked) {
	                votes.push(message.media.poll.answers[i]);
	              }
	            });

	            if (votes.length > 0) {
	              var options = votes.map(v => v.option);
	              var result = yield client.invoke(new Api.messages.SendVote({
	                peer: chat,
	                msgId: message.id,
	                options
	              }));
	              refetchMessage(message.id);
	            }
	          }),
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            multiSelector.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: scope => {
	            parentNavInstance.attachListener();
	            multiSelector = null;
	          }
	        }
	      });
	    } catch (err) {
	      console.log('multipleChoice:', err);
	    }
	  }

	  function retractVote() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var result = yield client.invoke(new Api.messages.SendVote({
	          peer: chat,
	          msgId: message.id,
	          options: []
	        }));
	        refetchMessage(message.id);
	      } catch (err) {
	        console.log('retractVote:', err);
	      }
	    });
	  }

	  function showResult() {
	    var results = [];

	    if (message.media.results.solution) {
	      results.push({
	        title: 'Explanation',
	        subtitle: message.media.results.solution
	      });
	    }

	    message.media.results.results.forEach((result, i) => {
	      results.push({
	        title: message.media.poll.answers[i].text,
	        subtitle: `Voters: ${result.voters}, Chosen: ${result.chosen ? '' : 'X'}${message.media.poll.quiz ? result.correct ? ', Correct: ' : ', Correct: X' : ''}${message.media.poll.quiz ? result.chosen && result.correct ? ', Result: ' : ', Result: X' : ''}`
	      });
	    });
	    pollResults = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Result',
	        focusIndex: 0,
	        options: results,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => {
	          pollResults.$destroy();
	        },
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          pollResults.$destroy();
	        },
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: scope => {
	          parentNavInstance.attachListener();
	          pollResults = null;
	        }
	      }
	    });
	  }

	  function actionMenu() {
	    var options = [];

	    if (available) {
	      if (message.media.poll.quiz || !message.media.poll.multipleChoice) {
	        if (message.media.poll.quiz) options.push({
	          title: 'Submit answer'
	        });else options.push({
	          title: 'Cast vote'
	        });
	      } else {
	        options.push({
	          title: 'Cast votes'
	        });
	      }
	    } else {
	      if (!message.media.poll.quiz) options.push({
	        title: 'Retract vote'
	      });
	      options.push({
	        title: 'Show Result'
	      });
	    }

	    setTimeout(() => {
	      menu = new OptionMenu({
	        target: document.body,
	        props: {
	          title: 'Action Menu',
	          focusIndex: 0,
	          options,
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => {
	            menu.$destroy();
	            setTimeout(() => {
	              if (['Submit answer', 'Cast vote'].indexOf(scope.selected.title) > -1) {
	                singleChoice();
	              } else if (scope.selected.title === 'Cast votes') {
	                multipleChoice();
	              } else if (scope.selected.title === 'Retract vote') {
	                retractVote();
	              } else if (scope.selected.title === 'Show Result') {
	                showResult();
	              }
	            }, 100);
	          },
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            menu.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: scope => {
	            parentNavInstance.attachListener();
	            menu = null;
	          }
	        }
	      });
	    }, 100);
	  }

	  function update() {
	    $$invalidate(1, available = true);
	    $$invalidate(2, answeredOrVoted = false);
	    if (message.media.poll.closed) $$invalidate(1, available = false);

	    for (var r in message.media.results.results) {
	      if (message.media.results.results[r].chosen) {
	        $$invalidate(1, available = false);
	        $$invalidate(2, answeredOrVoted = true);
	        break;
	      }
	    }
	  }

	  beforeUpdate(() => {
	    update();
	  });
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu);
	    update();
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<MessageMediaPoll> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(3, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(4, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(5, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(6, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    OptionMenu,
	    MultiSelector,
	    SingleSelector,
	    client,
	    Api,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    available,
	    answeredOrVoted,
	    pollResults,
	    singleSelector,
	    multiSelector,
	    menu,
	    singleChoice,
	    multipleChoice,
	    retractVote,
	    showResult,
	    actionMenu,
	    update
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(3, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(4, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(5, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(6, refetchMessage = $$props.refetchMessage);
	    if ('available' in $$props) $$invalidate(1, available = $$props.available);
	    if ('answeredOrVoted' in $$props) $$invalidate(2, answeredOrVoted = $$props.answeredOrVoted);
	    if ('pollResults' in $$props) pollResults = $$props.pollResults;
	    if ('singleSelector' in $$props) singleSelector = $$props.singleSelector;
	    if ('multiSelector' in $$props) multiSelector = $$props.multiSelector;
	    if ('menu' in $$props) menu = $$props.menu;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, available, answeredOrVoted, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaPoll extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$L, create_fragment$L, not_equal, {
	      chat: 3,
	      message: 0,
	      parentNavInstance: 4,
	      registerCallButtonHandler: 5,
	      refetchMessage: 6
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaPoll",
	      options,
	      id: create_fragment$L.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[4] === undefined && !('parentNavInstance' in props)) {
	      console_1$6.warn("<MessageMediaPoll> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[3];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[4];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[5];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[6];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaVenue.svelte generated by Svelte v3.46.4 */
	var file$K = "src/widgets/message/media/MessageMediaVenue.svelte";

	function create_fragment$K(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: Venue";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$K, 16, 2, 501);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$K, 15, 0, 469);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$K.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$6() {}

	function instance$K($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaVenue', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$6);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaVenue> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$6
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaVenue extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$K, create_fragment$K, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaVenue",
	      options,
	      id: create_fragment$K.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaVenue> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaGame.svelte generated by Svelte v3.46.4 */
	var file$J = "src/widgets/message/media/MessageMediaGame.svelte";

	function create_fragment$J(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported: Game";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$J, 17, 2, 502);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$J, 16, 0, 470);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$J.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$5() {}

	function instance$J($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaGame', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$5);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaGame> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$5
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaGame extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$J, create_fragment$J, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaGame",
	      options,
	      id: create_fragment$J.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaGame> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaInvoice.svelte generated by Svelte v3.46.4 */
	var file$I = "src/widgets/message/media/MessageMediaInvoice.svelte";

	function create_fragment$I(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: Invoice";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$I, 16, 2, 501);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$I, 15, 0, 469);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$I.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$4() {}

	function instance$I($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaInvoice', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$4);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaInvoice> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$4
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaInvoice extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$I, create_fragment$I, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaInvoice",
	      options,
	      id: create_fragment$I.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaInvoice> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaDice.svelte generated by Svelte v3.46.4 */
	var file$H = "src/widgets/message/media/MessageMediaDice.svelte";

	function create_fragment$H(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: Dice";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$H, 16, 2, 501);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$H, 15, 0, 469);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$H.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$3() {}

	function instance$H($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaDice', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$3);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaDice> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$3
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaDice extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$H, create_fragment$H, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaDice",
	      options,
	      id: create_fragment$H.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaDice> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/media/MessageMediaContact.svelte generated by Svelte v3.46.4 */
	var file$G = "src/widgets/message/media/MessageMediaContact.svelte";

	function create_fragment$G(ctx) {
	  var div;
	  var span;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      span.textContent = "Unsupported Media: Dice";
	      set_style(span, "color", "#A20000");
	      add_location(span, file$G, 16, 2, 501);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$G, 15, 0, 469);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$G.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$2() {}

	function instance$G($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaContact', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$2);
	  });
	  onDestroy(() => {});
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaContact> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$2
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaContact extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$G, create_fragment$G, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaContact",
	      options,
	      id: create_fragment$G.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaContact> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var Readability_1 = createCommonjsModule(function (module) {
	  /*
	   * Copyright (c) 2010 Arc90 Inc
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License");
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   */

	  /*
	   * This code is heavily based on Arc90's readability.js (1.7.1) script
	   * available at: http://code.google.com/p/arc90labs-readability
	   */

	  /**
	   * Public constructor.
	   * @param {HTMLDocument} doc     The document to parse.
	   * @param {Object}       options The options object.
	   */
	  function Readability(doc, options) {
	    // In some older versions, people passed a URI as the first argument. Cope:
	    if (options && options.documentElement) {
	      doc = options;
	      options = arguments[2];
	    } else if (!doc || !doc.documentElement) {
	      throw new Error("First argument to Readability constructor should be a document object.");
	    }

	    options = options || {};
	    this._doc = doc;
	    this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
	    this._articleTitle = null;
	    this._articleByline = null;
	    this._articleDir = null;
	    this._articleSiteName = null;
	    this._attempts = []; // Configurable options

	    this._debug = !!options.debug;
	    this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
	    this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
	    this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
	    this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
	    this._keepClasses = !!options.keepClasses;

	    this._serializer = options.serializer || function (el) {
	      return el.innerHTML;
	    };

	    this._disableJSONLD = !!options.disableJSONLD; // Start with all flags set

	    this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY; // Control whether log messages are sent to the console

	    if (this._debug) {
	      var logNode = function logNode(node) {
	        if (node.nodeType == node.TEXT_NODE) {
	          return `${node.nodeName} ("${node.textContent}")`;
	        }

	        var attrPairs = Array.from(node.attributes || [], function (attr) {
	          return `${attr.name}="${attr.value}"`;
	        }).join(" ");
	        return `<${node.localName} ${attrPairs}>`;
	      };

	      this.log = function () {
	        if (typeof dump !== "undefined") {
	          var msg = Array.prototype.map.call(arguments, function (x) {
	            return x && x.nodeName ? logNode(x) : x;
	          }).join(" ");
	          dump("Reader: (Readability) " + msg + "\n");
	        } else if (typeof console !== "undefined") {
	          var args = Array.from(arguments, arg => {
	            if (arg && arg.nodeType == this.ELEMENT_NODE) {
	              return logNode(arg);
	            }

	            return arg;
	          });
	          args.unshift("Reader: (Readability)");
	          console.log.apply(console, args);
	        }
	      };
	    } else {
	      this.log = function () {};
	    }
	  }

	  Readability.prototype = {
	    FLAG_STRIP_UNLIKELYS: 0x1,
	    FLAG_WEIGHT_CLASSES: 0x2,
	    FLAG_CLEAN_CONDITIONALLY: 0x4,
	    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
	    ELEMENT_NODE: 1,
	    TEXT_NODE: 3,
	    // Max number of nodes supported by this parser. Default: 0 (no limit)
	    DEFAULT_MAX_ELEMS_TO_PARSE: 0,
	    // The number of top candidates to consider when analysing how
	    // tight the competition is among candidates.
	    DEFAULT_N_TOP_CANDIDATES: 5,
	    // Element tags to score by default.
	    DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
	    // The default number of chars an article must have in order to return a result
	    DEFAULT_CHAR_THRESHOLD: 500,
	    // All of the regular expressions in use within readability.
	    // Defined up here so we don't instantiate them repeatedly in loops.
	    REGEXPS: {
	      // NOTE: These two regular expressions are duplicated in
	      // Readability-readerable.js. Please keep both copies in sync.
	      unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
	      okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
	      positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
	      negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
	      extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
	      byline: /byline|author|dateline|writtenby|p-author/i,
	      replaceFonts: /<(\/?)font[^>]*>/gi,
	      normalize: /\s{2,}/g,
	      videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
	      shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
	      nextLink: /(next|weiter|continue|>([^\|]|$)|([^\|]|$))/i,
	      prevLink: /(prev|earl|old|new|<|)/i,
	      tokenize: /\W+/g,
	      whitespace: /^\s*$/,
	      hasContent: /\S$/,
	      hashUrl: /^#.+/,
	      srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
	      b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
	      // See: https://schema.org/Article
	      jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
	    },
	    UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
	    DIV_TO_P_ELEMS: new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
	    ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
	    PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
	    DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
	    // The commented out elements qualify as phrasing content but tend to be
	    // removed by readability when put into paragraphs, so we ignore them here.
	    PHRASING_ELEMS: [// "CANVAS", "IFRAME", "SVG", "VIDEO",
	    "ABBR", "AUDIO", "B", "BDO", "BR", "BUTTON", "CITE", "CODE", "DATA", "DATALIST", "DFN", "EM", "EMBED", "I", "IMG", "INPUT", "KBD", "LABEL", "MARK", "MATH", "METER", "NOSCRIPT", "OBJECT", "OUTPUT", "PROGRESS", "Q", "RUBY", "SAMP", "SCRIPT", "SELECT", "SMALL", "SPAN", "STRONG", "SUB", "SUP", "TEXTAREA", "TIME", "VAR", "WBR"],
	    // These are the classes that readability sets itself.
	    CLASSES_TO_PRESERVE: ["page"],
	    // These are the list of HTML entities that need to be escaped.
	    HTML_ESCAPE_MAP: {
	      "lt": "<",
	      "gt": ">",
	      "amp": "&",
	      "quot": '"',
	      "apos": "'"
	    },

	    /**
	     * Run any post-process modifications to article content as necessary.
	     *
	     * @param Element
	     * @return void
	    **/
	    _postProcessContent: function _postProcessContent(articleContent) {
	      // Readability cannot open relative uris so we convert them to absolute uris.
	      this._fixRelativeUris(articleContent);

	      this._simplifyNestedElements(articleContent);

	      if (!this._keepClasses) {
	        // Remove classes.
	        this._cleanClasses(articleContent);
	      }
	    },

	    /**
	     * Iterates over a NodeList, calls `filterFn` for each node and removes node
	     * if function returned `true`.
	     *
	     * If function is not passed, removes all the nodes in node list.
	     *
	     * @param NodeList nodeList The nodes to operate on
	     * @param Function filterFn the function to use as a filter
	     * @return void
	     */
	    _removeNodes: function _removeNodes(nodeList, filterFn) {
	      // Avoid ever operating on live node lists.
	      if (this._docJSDOMParser && nodeList._isLiveNodeList) {
	        throw new Error("Do not pass live node lists to _removeNodes");
	      }

	      for (var i = nodeList.length - 1; i >= 0; i--) {
	        var node = nodeList[i];
	        var parentNode = node.parentNode;

	        if (parentNode) {
	          if (!filterFn || filterFn.call(this, node, i, nodeList)) {
	            parentNode.removeChild(node);
	          }
	        }
	      }
	    },

	    /**
	     * Iterates over a NodeList, and calls _setNodeTag for each node.
	     *
	     * @param NodeList nodeList The nodes to operate on
	     * @param String newTagName the new tag name to use
	     * @return void
	     */
	    _replaceNodeTags: function _replaceNodeTags(nodeList, newTagName) {
	      // Avoid ever operating on live node lists.
	      if (this._docJSDOMParser && nodeList._isLiveNodeList) {
	        throw new Error("Do not pass live node lists to _replaceNodeTags");
	      }

	      var _iterator = _createForOfIteratorHelper(nodeList),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var node = _step.value;

	          this._setNodeTag(node, newTagName);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    },

	    /**
	     * Iterate over a NodeList, which doesn't natively fully implement the Array
	     * interface.
	     *
	     * For convenience, the current object context is applied to the provided
	     * iterate function.
	     *
	     * @param  NodeList nodeList The NodeList.
	     * @param  Function fn       The iterate function.
	     * @return void
	     */
	    _forEachNode: function _forEachNode(nodeList, fn) {
	      Array.prototype.forEach.call(nodeList, fn, this);
	    },

	    /**
	     * Iterate over a NodeList, and return the first node that passes
	     * the supplied test function
	     *
	     * For convenience, the current object context is applied to the provided
	     * test function.
	     *
	     * @param  NodeList nodeList The NodeList.
	     * @param  Function fn       The test function.
	     * @return void
	     */
	    _findNode: function _findNode(nodeList, fn) {
	      return Array.prototype.find.call(nodeList, fn, this);
	    },

	    /**
	     * Iterate over a NodeList, return true if any of the provided iterate
	     * function calls returns true, false otherwise.
	     *
	     * For convenience, the current object context is applied to the
	     * provided iterate function.
	     *
	     * @param  NodeList nodeList The NodeList.
	     * @param  Function fn       The iterate function.
	     * @return Boolean
	     */
	    _someNode: function _someNode(nodeList, fn) {
	      return Array.prototype.some.call(nodeList, fn, this);
	    },

	    /**
	     * Iterate over a NodeList, return true if all of the provided iterate
	     * function calls return true, false otherwise.
	     *
	     * For convenience, the current object context is applied to the
	     * provided iterate function.
	     *
	     * @param  NodeList nodeList The NodeList.
	     * @param  Function fn       The iterate function.
	     * @return Boolean
	     */
	    _everyNode: function _everyNode(nodeList, fn) {
	      return Array.prototype.every.call(nodeList, fn, this);
	    },

	    /**
	     * Concat all nodelists passed as arguments.
	     *
	     * @return ...NodeList
	     * @return Array
	     */
	    _concatNodeLists: function _concatNodeLists() {
	      var slice = Array.prototype.slice;
	      var args = slice.call(arguments);
	      var nodeLists = args.map(function (list) {
	        return slice.call(list);
	      });
	      return Array.prototype.concat.apply([], nodeLists);
	    },
	    _getAllNodesWithTag: function _getAllNodesWithTag(node, tagNames) {
	      if (node.querySelectorAll) {
	        return node.querySelectorAll(tagNames.join(","));
	      }

	      return [].concat.apply([], tagNames.map(function (tag) {
	        var collection = node.getElementsByTagName(tag);
	        return Array.isArray(collection) ? collection : Array.from(collection);
	      }));
	    },

	    /**
	     * Removes the class="" attribute from every element in the given
	     * subtree, except those that match CLASSES_TO_PRESERVE and
	     * the classesToPreserve array from the options object.
	     *
	     * @param Element
	     * @return void
	     */
	    _cleanClasses: function _cleanClasses(node) {
	      var classesToPreserve = this._classesToPreserve;
	      var className = (node.getAttribute("class") || "").split(/\s+/).filter(function (cls) {
	        return classesToPreserve.indexOf(cls) != -1;
	      }).join(" ");

	      if (className) {
	        node.setAttribute("class", className);
	      } else {
	        node.removeAttribute("class");
	      }

	      for (node = node.firstElementChild; node; node = node.nextElementSibling) {
	        this._cleanClasses(node);
	      }
	    },

	    /**
	     * Converts each <a> and <img> uri in the given element to an absolute URI,
	     * ignoring #ref URIs.
	     *
	     * @param Element
	     * @return void
	     */
	    _fixRelativeUris: function _fixRelativeUris(articleContent) {
	      var baseURI = this._doc.baseURI;
	      var documentURI = this._doc.documentURI;

	      function toAbsoluteURI(uri) {
	        // Leave hash links alone if the base URI matches the document URI:
	        if (baseURI == documentURI && uri.charAt(0) == "#") {
	          return uri;
	        } // Otherwise, resolve against base URI:


	        try {
	          return new URL(uri, baseURI).href;
	        } catch (ex) {// Something went wrong, just return the original:
	        }

	        return uri;
	      }

	      var links = this._getAllNodesWithTag(articleContent, ["a"]);

	      this._forEachNode(links, function (link) {
	        var href = link.getAttribute("href");

	        if (href) {
	          // Remove links with javascript: URIs, since
	          // they won't work after scripts have been removed from the page.
	          if (href.indexOf("javascript:") === 0) {
	            // if the link only contains simple text content, it can be converted to a text node
	            if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
	              var text = this._doc.createTextNode(link.textContent);

	              link.parentNode.replaceChild(text, link);
	            } else {
	              // if the link has multiple children, they should all be preserved
	              var container = this._doc.createElement("span");

	              while (link.firstChild) {
	                container.appendChild(link.firstChild);
	              }

	              link.parentNode.replaceChild(container, link);
	            }
	          } else {
	            link.setAttribute("href", toAbsoluteURI(href));
	          }
	        }
	      });

	      var medias = this._getAllNodesWithTag(articleContent, ["img", "picture", "figure", "video", "audio", "source"]);

	      this._forEachNode(medias, function (media) {
	        var src = media.getAttribute("src");
	        var poster = media.getAttribute("poster");
	        var srcset = media.getAttribute("srcset");

	        if (src) {
	          media.setAttribute("src", toAbsoluteURI(src));
	        }

	        if (poster) {
	          media.setAttribute("poster", toAbsoluteURI(poster));
	        }

	        if (srcset) {
	          var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function (_, p1, p2, p3) {
	            return toAbsoluteURI(p1) + (p2 || "") + p3;
	          });
	          media.setAttribute("srcset", newSrcset);
	        }
	      });
	    },
	    _simplifyNestedElements: function _simplifyNestedElements(articleContent) {
	      var node = articleContent;

	      while (node) {
	        if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
	          if (this._isElementWithoutContent(node)) {
	            node = this._removeAndGetNext(node);
	            continue;
	          } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
	            var child = node.children[0];

	            for (var i = 0; i < node.attributes.length; i++) {
	              child.setAttribute(node.attributes[i].name, node.attributes[i].value);
	            }

	            node.parentNode.replaceChild(child, node);
	            node = child;
	            continue;
	          }
	        }

	        node = this._getNextNode(node);
	      }
	    },

	    /**
	     * Get the article title as an H1.
	     *
	     * @return string
	     **/
	    _getArticleTitle: function _getArticleTitle() {
	      var doc = this._doc;
	      var curTitle = "";
	      var origTitle = "";

	      try {
	        curTitle = origTitle = doc.title.trim(); // If they had an element with id "title" in their HTML

	        if (typeof curTitle !== "string") curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
	      } catch (e) {
	        /* ignore exceptions setting the title. */
	      }

	      var titleHadHierarchicalSeparators = false;

	      function wordCount(str) {
	        return str.split(/\s+/).length;
	      } // If there's a separator in the title, first remove the final part


	      if (/ [\|\-\\\/>] /.test(curTitle)) {
	        titleHadHierarchicalSeparators = / [\\\/>] /.test(curTitle);
	        curTitle = origTitle.replace(/(.*)[\|\-\\\/>] .*/gi, "$1"); // If the resulting title is too short (3 words or fewer), remove
	        // the first part instead:

	        if (wordCount(curTitle) < 3) curTitle = origTitle.replace(/[^\|\-\\\/>]*[\|\-\\\/>](.*)/gi, "$1");
	      } else if (curTitle.indexOf(": ") !== -1) {
	        // Check if we have an heading containing this exact string, so we
	        // could assume it's the full title.
	        var headings = this._concatNodeLists(doc.getElementsByTagName("h1"), doc.getElementsByTagName("h2"));

	        var trimmedTitle = curTitle.trim();

	        var match = this._someNode(headings, function (heading) {
	          return heading.textContent.trim() === trimmedTitle;
	        }); // If we don't, let's extract the title out of the original title string.


	        if (!match) {
	          curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1); // If the title is now too short, try the first colon instead:

	          if (wordCount(curTitle) < 3) {
	            curTitle = origTitle.substring(origTitle.indexOf(":") + 1); // But if we have too many words before the colon there's something weird
	            // with the titles and the H tags so let's just use the original title instead
	          } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
	            curTitle = origTitle;
	          }
	        }
	      } else if (curTitle.length > 150 || curTitle.length < 15) {
	        var hOnes = doc.getElementsByTagName("h1");
	        if (hOnes.length === 1) curTitle = this._getInnerText(hOnes[0]);
	      }

	      curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " "); // If we now have 4 words or fewer as our title, and either no
	      // 'hierarchical' separators (\, /, > or ) were found in the original
	      // title or we decreased the number of words by more than 1 word, use
	      // the original title.

	      var curTitleWordCount = wordCount(curTitle);

	      if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>]+/g, "")) - 1)) {
	        curTitle = origTitle;
	      }

	      return curTitle;
	    },

	    /**
	     * Prepare the HTML document for readability to scrape it.
	     * This includes things like stripping javascript, CSS, and handling terrible markup.
	     *
	     * @return void
	     **/
	    _prepDocument: function _prepDocument() {
	      var doc = this._doc; // Remove all style tags in head

	      this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));

	      if (doc.body) {
	        this._replaceBrs(doc.body);
	      }

	      this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
	    },

	    /**
	     * Finds the next node, starting from the given node, and ignoring
	     * whitespace in between. If the given node is an element, the same node is
	     * returned.
	     */
	    _nextNode: function _nextNode(node) {
	      var next = node;

	      while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
	        next = next.nextSibling;
	      }

	      return next;
	    },

	    /**
	     * Replaces 2 or more successive <br> elements with a single <p>.
	     * Whitespace between <br> elements are ignored. For example:
	     *   <div>foo<br>bar<br> <br><br>abc</div>
	     * will become:
	     *   <div>foo<br>bar<p>abc</p></div>
	     */
	    _replaceBrs: function _replaceBrs(elem) {
	      this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function (br) {
	        var next = br.nextSibling; // Whether 2 or more <br> elements have been found and replaced with a
	        // <p> block.

	        var replaced = false; // If we find a <br> chain, remove the <br>s until we hit another node
	        // or non-whitespace. This leaves behind the first <br> in the chain
	        // (which will be replaced with a <p> later).

	        while ((next = this._nextNode(next)) && next.tagName == "BR") {
	          replaced = true;
	          var brSibling = next.nextSibling;
	          next.parentNode.removeChild(next);
	          next = brSibling;
	        } // If we removed a <br> chain, replace the remaining <br> with a <p>. Add
	        // all sibling nodes as children of the <p> until we hit another <br>
	        // chain.


	        if (replaced) {
	          var p = this._doc.createElement("p");

	          br.parentNode.replaceChild(p, br);
	          next = p.nextSibling;

	          while (next) {
	            // If we've hit another <br><br>, we're done adding children to this <p>.
	            if (next.tagName == "BR") {
	              var nextElem = this._nextNode(next.nextSibling);

	              if (nextElem && nextElem.tagName == "BR") break;
	            }

	            if (!this._isPhrasingContent(next)) break; // Otherwise, make this node a child of the new <p>.

	            var sibling = next.nextSibling;
	            p.appendChild(next);
	            next = sibling;
	          }

	          while (p.lastChild && this._isWhitespace(p.lastChild)) {
	            p.removeChild(p.lastChild);
	          }

	          if (p.parentNode.tagName === "P") this._setNodeTag(p.parentNode, "DIV");
	        }
	      });
	    },
	    _setNodeTag: function _setNodeTag(node, tag) {
	      this.log("_setNodeTag", node, tag);

	      if (this._docJSDOMParser) {
	        node.localName = tag.toLowerCase();
	        node.tagName = tag.toUpperCase();
	        return node;
	      }

	      var replacement = node.ownerDocument.createElement(tag);

	      while (node.firstChild) {
	        replacement.appendChild(node.firstChild);
	      }

	      node.parentNode.replaceChild(replacement, node);
	      if (node.readability) replacement.readability = node.readability;

	      for (var i = 0; i < node.attributes.length; i++) {
	        try {
	          replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);
	        } catch (ex) {
	          /* it's possible for setAttribute() to throw if the attribute name
	           * isn't a valid XML Name. Such attributes can however be parsed from
	           * source in HTML docs, see https://github.com/whatwg/html/issues/4275,
	           * so we can hit them here and then throw. We don't care about such
	           * attributes so we ignore them.
	           */
	        }
	      }

	      return replacement;
	    },

	    /**
	     * Prepare the article node for display. Clean out any inline styles,
	     * iframes, forms, strip extraneous <p> tags, etc.
	     *
	     * @param Element
	     * @return void
	     **/
	    _prepArticle: function _prepArticle(articleContent) {
	      this._cleanStyles(articleContent); // Check for data tables before we continue, to avoid removing items in
	      // those tables, which will often be isolated even though they're
	      // visually linked to other content-ful elements (text, images, etc.).


	      this._markDataTables(articleContent);

	      this._fixLazyImages(articleContent); // Clean out junk from the article content


	      this._cleanConditionally(articleContent, "form");

	      this._cleanConditionally(articleContent, "fieldset");

	      this._clean(articleContent, "object");

	      this._clean(articleContent, "embed");

	      this._clean(articleContent, "footer");

	      this._clean(articleContent, "link");

	      this._clean(articleContent, "aside"); // Clean out elements with little content that have "share" in their id/class combinations from final top candidates,
	      // which means we don't remove the top candidates even they have "share".


	      var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;

	      this._forEachNode(articleContent.children, function (topCandidate) {
	        this._cleanMatchedNodes(topCandidate, function (node, matchString) {
	          return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
	        });
	      });

	      this._clean(articleContent, "iframe");

	      this._clean(articleContent, "input");

	      this._clean(articleContent, "textarea");

	      this._clean(articleContent, "select");

	      this._clean(articleContent, "button");

	      this._cleanHeaders(articleContent); // Do these last as the previous stuff may have removed junk
	      // that will affect these


	      this._cleanConditionally(articleContent, "table");

	      this._cleanConditionally(articleContent, "ul");

	      this._cleanConditionally(articleContent, "div"); // replace H1 with H2 as H1 should be only title that is displayed separately


	      this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2"); // Remove extra paragraphs


	      this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function (paragraph) {
	        var imgCount = paragraph.getElementsByTagName("img").length;
	        var embedCount = paragraph.getElementsByTagName("embed").length;
	        var objectCount = paragraph.getElementsByTagName("object").length; // At this point, nasty iframes have been removed, only remain embedded video ones.

	        var iframeCount = paragraph.getElementsByTagName("iframe").length;
	        var totalCount = imgCount + embedCount + objectCount + iframeCount;
	        return totalCount === 0 && !this._getInnerText(paragraph, false);
	      });

	      this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function (br) {
	        var next = this._nextNode(br.nextSibling);

	        if (next && next.tagName == "P") br.parentNode.removeChild(br);
	      }); // Remove single-cell tables


	      this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function (table) {
	        var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;

	        if (this._hasSingleTagInsideElement(tbody, "TR")) {
	          var row = tbody.firstElementChild;

	          if (this._hasSingleTagInsideElement(row, "TD")) {
	            var cell = row.firstElementChild;
	            cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
	            table.parentNode.replaceChild(cell, table);
	          }
	        }
	      });
	    },

	    /**
	     * Initialize a node with the readability object. Also checks the
	     * className/id for special names to add to its score.
	     *
	     * @param Element
	     * @return void
	    **/
	    _initializeNode: function _initializeNode(node) {
	      node.readability = {
	        "contentScore": 0
	      };

	      switch (node.tagName) {
	        case "DIV":
	          node.readability.contentScore += 5;
	          break;

	        case "PRE":
	        case "TD":
	        case "BLOCKQUOTE":
	          node.readability.contentScore += 3;
	          break;

	        case "ADDRESS":
	        case "OL":
	        case "UL":
	        case "DL":
	        case "DD":
	        case "DT":
	        case "LI":
	        case "FORM":
	          node.readability.contentScore -= 3;
	          break;

	        case "H1":
	        case "H2":
	        case "H3":
	        case "H4":
	        case "H5":
	        case "H6":
	        case "TH":
	          node.readability.contentScore -= 5;
	          break;
	      }

	      node.readability.contentScore += this._getClassWeight(node);
	    },
	    _removeAndGetNext: function _removeAndGetNext(node) {
	      var nextNode = this._getNextNode(node, true);

	      node.parentNode.removeChild(node);
	      return nextNode;
	    },

	    /**
	     * Traverse the DOM from node to node, starting at the node passed in.
	     * Pass true for the second parameter to indicate this node itself
	     * (and its kids) are going away, and we want the next node over.
	     *
	     * Calling this in a loop will traverse the DOM depth-first.
	     */
	    _getNextNode: function _getNextNode(node, ignoreSelfAndKids) {
	      // First check for kids if those aren't being ignored
	      if (!ignoreSelfAndKids && node.firstElementChild) {
	        return node.firstElementChild;
	      } // Then for siblings...


	      if (node.nextElementSibling) {
	        return node.nextElementSibling;
	      } // And finally, move up the parent chain *and* find a sibling
	      // (because this is depth-first traversal, we will have already
	      // seen the parent nodes themselves).


	      do {
	        node = node.parentNode;
	      } while (node && !node.nextElementSibling);

	      return node && node.nextElementSibling;
	    },
	    // compares second text to first one
	    // 1 = same text, 0 = completely different text
	    // works the way that it splits both texts into words and then finds words that are unique in second text
	    // the result is given by the lower length of unique parts
	    _textSimilarity: function _textSimilarity(textA, textB) {
	      var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
	      var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);

	      if (!tokensA.length || !tokensB.length) {
	        return 0;
	      }

	      var uniqTokensB = tokensB.filter(token => !tokensA.includes(token));
	      var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
	      return 1 - distanceB;
	    },
	    _checkByline: function _checkByline(node, matchString) {
	      if (this._articleByline) {
	        return false;
	      }

	      if (node.getAttribute !== undefined) {
	        var rel = node.getAttribute("rel");
	        var itemprop = node.getAttribute("itemprop");
	      }

	      if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
	        this._articleByline = node.textContent.trim();
	        return true;
	      }

	      return false;
	    },
	    _getNodeAncestors: function _getNodeAncestors(node, maxDepth) {
	      maxDepth = maxDepth || 0;
	      var i = 0,
	          ancestors = [];

	      while (node.parentNode) {
	        ancestors.push(node.parentNode);
	        if (maxDepth && ++i === maxDepth) break;
	        node = node.parentNode;
	      }

	      return ancestors;
	    },

	    /***
	     * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
	     *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
	     *
	     * @param page a document to run upon. Needs to be a full document, complete with body.
	     * @return Element
	    **/
	    _grabArticle: function _grabArticle(page) {
	      this.log("**** grabArticle ****");
	      var doc = this._doc;
	      var isPaging = page !== null;
	      page = page ? page : this._doc.body; // We can't grab an article if we don't have a page!

	      if (!page) {
	        this.log("No body found in document. Abort.");
	        return null;
	      }

	      var pageCacheHtml = page.innerHTML;

	      while (true) {
	        this.log("Starting grabArticle loop");

	        var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS); // First, node prepping. Trash nodes that look cruddy (like ones with the
	        // class name "comment", etc), and turn divs into P tags where they have been
	        // used inappropriately (as in, where they contain no other block level elements.)


	        var elementsToScore = [];
	        var node = this._doc.documentElement;
	        var shouldRemoveTitleHeader = true;

	        while (node) {
	          if (node.tagName === "HTML") {
	            this._articleLang = node.getAttribute("lang");
	          }

	          var matchString = node.className + " " + node.id;

	          if (!this._isProbablyVisible(node)) {
	            this.log("Removing hidden node - " + matchString);
	            node = this._removeAndGetNext(node);
	            continue;
	          } // Check to see if this node is a byline, and remove it if it is.


	          if (this._checkByline(node, matchString)) {
	            node = this._removeAndGetNext(node);
	            continue;
	          }

	          if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
	            this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
	            shouldRemoveTitleHeader = false;
	            node = this._removeAndGetNext(node);
	            continue;
	          } // Remove unlikely candidates


	          if (stripUnlikelyCandidates) {
	            if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
	              this.log("Removing unlikely candidate - " + matchString);
	              node = this._removeAndGetNext(node);
	              continue;
	            }

	            if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
	              this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
	              node = this._removeAndGetNext(node);
	              continue;
	            }
	          } // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).


	          if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
	            node = this._removeAndGetNext(node);
	            continue;
	          }

	          if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
	            elementsToScore.push(node);
	          } // Turn all divs that don't have children block level elements into p's


	          if (node.tagName === "DIV") {
	            // Put phrasing content into paragraphs.
	            var p = null;
	            var childNode = node.firstChild;

	            while (childNode) {
	              var nextSibling = childNode.nextSibling;

	              if (this._isPhrasingContent(childNode)) {
	                if (p !== null) {
	                  p.appendChild(childNode);
	                } else if (!this._isWhitespace(childNode)) {
	                  p = doc.createElement("p");
	                  node.replaceChild(p, childNode);
	                  p.appendChild(childNode);
	                }
	              } else if (p !== null) {
	                while (p.lastChild && this._isWhitespace(p.lastChild)) {
	                  p.removeChild(p.lastChild);
	                }

	                p = null;
	              }

	              childNode = nextSibling;
	            } // Sites like http://mobile.slate.com encloses each paragraph with a DIV
	            // element. DIVs with only a P element inside and no text content can be
	            // safely converted into plain P elements to avoid confusing the scoring
	            // algorithm with DIVs with are, in practice, paragraphs.


	            if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
	              var newNode = node.children[0];
	              node.parentNode.replaceChild(newNode, node);
	              node = newNode;
	              elementsToScore.push(node);
	            } else if (!this._hasChildBlockElement(node)) {
	              node = this._setNodeTag(node, "P");
	              elementsToScore.push(node);
	            }
	          }

	          node = this._getNextNode(node);
	        }
	        /**
	         * Loop through all paragraphs, and assign a score to them based on how content-y they look.
	         * Then add their score to their parent node.
	         *
	         * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.
	        **/


	        var candidates = [];

	        this._forEachNode(elementsToScore, function (elementToScore) {
	          if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined") return; // If this paragraph is less than 25 characters, don't even count it.

	          var innerText = this._getInnerText(elementToScore);

	          if (innerText.length < 25) return; // Exclude nodes with no ancestor.

	          var ancestors = this._getNodeAncestors(elementToScore, 5);

	          if (ancestors.length === 0) return;
	          var contentScore = 0; // Add a point for the paragraph itself as a base.

	          contentScore += 1; // Add points for any commas within this paragraph.

	          contentScore += innerText.split(",").length; // For every 100 characters in this paragraph, add another point. Up to 3 points.

	          contentScore += Math.min(Math.floor(innerText.length / 100), 3); // Initialize and score ancestors.

	          this._forEachNode(ancestors, function (ancestor, level) {
	            if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined") return;

	            if (typeof ancestor.readability === "undefined") {
	              this._initializeNode(ancestor);

	              candidates.push(ancestor);
	            } // Node score divider:
	            // - parent:             1 (no division)
	            // - grandparent:        2
	            // - great grandparent+: ancestor level * 3


	            if (level === 0) var scoreDivider = 1;else if (level === 1) scoreDivider = 2;else scoreDivider = level * 3;
	            ancestor.readability.contentScore += contentScore / scoreDivider;
	          });
	        }); // After we've calculated scores, loop through all of the possible
	        // candidate nodes we found and find the one with the highest score.


	        var topCandidates = [];

	        for (var c = 0, cl = candidates.length; c < cl; c += 1) {
	          var candidate = candidates[c]; // Scale the final candidates score based on link density. Good content
	          // should have a relatively small link density (5% or less) and be mostly
	          // unaffected by this operation.

	          var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));

	          candidate.readability.contentScore = candidateScore;
	          this.log("Candidate:", candidate, "with score " + candidateScore);

	          for (var t = 0; t < this._nbTopCandidates; t++) {
	            var aTopCandidate = topCandidates[t];

	            if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
	              topCandidates.splice(t, 0, candidate);
	              if (topCandidates.length > this._nbTopCandidates) topCandidates.pop();
	              break;
	            }
	          }
	        }

	        var topCandidate = topCandidates[0] || null;
	        var neededToCreateTopCandidate = false;
	        var parentOfTopCandidate; // If we still have no top candidate, just use the body as a last resort.
	        // We also have to copy the body node so it is something we can modify.

	        if (topCandidate === null || topCandidate.tagName === "BODY") {
	          // Move all of the page's children into topCandidate
	          topCandidate = doc.createElement("DIV");
	          neededToCreateTopCandidate = true; // Move everything (not just elements, also text nodes etc.) into the container
	          // so we even include text directly in the body:

	          while (page.firstChild) {
	            this.log("Moving child out:", page.firstChild);
	            topCandidate.appendChild(page.firstChild);
	          }

	          page.appendChild(topCandidate);

	          this._initializeNode(topCandidate);
	        } else if (topCandidate) {
	          // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array
	          // and whose scores are quite closed with current `topCandidate` node.
	          var alternativeCandidateAncestors = [];

	          for (var i = 1; i < topCandidates.length; i++) {
	            if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
	              alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));
	            }
	          }

	          var MINIMUM_TOPCANDIDATES = 3;

	          if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
	            parentOfTopCandidate = topCandidate.parentNode;

	            while (parentOfTopCandidate.tagName !== "BODY") {
	              var listsContainingThisAncestor = 0;

	              for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
	                listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
	              }

	              if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
	                topCandidate = parentOfTopCandidate;
	                break;
	              }

	              parentOfTopCandidate = parentOfTopCandidate.parentNode;
	            }
	          }

	          if (!topCandidate.readability) {
	            this._initializeNode(topCandidate);
	          } // Because of our bonus system, parents of candidates might have scores
	          // themselves. They get half of the node. There won't be nodes with higher
	          // scores than our topCandidate, but if we see the score going *up* in the first
	          // few steps up the tree, that's a decent sign that there might be more content
	          // lurking in other places that we want to unify in. The sibling stuff
	          // below does some of that - but only if we've looked high enough up the DOM
	          // tree.


	          parentOfTopCandidate = topCandidate.parentNode;
	          var lastScore = topCandidate.readability.contentScore; // The scores shouldn't get too low.

	          var scoreThreshold = lastScore / 3;

	          while (parentOfTopCandidate.tagName !== "BODY") {
	            if (!parentOfTopCandidate.readability) {
	              parentOfTopCandidate = parentOfTopCandidate.parentNode;
	              continue;
	            }

	            var parentScore = parentOfTopCandidate.readability.contentScore;
	            if (parentScore < scoreThreshold) break;

	            if (parentScore > lastScore) {
	              // Alright! We found a better parent to use.
	              topCandidate = parentOfTopCandidate;
	              break;
	            }

	            lastScore = parentOfTopCandidate.readability.contentScore;
	            parentOfTopCandidate = parentOfTopCandidate.parentNode;
	          } // If the top candidate is the only child, use parent instead. This will help sibling
	          // joining logic when adjacent content is actually located in parent's sibling node.


	          parentOfTopCandidate = topCandidate.parentNode;

	          while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
	            topCandidate = parentOfTopCandidate;
	            parentOfTopCandidate = topCandidate.parentNode;
	          }

	          if (!topCandidate.readability) {
	            this._initializeNode(topCandidate);
	          }
	        } // Now that we have the top candidate, look through its siblings for content
	        // that might also be related. Things like preambles, content split by ads
	        // that we removed, etc.


	        var articleContent = doc.createElement("DIV");
	        if (isPaging) articleContent.id = "readability-content";
	        var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2); // Keep potential top candidate's parent node to try to get text direction of it later.

	        parentOfTopCandidate = topCandidate.parentNode;
	        var siblings = parentOfTopCandidate.children;

	        for (var s = 0, sl = siblings.length; s < sl; s++) {
	          var sibling = siblings[s];
	          var append = false;
	          this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
	          this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");

	          if (sibling === topCandidate) {
	            append = true;
	          } else {
	            var contentBonus = 0; // Give a bonus if sibling nodes and top candidates have the example same classname

	            if (sibling.className === topCandidate.className && topCandidate.className !== "") contentBonus += topCandidate.readability.contentScore * 0.2;

	            if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
	              append = true;
	            } else if (sibling.nodeName === "P") {
	              var linkDensity = this._getLinkDensity(sibling);

	              var nodeContent = this._getInnerText(sibling);

	              var nodeLength = nodeContent.length;

	              if (nodeLength > 80 && linkDensity < 0.25) {
	                append = true;
	              } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
	                append = true;
	              }
	            }
	          }

	          if (append) {
	            this.log("Appending node:", sibling);

	            if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
	              // We have a node that isn't a common block level element, like a form or td tag.
	              // Turn it into a div so it doesn't get filtered out later by accident.
	              this.log("Altering sibling:", sibling, "to div.");
	              sibling = this._setNodeTag(sibling, "DIV");
	            }

	            articleContent.appendChild(sibling); // Fetch children again to make it compatible
	            // with DOM parsers without live collection support.

	            siblings = parentOfTopCandidate.children; // siblings is a reference to the children array, and
	            // sibling is removed from the array when we call appendChild().
	            // As a result, we must revisit this index since the nodes
	            // have been shifted.

	            s -= 1;
	            sl -= 1;
	          }
	        }

	        if (this._debug) this.log("Article content pre-prep: " + articleContent.innerHTML); // So we have all of the content that we need. Now we clean it up for presentation.

	        this._prepArticle(articleContent);

	        if (this._debug) this.log("Article content post-prep: " + articleContent.innerHTML);

	        if (neededToCreateTopCandidate) {
	          // We already created a fake div thing, and there wouldn't have been any siblings left
	          // for the previous loop, so there's no point trying to create a new div, and then
	          // move all the children over. Just assign IDs and class names here. No need to append
	          // because that already happened anyway.
	          topCandidate.id = "readability-page-1";
	          topCandidate.className = "page";
	        } else {
	          var div = doc.createElement("DIV");
	          div.id = "readability-page-1";
	          div.className = "page";

	          while (articleContent.firstChild) {
	            div.appendChild(articleContent.firstChild);
	          }

	          articleContent.appendChild(div);
	        }

	        if (this._debug) this.log("Article content after paging: " + articleContent.innerHTML);
	        var parseSuccessful = true; // Now that we've gone through the full algorithm, check to see if
	        // we got any meaningful content. If we didn't, we may need to re-run
	        // grabArticle with different flags set. This gives us a higher likelihood of
	        // finding the content, and the sieve approach gives us a higher likelihood of
	        // finding the -right- content.

	        var textLength = this._getInnerText(articleContent, true).length;

	        if (textLength < this._charThreshold) {
	          parseSuccessful = false;
	          page.innerHTML = pageCacheHtml;

	          if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
	            this._removeFlag(this.FLAG_STRIP_UNLIKELYS);

	            this._attempts.push({
	              articleContent: articleContent,
	              textLength: textLength
	            });
	          } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
	            this._removeFlag(this.FLAG_WEIGHT_CLASSES);

	            this._attempts.push({
	              articleContent: articleContent,
	              textLength: textLength
	            });
	          } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
	            this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);

	            this._attempts.push({
	              articleContent: articleContent,
	              textLength: textLength
	            });
	          } else {
	            this._attempts.push({
	              articleContent: articleContent,
	              textLength: textLength
	            }); // No luck after removing flags, just return the longest text we found during the different loops


	            this._attempts.sort(function (a, b) {
	              return b.textLength - a.textLength;
	            }); // But first check if we actually have something


	            if (!this._attempts[0].textLength) {
	              return null;
	            }

	            articleContent = this._attempts[0].articleContent;
	            parseSuccessful = true;
	          }
	        }

	        if (parseSuccessful) {
	          // Find out text direction from ancestors of final top candidate.
	          var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));

	          this._someNode(ancestors, function (ancestor) {
	            if (!ancestor.tagName) return false;
	            var articleDir = ancestor.getAttribute("dir");

	            if (articleDir) {
	              this._articleDir = articleDir;
	              return true;
	            }

	            return false;
	          });

	          return articleContent;
	        }
	      }
	    },

	    /**
	     * Check whether the input string could be a byline.
	     * This verifies that the input is a string, and that the length
	     * is less than 100 chars.
	     *
	     * @param possibleByline {string} - a string to check whether its a byline.
	     * @return Boolean - whether the input string is a byline.
	     */
	    _isValidByline: function _isValidByline(byline) {
	      if (typeof byline == "string" || byline instanceof String) {
	        byline = byline.trim();
	        return byline.length > 0 && byline.length < 100;
	      }

	      return false;
	    },

	    /**
	     * Converts some of the common HTML entities in string to their corresponding characters.
	     *
	     * @param str {string} - a string to unescape.
	     * @return string without HTML entity.
	     */
	    _unescapeHtmlEntities: function _unescapeHtmlEntities(str) {
	      if (!str) {
	        return str;
	      }

	      var htmlEscapeMap = this.HTML_ESCAPE_MAP;
	      return str.replace(/&(quot|amp|apos|lt|gt);/g, function (_, tag) {
	        return htmlEscapeMap[tag];
	      }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function (_, hex, numStr) {
	        var num = parseInt(hex || numStr, hex ? 16 : 10);
	        return String.fromCharCode(num);
	      });
	    },

	    /**
	     * Try to extract metadata from JSON-LD object.
	     * For now, only Schema.org objects of type Article or its subtypes are supported.
	     * @return Object with any metadata that could be extracted (possibly none)
	     */
	    _getJSONLD: function _getJSONLD(doc) {
	      var scripts = this._getAllNodesWithTag(doc, ["script"]);

	      var metadata;

	      this._forEachNode(scripts, function (jsonLdElement) {
	        if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
	          try {
	            // Strip CDATA markers if present
	            var content = jsonLdElement.textContent.replace(/^\s*<!\[CDATA\[|\]\]>\s*$/g, "");
	            var parsed = JSON.parse(content);

	            if (!parsed["@context"] || !parsed["@context"].match(/^https?\:\/\/schema\.org$/)) {
	              return;
	            }

	            if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
	              parsed = parsed["@graph"].find(function (it) {
	                return (it["@type"] || "").match(this.REGEXPS.jsonLdArticleTypes);
	              });
	            }

	            if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
	              return;
	            }

	            metadata = {};

	            if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
	              // we have both name and headline element in the JSON-LD. They should both be the same but some websites like aktualne.cz
	              // put their own name into "name" and the article title to "headline" which confuses Readability. So we try to check if either
	              // "name" or "headline" closely matches the html title, and if so, use that one. If not, then we use "name" by default.
	              var title = this._getArticleTitle();

	              var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
	              var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;

	              if (headlineMatches && !nameMatches) {
	                metadata.title = parsed.headline;
	              } else {
	                metadata.title = parsed.name;
	              }
	            } else if (typeof parsed.name === "string") {
	              metadata.title = parsed.name.trim();
	            } else if (typeof parsed.headline === "string") {
	              metadata.title = parsed.headline.trim();
	            }

	            if (parsed.author) {
	              if (typeof parsed.author.name === "string") {
	                metadata.byline = parsed.author.name.trim();
	              } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
	                metadata.byline = parsed.author.filter(function (author) {
	                  return author && typeof author.name === "string";
	                }).map(function (author) {
	                  return author.name.trim();
	                }).join(", ");
	              }
	            }

	            if (typeof parsed.description === "string") {
	              metadata.excerpt = parsed.description.trim();
	            }

	            if (parsed.publisher && typeof parsed.publisher.name === "string") {
	              metadata.siteName = parsed.publisher.name.trim();
	            }

	            return;
	          } catch (err) {
	            this.log(err.message);
	          }
	        }
	      });

	      return metadata ? metadata : {};
	    },

	    /**
	     * Attempts to get excerpt and byline metadata for the article.
	     *
	     * @param {Object} jsonld  object containing any metadata that
	     * could be extracted from JSON-LD object.
	     *
	     * @return Object with optional "excerpt" and "byline" properties
	     */
	    _getArticleMetadata: function _getArticleMetadata(jsonld) {
	      var metadata = {};
	      var values = {};

	      var metaElements = this._doc.getElementsByTagName("meta"); // property is a space-separated list of values


	      var propertyPattern = /\s*(dc|dcterm|og|twitter)\s*:\s*(author|creator|description|title|site_name)\s*/gi; // name is a single value

	      var namePattern = /^\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\s*[\.:]\s*)?(author|creator|description|title|site_name)\s*$/i; // Find description tags.

	      this._forEachNode(metaElements, function (element) {
	        var elementName = element.getAttribute("name");
	        var elementProperty = element.getAttribute("property");
	        var content = element.getAttribute("content");

	        if (!content) {
	          return;
	        }

	        var matches = null;
	        var name = null;

	        if (elementProperty) {
	          matches = elementProperty.match(propertyPattern);

	          if (matches) {
	            // Convert to lowercase, and remove any whitespace
	            // so we can match below.
	            name = matches[0].toLowerCase().replace(/\s/g, ""); // multiple authors

	            values[name] = content.trim();
	          }
	        }

	        if (!matches && elementName && namePattern.test(elementName)) {
	          name = elementName;

	          if (content) {
	            // Convert to lowercase, remove any whitespace, and convert dots
	            // to colons so we can match below.
	            name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
	            values[name] = content.trim();
	          }
	        }
	      }); // get title


	      metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];

	      if (!metadata.title) {
	        metadata.title = this._getArticleTitle();
	      } // get author


	      metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"]; // get description

	      metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"]; // get site name

	      metadata.siteName = jsonld.siteName || values["og:site_name"]; // in many sites the meta value is escaped with HTML entities,
	      // so here we need to unescape it

	      metadata.title = this._unescapeHtmlEntities(metadata.title);
	      metadata.byline = this._unescapeHtmlEntities(metadata.byline);
	      metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
	      metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
	      return metadata;
	    },

	    /**
	     * Check if node is image, or if node contains exactly only one image
	     * whether as a direct child or as its descendants.
	     *
	     * @param Element
	    **/
	    _isSingleImage: function _isSingleImage(node) {
	      if (node.tagName === "IMG") {
	        return true;
	      }

	      if (node.children.length !== 1 || node.textContent.trim() !== "") {
	        return false;
	      }

	      return this._isSingleImage(node.children[0]);
	    },

	    /**
	     * Find all <noscript> that are located after <img> nodes, and which contain only one
	     * <img> element. Replace the first image with the image from inside the <noscript> tag,
	     * and remove the <noscript> tag. This improves the quality of the images we use on
	     * some sites (e.g. Medium).
	     *
	     * @param Element
	    **/
	    _unwrapNoscriptImages: function _unwrapNoscriptImages(doc) {
	      // Find img without source or attributes that might contains image, and remove it.
	      // This is done to prevent a placeholder img is replaced by img from noscript in next step.
	      var imgs = Array.from(doc.getElementsByTagName("img"));

	      this._forEachNode(imgs, function (img) {
	        for (var i = 0; i < img.attributes.length; i++) {
	          var attr = img.attributes[i];

	          switch (attr.name) {
	            case "src":
	            case "srcset":
	            case "data-src":
	            case "data-srcset":
	              return;
	          }

	          if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
	            return;
	          }
	        }

	        img.parentNode.removeChild(img);
	      }); // Next find noscript and try to extract its image


	      var noscripts = Array.from(doc.getElementsByTagName("noscript"));

	      this._forEachNode(noscripts, function (noscript) {
	        // Parse content of noscript and make sure it only contains image
	        var tmp = doc.createElement("div");
	        tmp.innerHTML = noscript.innerHTML;

	        if (!this._isSingleImage(tmp)) {
	          return;
	        } // If noscript has previous sibling and it only contains image,
	        // replace it with noscript content. However we also keep old
	        // attributes that might contains image.


	        var prevElement = noscript.previousElementSibling;

	        if (prevElement && this._isSingleImage(prevElement)) {
	          var prevImg = prevElement;

	          if (prevImg.tagName !== "IMG") {
	            prevImg = prevElement.getElementsByTagName("img")[0];
	          }

	          var newImg = tmp.getElementsByTagName("img")[0];

	          for (var i = 0; i < prevImg.attributes.length; i++) {
	            var attr = prevImg.attributes[i];

	            if (attr.value === "") {
	              continue;
	            }

	            if (attr.name === "src" || attr.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
	              if (newImg.getAttribute(attr.name) === attr.value) {
	                continue;
	              }

	              var attrName = attr.name;

	              if (newImg.hasAttribute(attrName)) {
	                attrName = "data-old-" + attrName;
	              }

	              newImg.setAttribute(attrName, attr.value);
	            }
	          }

	          noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
	        }
	      });
	    },

	    /**
	     * Removes script tags from the document.
	     *
	     * @param Element
	    **/
	    _removeScripts: function _removeScripts(doc) {
	      this._removeNodes(this._getAllNodesWithTag(doc, ["script"]), function (scriptNode) {
	        scriptNode.nodeValue = "";
	        scriptNode.removeAttribute("src");
	        return true;
	      });

	      this._removeNodes(this._getAllNodesWithTag(doc, ["noscript"]));
	    },

	    /**
	     * Check if this node has only whitespace and a single element with given tag
	     * Returns false if the DIV node contains non-empty text nodes
	     * or if it contains no element with given tag or more than 1 element.
	     *
	     * @param Element
	     * @param string tag of child element
	    **/
	    _hasSingleTagInsideElement: function _hasSingleTagInsideElement(element, tag) {
	      // There should be exactly 1 element child with given tag
	      if (element.children.length != 1 || element.children[0].tagName !== tag) {
	        return false;
	      } // And there should be no text nodes with real content


	      return !this._someNode(element.childNodes, function (node) {
	        return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
	      });
	    },
	    _isElementWithoutContent: function _isElementWithoutContent(node) {
	      return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
	    },

	    /**
	     * Determine whether element has any children block level elements.
	     *
	     * @param Element
	     */
	    _hasChildBlockElement: function _hasChildBlockElement(element) {
	      return this._someNode(element.childNodes, function (node) {
	        return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
	      });
	    },

	    /***
	     * Determine if a node qualifies as phrasing content.
	     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
	    **/
	    _isPhrasingContent: function _isPhrasingContent(node) {
	      return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
	    },
	    _isWhitespace: function _isWhitespace(node) {
	      return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
	    },

	    /**
	     * Get the inner text of a node - cross browser compatibly.
	     * This also strips out any excess whitespace to be found.
	     *
	     * @param Element
	     * @param Boolean normalizeSpaces (default: true)
	     * @return string
	    **/
	    _getInnerText: function _getInnerText(e, normalizeSpaces) {
	      normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
	      var textContent = e.textContent.trim();

	      if (normalizeSpaces) {
	        return textContent.replace(this.REGEXPS.normalize, " ");
	      }

	      return textContent;
	    },

	    /**
	     * Get the number of times a string s appears in the node e.
	     *
	     * @param Element
	     * @param string - what to split on. Default is ","
	     * @return number (integer)
	    **/
	    _getCharCount: function _getCharCount(e, s) {
	      s = s || ",";
	      return this._getInnerText(e).split(s).length - 1;
	    },

	    /**
	     * Remove the style attribute on every e and under.
	     * TODO: Test if getElementsByTagName(*) is faster.
	     *
	     * @param Element
	     * @return void
	    **/
	    _cleanStyles: function _cleanStyles(e) {
	      if (!e || e.tagName.toLowerCase() === "svg") return; // Remove `style` and deprecated presentational attributes

	      for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
	        e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
	      }

	      if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
	        e.removeAttribute("width");
	        e.removeAttribute("height");
	      }

	      var cur = e.firstElementChild;

	      while (cur !== null) {
	        this._cleanStyles(cur);

	        cur = cur.nextElementSibling;
	      }
	    },

	    /**
	     * Get the density of links as a percentage of the content
	     * This is the amount of text that is inside a link divided by the total text in the node.
	     *
	     * @param Element
	     * @return number (float)
	    **/
	    _getLinkDensity: function _getLinkDensity(element) {
	      var textLength = this._getInnerText(element).length;

	      if (textLength === 0) return 0;
	      var linkLength = 0; // XXX implement _reduceNodeList?

	      this._forEachNode(element.getElementsByTagName("a"), function (linkNode) {
	        var href = linkNode.getAttribute("href");
	        var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
	        linkLength += this._getInnerText(linkNode).length * coefficient;
	      });

	      return linkLength / textLength;
	    },

	    /**
	     * Get an elements class/id weight. Uses regular expressions to tell if this
	     * element looks good or bad.
	     *
	     * @param Element
	     * @return number (Integer)
	    **/
	    _getClassWeight: function _getClassWeight(e) {
	      if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) return 0;
	      var weight = 0; // Look for a special classname

	      if (typeof e.className === "string" && e.className !== "") {
	        if (this.REGEXPS.negative.test(e.className)) weight -= 25;
	        if (this.REGEXPS.positive.test(e.className)) weight += 25;
	      } // Look for a special ID


	      if (typeof e.id === "string" && e.id !== "") {
	        if (this.REGEXPS.negative.test(e.id)) weight -= 25;
	        if (this.REGEXPS.positive.test(e.id)) weight += 25;
	      }

	      return weight;
	    },

	    /**
	     * Clean a node of all elements of type "tag".
	     * (Unless it's a youtube/vimeo video. People love movies.)
	     *
	     * @param Element
	     * @param string tag to clean
	     * @return void
	     **/
	    _clean: function _clean(e, tag) {
	      var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;

	      this._removeNodes(this._getAllNodesWithTag(e, [tag]), function (element) {
	        // Allow youtube and vimeo videos through as people usually want to see those.
	        if (isEmbed) {
	          // First, check the elements attributes to see if any of them contain youtube or vimeo
	          for (var i = 0; i < element.attributes.length; i++) {
	            if (this.REGEXPS.videos.test(element.attributes[i].value)) {
	              return false;
	            }
	          } // For embed with <object> tag, check inner HTML as well.


	          if (element.tagName === "object" && this.REGEXPS.videos.test(element.innerHTML)) {
	            return false;
	          }
	        }

	        return true;
	      });
	    },

	    /**
	     * Check if a given node has one of its ancestor tag name matching the
	     * provided one.
	     * @param  HTMLElement node
	     * @param  String      tagName
	     * @param  Number      maxDepth
	     * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
	     * @return Boolean
	     */
	    _hasAncestorTag: function _hasAncestorTag(node, tagName, maxDepth, filterFn) {
	      maxDepth = maxDepth || 3;
	      tagName = tagName.toUpperCase();
	      var depth = 0;

	      while (node.parentNode) {
	        if (maxDepth > 0 && depth > maxDepth) return false;
	        if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode))) return true;
	        node = node.parentNode;
	        depth++;
	      }

	      return false;
	    },

	    /**
	     * Return an object indicating how many rows and columns this table has.
	     */
	    _getRowAndColumnCount: function _getRowAndColumnCount(table) {
	      var rows = 0;
	      var columns = 0;
	      var trs = table.getElementsByTagName("tr");

	      for (var i = 0; i < trs.length; i++) {
	        var rowspan = trs[i].getAttribute("rowspan") || 0;

	        if (rowspan) {
	          rowspan = parseInt(rowspan, 10);
	        }

	        rows += rowspan || 1; // Now look for column-related info

	        var columnsInThisRow = 0;
	        var cells = trs[i].getElementsByTagName("td");

	        for (var j = 0; j < cells.length; j++) {
	          var colspan = cells[j].getAttribute("colspan") || 0;

	          if (colspan) {
	            colspan = parseInt(colspan, 10);
	          }

	          columnsInThisRow += colspan || 1;
	        }

	        columns = Math.max(columns, columnsInThisRow);
	      }

	      return {
	        rows: rows,
	        columns: columns
	      };
	    },

	    /**
	     * Look for 'data' (as opposed to 'layout') tables, for which we use
	     * similar checks as
	     * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
	     */
	    _markDataTables: function _markDataTables(root) {
	      var tables = root.getElementsByTagName("table");

	      for (var i = 0; i < tables.length; i++) {
	        var table = tables[i];
	        var role = table.getAttribute("role");

	        if (role == "presentation") {
	          table._readabilityDataTable = false;
	          continue;
	        }

	        var datatable = table.getAttribute("datatable");

	        if (datatable == "0") {
	          table._readabilityDataTable = false;
	          continue;
	        }

	        var summary = table.getAttribute("summary");

	        if (summary) {
	          table._readabilityDataTable = true;
	          continue;
	        }

	        var caption = table.getElementsByTagName("caption")[0];

	        if (caption && caption.childNodes.length > 0) {
	          table._readabilityDataTable = true;
	          continue;
	        } // If the table has a descendant with any of these tags, consider a data table:


	        var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];

	        var descendantExists = function descendantExists(tag) {
	          return !!table.getElementsByTagName(tag)[0];
	        };

	        if (dataTableDescendants.some(descendantExists)) {
	          this.log("Data table because found data-y descendant");
	          table._readabilityDataTable = true;
	          continue;
	        } // Nested tables indicate a layout table:


	        if (table.getElementsByTagName("table")[0]) {
	          table._readabilityDataTable = false;
	          continue;
	        }

	        var sizeInfo = this._getRowAndColumnCount(table);

	        if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
	          table._readabilityDataTable = true;
	          continue;
	        } // Now just go by size entirely:


	        table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
	      }
	    },

	    /* convert images and figures that have properties like data-src into images that can be loaded without JS */
	    _fixLazyImages: function _fixLazyImages(root) {
	      this._forEachNode(this._getAllNodesWithTag(root, ["img", "picture", "figure"]), function (elem) {
	        // In some sites (e.g. Kotaku), they put 1px square image as base64 data uri in the src attribute.
	        // So, here we check if the data uri is too short, just might as well remove it.
	        if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
	          // Make sure it's not SVG, because SVG can have a meaningful image in under 133 bytes.
	          var parts = this.REGEXPS.b64DataUrl.exec(elem.src);

	          if (parts[1] === "image/svg+xml") {
	            return;
	          } // Make sure this element has other attributes which contains image.
	          // If it doesn't, then this src is important and shouldn't be removed.


	          var srcCouldBeRemoved = false;

	          for (var i = 0; i < elem.attributes.length; i++) {
	            var attr = elem.attributes[i];

	            if (attr.name === "src") {
	              continue;
	            }

	            if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
	              srcCouldBeRemoved = true;
	              break;
	            }
	          } // Here we assume if image is less than 100 bytes (or 133B after encoded to base64)
	          // it will be too small, therefore it might be placeholder image.


	          if (srcCouldBeRemoved) {
	            var b64starts = elem.src.search(/base64\s*/i) + 7;
	            var b64length = elem.src.length - b64starts;

	            if (b64length < 133) {
	              elem.removeAttribute("src");
	            }
	          }
	        } // also check for "null" to work around https://github.com/jsdom/jsdom/issues/2580


	        if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
	          return;
	        }

	        for (var j = 0; j < elem.attributes.length; j++) {
	          attr = elem.attributes[j];

	          if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
	            continue;
	          }

	          var copyTo = null;

	          if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr.value)) {
	            copyTo = "srcset";
	          } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr.value)) {
	            copyTo = "src";
	          }

	          if (copyTo) {
	            //if this is an img or picture, set the attribute directly
	            if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
	              elem.setAttribute(copyTo, attr.value);
	            } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
	              //if the item is a <figure> that does not contain an image or picture, create one and place it inside the figure
	              //see the nytimes-3 testcase for an example
	              var img = this._doc.createElement("img");

	              img.setAttribute(copyTo, attr.value);
	              elem.appendChild(img);
	            }
	          }
	        }
	      });
	    },
	    _getTextDensity: function _getTextDensity(e, tags) {
	      var textLength = this._getInnerText(e, true).length;

	      if (textLength === 0) {
	        return 0;
	      }

	      var childrenLength = 0;

	      var children = this._getAllNodesWithTag(e, tags);

	      this._forEachNode(children, child => childrenLength += this._getInnerText(child, true).length);

	      return childrenLength / textLength;
	    },

	    /**
	     * Clean an element of all tags of type "tag" if they look fishy.
	     * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
	     *
	     * @return void
	     **/
	    _cleanConditionally: function _cleanConditionally(e, tag) {
	      if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) return; // Gather counts for other typical elements embedded within.
	      // Traverse backwards so we can remove nodes at the same time
	      // without effecting the traversal.
	      //
	      // TODO: Consider taking into account original contentScore here.

	      this._removeNodes(this._getAllNodesWithTag(e, [tag]), function (node) {
	        // First check if this node IS data table, in which case don't remove it.
	        var isDataTable = function isDataTable(t) {
	          return t._readabilityDataTable;
	        };

	        var isList = tag === "ul" || tag === "ol";

	        if (!isList) {
	          var listLength = 0;

	          var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);

	          this._forEachNode(listNodes, list => listLength += this._getInnerText(list).length);

	          isList = listLength / this._getInnerText(node).length > 0.9;
	        }

	        if (tag === "table" && isDataTable(node)) {
	          return false;
	        } // Next check if we're inside a data table, in which case don't remove it as well.


	        if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
	          return false;
	        }

	        if (this._hasAncestorTag(node, "code")) {
	          return false;
	        }

	        var weight = this._getClassWeight(node);

	        this.log("Cleaning Conditionally", node);
	        var contentScore = 0;

	        if (weight + contentScore < 0) {
	          return true;
	        }

	        if (this._getCharCount(node, ",") < 10) {
	          // If there are not very many commas, and the number of
	          // non-paragraph elements is more than paragraphs or other
	          // ominous signs, remove the element.
	          var p = node.getElementsByTagName("p").length;
	          var img = node.getElementsByTagName("img").length;
	          var li = node.getElementsByTagName("li").length - 100;
	          var input = node.getElementsByTagName("input").length;

	          var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);

	          var embedCount = 0;

	          var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);

	          for (var i = 0; i < embeds.length; i++) {
	            // If this embed has attribute that matches video regex, don't delete it.
	            for (var j = 0; j < embeds[i].attributes.length; j++) {
	              if (this.REGEXPS.videos.test(embeds[i].attributes[j].value)) {
	                return false;
	              }
	            } // For embed with <object> tag, check inner HTML as well.


	            if (embeds[i].tagName === "object" && this.REGEXPS.videos.test(embeds[i].innerHTML)) {
	              return false;
	            }

	            embedCount++;
	          }

	          var linkDensity = this._getLinkDensity(node);

	          var contentLength = this._getInnerText(node).length;

	          var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || embedCount === 1 && contentLength < 75 || embedCount > 1;
	          return haveToRemove;
	        }

	        return false;
	      });
	    },

	    /**
	     * Clean out elements that match the specified conditions
	     *
	     * @param Element
	     * @param Function determines whether a node should be removed
	     * @return void
	     **/
	    _cleanMatchedNodes: function _cleanMatchedNodes(e, filter) {
	      var endOfSearchMarkerNode = this._getNextNode(e, true);

	      var next = this._getNextNode(e);

	      while (next && next != endOfSearchMarkerNode) {
	        if (filter.call(this, next, next.className + " " + next.id)) {
	          next = this._removeAndGetNext(next);
	        } else {
	          next = this._getNextNode(next);
	        }
	      }
	    },

	    /**
	     * Clean out spurious headers from an Element.
	     *
	     * @param Element
	     * @return void
	    **/
	    _cleanHeaders: function _cleanHeaders(e) {
	      var headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);

	      this._removeNodes(headingNodes, function (node) {
	        var shouldRemove = this._getClassWeight(node) < 0;

	        if (shouldRemove) {
	          this.log("Removing header with low class weight:", node);
	        }

	        return shouldRemove;
	      });
	    },

	    /**
	     * Check if this node is an H1 or H2 element whose content is mostly
	     * the same as the article title.
	     *
	     * @param Element  the node to check.
	     * @return boolean indicating whether this is a title-like header.
	     */
	    _headerDuplicatesTitle: function _headerDuplicatesTitle(node) {
	      if (node.tagName != "H1" && node.tagName != "H2") {
	        return false;
	      }

	      var heading = this._getInnerText(node, false);

	      this.log("Evaluating similarity of header:", heading, this._articleTitle);
	      return this._textSimilarity(this._articleTitle, heading) > 0.75;
	    },
	    _flagIsActive: function _flagIsActive(flag) {
	      return (this._flags & flag) > 0;
	    },
	    _removeFlag: function _removeFlag(flag) {
	      this._flags = this._flags & ~flag;
	    },
	    _isProbablyVisible: function _isProbablyVisible(node) {
	      // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.
	      return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") //check for "fallback-image" so that wikimedia math images are displayed
	      && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
	    },

	    /**
	     * Runs readability.
	     *
	     * Workflow:
	     *  1. Prep the document by removing script tags, css, etc.
	     *  2. Build readability's DOM tree.
	     *  3. Grab the article content from the current dom tree.
	     *  4. Replace the current DOM tree with the new one.
	     *  5. Read peacefully.
	     *
	     * @return void
	     **/
	    parse: function parse() {
	      // Avoid parsing too large documents, as per configuration option
	      if (this._maxElemsToParse > 0) {
	        var numTags = this._doc.getElementsByTagName("*").length;

	        if (numTags > this._maxElemsToParse) {
	          throw new Error("Aborting parsing document; " + numTags + " elements found");
	        }
	      } // Unwrap image from noscript


	      this._unwrapNoscriptImages(this._doc); // Extract JSON-LD metadata before removing scripts


	      var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc); // Remove script tags from the document.

	      this._removeScripts(this._doc);

	      this._prepDocument();

	      var metadata = this._getArticleMetadata(jsonLd);

	      this._articleTitle = metadata.title;

	      var articleContent = this._grabArticle();

	      if (!articleContent) return null;
	      this.log("Grabbed: " + articleContent.innerHTML);

	      this._postProcessContent(articleContent); // If we haven't found an excerpt in the article's metadata, use the article's
	      // first paragraph as the excerpt. This is used for displaying a preview of
	      // the article's content.


	      if (!metadata.excerpt) {
	        var paragraphs = articleContent.getElementsByTagName("p");

	        if (paragraphs.length > 0) {
	          metadata.excerpt = paragraphs[0].textContent.trim();
	        }
	      }

	      var textContent = articleContent.textContent;
	      return {
	        title: this._articleTitle,
	        byline: metadata.byline || this._articleByline,
	        dir: this._articleDir,
	        lang: this._articleLang,
	        content: this._serializer(articleContent),
	        textContent: textContent,
	        length: textContent.length,
	        excerpt: metadata.excerpt,
	        siteName: metadata.siteName || this._articleSiteName
	      };
	    }
	  };

	  {
	    module.exports = Readability;
	  }
	});

	/* eslint-env es6:false */
	var ReadabilityReaderable = createCommonjsModule(function (module) {
	  /*
	   * Copyright (c) 2010 Arc90 Inc
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License");
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   */

	  /*
	   * This code is heavily based on Arc90's readability.js (1.7.1) script
	   * available at: http://code.google.com/p/arc90labs-readability
	   */
	  var REGEXPS = {
	    // NOTE: These two regular expressions are duplicated in
	    // Readability.js. Please keep both copies in sync.
	    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
	    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
	  };

	  function isNodeVisible(node) {
	    // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.
	    return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") //check for "fallback-image" so that wikimedia math images are displayed
	    && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
	  }
	  /**
	   * Decides whether or not the document is reader-able without parsing the whole thing.
	   * @param {Object} options Configuration object.
	   * @param {number} [options.minContentLength=140] The minimum node content length used to decide if the document is readerable.
	   * @param {number} [options.minScore=20] The minumum cumulated 'score' used to determine if the document is readerable.
	   * @param {Function} [options.visibilityChecker=isNodeVisible] The function used to determine if a node is visible.
	   * @return {boolean} Whether or not we suspect Readability.parse() will suceeed at returning an article object.
	   */


	  function isProbablyReaderable(doc) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    // For backward compatibility reasons 'options' can either be a configuration object or the function used
	    // to determine if a node is visible.
	    if (typeof options == "function") {
	      options = {
	        visibilityChecker: options
	      };
	    }

	    var defaultOptions = {
	      minScore: 20,
	      minContentLength: 140,
	      visibilityChecker: isNodeVisible
	    };
	    options = Object.assign(defaultOptions, options);
	    var nodes = doc.querySelectorAll("p, pre, article"); // Get <div> nodes which have <br> node(s) and append them into the `nodes` variable.
	    // Some articles' DOM structures might look like
	    // <div>
	    //   Sentences<br>
	    //   <br>
	    //   Sentences<br>
	    // </div>

	    var brNodes = doc.querySelectorAll("div > br");

	    if (brNodes.length) {
	      var set = new Set(nodes);
	      [].forEach.call(brNodes, function (node) {
	        set.add(node.parentNode);
	      });
	      nodes = Array.from(set);
	    }

	    var score = 0; // This is a little cheeky, we use the accumulator 'score' to decide what to return from
	    // this callback:

	    return [].some.call(nodes, function (node) {
	      if (!options.visibilityChecker(node)) {
	        return false;
	      }

	      var matchString = node.className + " " + node.id;

	      if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
	        return false;
	      }

	      if (node.matches("li p")) {
	        return false;
	      }

	      var textContentLength = node.textContent.trim().length;

	      if (textContentLength < options.minContentLength) {
	        return false;
	      }

	      score += Math.sqrt(textContentLength - options.minContentLength);

	      if (score > options.minScore) {
	        return true;
	      }

	      return false;
	    });
	  }

	  {
	    module.exports = isProbablyReaderable;
	  }
	});

	var readability = {
	  Readability: Readability_1,
	  isProbablyReaderable: ReadabilityReaderable
	};

	/*! @license DOMPurify 2.3.10 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.10/LICENSE */
	var purify = createCommonjsModule(function (module, exports) {
	  (function (global, factory) {
	    module.exports = factory() ;
	  })(commonjsGlobal, function () {

	    function _typeof(obj) {
	      "@babel/helpers - typeof";

	      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	        return typeof obj;
	      } : function (obj) {
	        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	      }, _typeof(obj);
	    }

	    function _setPrototypeOf(o, p) {
	      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	        o.__proto__ = p;
	        return o;
	      };

	      return _setPrototypeOf(o, p);
	    }

	    function _isNativeReflectConstruct() {
	      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	      if (Reflect.construct.sham) return false;
	      if (typeof Proxy === "function") return true;

	      try {
	        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	        return true;
	      } catch (e) {
	        return false;
	      }
	    }

	    function _construct(Parent, args, Class) {
	      if (_isNativeReflectConstruct()) {
	        _construct = Reflect.construct;
	      } else {
	        _construct = function _construct(Parent, args, Class) {
	          var a = [null];
	          a.push.apply(a, args);
	          var Constructor = Function.bind.apply(Parent, a);
	          var instance = new Constructor();
	          if (Class) _setPrototypeOf(instance, Class.prototype);
	          return instance;
	        };
	      }

	      return _construct.apply(null, arguments);
	    }

	    function _toConsumableArray(arr) {
	      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	    }

	    function _arrayWithoutHoles(arr) {
	      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	    }

	    function _iterableToArray(iter) {
	      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	    }

	    function _unsupportedIterableToArray(o, minLen) {
	      if (!o) return;
	      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	      var n = Object.prototype.toString.call(o).slice(8, -1);
	      if (n === "Object" && o.constructor) n = o.constructor.name;
	      if (n === "Map" || n === "Set") return Array.from(o);
	      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	    }

	    function _arrayLikeToArray(arr, len) {
	      if (len == null || len > arr.length) len = arr.length;

	      for (var i = 0, arr2 = new Array(len); i < len; i++) {
	        arr2[i] = arr[i];
	      }

	      return arr2;
	    }

	    function _nonIterableSpread() {
	      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	    }

	    var hasOwnProperty = Object.hasOwnProperty,
	        setPrototypeOf = Object.setPrototypeOf,
	        isFrozen = Object.isFrozen,
	        getPrototypeOf = Object.getPrototypeOf,
	        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	    var freeze = Object.freeze,
	        seal = Object.seal,
	        create = Object.create; // eslint-disable-line import/no-mutable-exports

	    var _ref = typeof Reflect !== 'undefined' && Reflect,
	        apply = _ref.apply,
	        construct = _ref.construct;

	    if (!apply) {
	      apply = function apply(fun, thisValue, args) {
	        return fun.apply(thisValue, args);
	      };
	    }

	    if (!freeze) {
	      freeze = function freeze(x) {
	        return x;
	      };
	    }

	    if (!seal) {
	      seal = function seal(x) {
	        return x;
	      };
	    }

	    if (!construct) {
	      construct = function construct(Func, args) {
	        return _construct(Func, _toConsumableArray(args));
	      };
	    }

	    var arrayForEach = unapply(Array.prototype.forEach);
	    var arrayPop = unapply(Array.prototype.pop);
	    var arrayPush = unapply(Array.prototype.push);
	    var stringToLowerCase = unapply(String.prototype.toLowerCase);
	    var stringMatch = unapply(String.prototype.match);
	    var stringReplace = unapply(String.prototype.replace);
	    var stringIndexOf = unapply(String.prototype.indexOf);
	    var stringTrim = unapply(String.prototype.trim);
	    var regExpTest = unapply(RegExp.prototype.test);
	    var typeErrorCreate = unconstruct(TypeError);

	    function unapply(func) {
	      return function (thisArg) {
	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }

	        return apply(func, thisArg, args);
	      };
	    }

	    function unconstruct(func) {
	      return function () {
	        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          args[_key2] = arguments[_key2];
	        }

	        return construct(func, args);
	      };
	    }
	    /* Add properties to a lookup table */


	    function addToSet(set, array, transformCaseFunc) {
	      transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

	      if (setPrototypeOf) {
	        // Make 'in' and truthy checks like Boolean(set.constructor)
	        // independent of any properties defined on Object.prototype.
	        // Prevent prototype setters from intercepting set as a this value.
	        setPrototypeOf(set, null);
	      }

	      var l = array.length;

	      while (l--) {
	        var element = array[l];

	        if (typeof element === 'string') {
	          var lcElement = transformCaseFunc(element);

	          if (lcElement !== element) {
	            // Config presets (e.g. tags.js, attrs.js) are immutable.
	            if (!isFrozen(array)) {
	              array[l] = lcElement;
	            }

	            element = lcElement;
	          }
	        }

	        set[element] = true;
	      }

	      return set;
	    }
	    /* Shallow clone an object */


	    function clone(object) {
	      var newObject = create(null);
	      var property;

	      for (property in object) {
	        if (apply(hasOwnProperty, object, [property])) {
	          newObject[property] = object[property];
	        }
	      }

	      return newObject;
	    }
	    /* IE10 doesn't support __lookupGetter__ so lets'
	     * simulate it. It also automatically checks
	     * if the prop is function or getter and behaves
	     * accordingly. */


	    function lookupGetter(object, prop) {
	      while (object !== null) {
	        var desc = getOwnPropertyDescriptor(object, prop);

	        if (desc) {
	          if (desc.get) {
	            return unapply(desc.get);
	          }

	          if (typeof desc.value === 'function') {
	            return unapply(desc.value);
	          }
	        }

	        object = getPrototypeOf(object);
	      }

	      function fallbackValue(element) {
	        console.warn('fallback value for', element);
	        return null;
	      }

	      return fallbackValue;
	    }

	    var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

	    var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
	    var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
	    // We still need to know them so that we can do namespace
	    // checks properly in case one wants to add them to
	    // allow-list.

	    var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
	    var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
	    // even those that we disallow by default.

	    var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
	    var text = freeze(['#text']);
	    var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
	    var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
	    var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
	    var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
	    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

	    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
	    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

	    var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

	    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
	    );
	    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
	    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
	    );
	    var DOCTYPE_NAME = seal(/^html$/i);

	    var getGlobal = function getGlobal() {
	      return typeof window === 'undefined' ? null : window;
	    };
	    /**
	     * Creates a no-op policy for internal use only.
	     * Don't export this function outside this module!
	     * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
	     * @param {Document} document The document object (to determine policy name suffix)
	     * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
	     * are not supported).
	     */


	    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
	      if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
	        return null;
	      } // Allow the callers to control the unique policy name
	      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
	      // Policy creation with duplicate names throws in Trusted Types.


	      var suffix = null;
	      var ATTR_NAME = 'data-tt-policy-suffix';

	      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
	        suffix = document.currentScript.getAttribute(ATTR_NAME);
	      }

	      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

	      try {
	        return trustedTypes.createPolicy(policyName, {
	          createHTML: function createHTML(html) {
	            return html;
	          },
	          createScriptURL: function createScriptURL(scriptUrl) {
	            return scriptUrl;
	          }
	        });
	      } catch (_) {
	        // Policy creation failed (most likely another DOMPurify script has
	        // already run). Skip creating the policy, as this will only cause errors
	        // if TT are enforced.
	        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
	        return null;
	      }
	    };

	    function createDOMPurify() {
	      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

	      var DOMPurify = function DOMPurify(root) {
	        return createDOMPurify(root);
	      };
	      /**
	       * Version label, exposed for easier checks
	       * if DOMPurify is up to date or not
	       */


	      DOMPurify.version = '2.3.10';
	      /**
	       * Array of elements that DOMPurify removed during sanitation.
	       * Empty if nothing was removed.
	       */

	      DOMPurify.removed = [];

	      if (!window || !window.document || window.document.nodeType !== 9) {
	        // Not running in a browser, provide a factory function
	        // so that you can pass your own Window
	        DOMPurify.isSupported = false;
	        return DOMPurify;
	      }

	      var originalDocument = window.document;
	      var document = window.document;
	      var DocumentFragment = window.DocumentFragment,
	          HTMLTemplateElement = window.HTMLTemplateElement,
	          Node = window.Node,
	          Element = window.Element,
	          NodeFilter = window.NodeFilter,
	          _window$NamedNodeMap = window.NamedNodeMap,
	          NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
	          HTMLFormElement = window.HTMLFormElement,
	          DOMParser = window.DOMParser,
	          trustedTypes = window.trustedTypes;
	      var ElementPrototype = Element.prototype;
	      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
	      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
	      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
	      var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
	      // new document created via createHTMLDocument. As per the spec
	      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
	      // a new empty registry is used when creating a template contents owner
	      // document, so we use that as our parent document to ensure nothing
	      // is inherited.

	      if (typeof HTMLTemplateElement === 'function') {
	        var template = document.createElement('template');

	        if (template.content && template.content.ownerDocument) {
	          document = template.content.ownerDocument;
	        }
	      }

	      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

	      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
	      var _document = document,
	          implementation = _document.implementation,
	          createNodeIterator = _document.createNodeIterator,
	          createDocumentFragment = _document.createDocumentFragment,
	          getElementsByTagName = _document.getElementsByTagName;
	      var importNode = originalDocument.importNode;
	      var documentMode = {};

	      try {
	        documentMode = clone(document).documentMode ? document.documentMode : {};
	      } catch (_) {}

	      var hooks = {};
	      /**
	       * Expose whether this browser supports running the full DOMPurify.
	       */

	      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
	      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
	          ERB_EXPR$1 = ERB_EXPR,
	          DATA_ATTR$1 = DATA_ATTR,
	          ARIA_ATTR$1 = ARIA_ATTR,
	          IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
	          ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
	      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
	      /**
	       * We consider the elements and attributes below to be safe. Ideally
	       * don't add any new ones but feel free to remove unwanted ones.
	       */

	      /* allowed element names */

	      var ALLOWED_TAGS = null;
	      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
	      /* Allowed attribute names */

	      var ALLOWED_ATTR = null;
	      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
	      /*
	       * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
	       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
	       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
	       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
	       */

	      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
	        tagNameCheck: {
	          writable: true,
	          configurable: false,
	          enumerable: true,
	          value: null
	        },
	        attributeNameCheck: {
	          writable: true,
	          configurable: false,
	          enumerable: true,
	          value: null
	        },
	        allowCustomizedBuiltInElements: {
	          writable: true,
	          configurable: false,
	          enumerable: true,
	          value: false
	        }
	      }));
	      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

	      var FORBID_TAGS = null;
	      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

	      var FORBID_ATTR = null;
	      /* Decide if ARIA attributes are okay */

	      var ALLOW_ARIA_ATTR = true;
	      /* Decide if custom data attributes are okay */

	      var ALLOW_DATA_ATTR = true;
	      /* Decide if unknown protocols are okay */

	      var ALLOW_UNKNOWN_PROTOCOLS = false;
	      /* Output should be safe for common template engines.
	       * This means, DOMPurify removes data attributes, mustaches and ERB
	       */

	      var SAFE_FOR_TEMPLATES = false;
	      /* Decide if document with <html>... should be returned */

	      var WHOLE_DOCUMENT = false;
	      /* Track whether config is already set on this instance of DOMPurify. */

	      var SET_CONFIG = false;
	      /* Decide if all elements (e.g. style, script) must be children of
	       * document.body. By default, browsers might move them to document.head */

	      var FORCE_BODY = false;
	      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
	       * string (or a TrustedHTML object if Trusted Types are supported).
	       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
	       */

	      var RETURN_DOM = false;
	      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
	       * string  (or a TrustedHTML object if Trusted Types are supported) */

	      var RETURN_DOM_FRAGMENT = false;
	      /* Try to return a Trusted Type object instead of a string, return a string in
	       * case Trusted Types are not supported  */

	      var RETURN_TRUSTED_TYPE = false;
	      /* Output should be free from DOM clobbering attacks? */

	      var SANITIZE_DOM = true;
	      /* Keep element content when removing element? */

	      var KEEP_CONTENT = true;
	      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
	       * of importing it into a new Document and returning a sanitized copy */

	      var IN_PLACE = false;
	      /* Allow usage of profiles like html, svg and mathMl */

	      var USE_PROFILES = {};
	      /* Tags to ignore content of when KEEP_CONTENT is true */

	      var FORBID_CONTENTS = null;
	      var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
	      /* Tags that are safe for data: URIs */

	      var DATA_URI_TAGS = null;
	      var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
	      /* Attributes safe for values like "javascript:" */

	      var URI_SAFE_ATTRIBUTES = null;
	      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
	      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
	      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
	      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
	      /* Document namespace */

	      var NAMESPACE = HTML_NAMESPACE;
	      var IS_EMPTY_INPUT = false;
	      /* Parsing of strict XHTML documents */

	      var PARSER_MEDIA_TYPE;
	      var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
	      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
	      var transformCaseFunc;
	      /* Keep a reference to config to pass to hooks */

	      var CONFIG = null;
	      /* Ideally, do not touch anything below this line */

	      /* ______________________________________________ */

	      var formElement = document.createElement('form');

	      var isRegexOrFunction = function isRegexOrFunction(testValue) {
	        return testValue instanceof RegExp || testValue instanceof Function;
	      };
	      /**
	       * _parseConfig
	       *
	       * @param  {Object} cfg optional config literal
	       */
	      // eslint-disable-next-line complexity


	      var _parseConfig = function _parseConfig(cfg) {
	        if (CONFIG && CONFIG === cfg) {
	          return;
	        }
	        /* Shield configuration object from tampering */


	        if (!cfg || _typeof(cfg) !== 'object') {
	          cfg = {};
	        }
	        /* Shield configuration object from prototype pollution */


	        cfg = clone(cfg);
	        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
	        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

	        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
	          return x;
	        } : stringToLowerCase;
	        /* Set configuration parameters */

	        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
	        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
	        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
	        cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
	        transformCaseFunc // eslint-disable-line indent
	        ) // eslint-disable-line indent
	        : DEFAULT_URI_SAFE_ATTRIBUTES;
	        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
	        cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
	        transformCaseFunc // eslint-disable-line indent
	        ) // eslint-disable-line indent
	        : DEFAULT_DATA_URI_TAGS;
	        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
	        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
	        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
	        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
	        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

	        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

	        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

	        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

	        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

	        RETURN_DOM = cfg.RETURN_DOM || false; // Default false

	        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

	        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

	        FORCE_BODY = cfg.FORCE_BODY || false; // Default false

	        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

	        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

	        IN_PLACE = cfg.IN_PLACE || false; // Default false

	        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
	        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

	        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
	          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
	        }

	        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
	          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
	        }

	        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
	          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
	        }

	        if (SAFE_FOR_TEMPLATES) {
	          ALLOW_DATA_ATTR = false;
	        }

	        if (RETURN_DOM_FRAGMENT) {
	          RETURN_DOM = true;
	        }
	        /* Parse profile info */


	        if (USE_PROFILES) {
	          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
	          ALLOWED_ATTR = [];

	          if (USE_PROFILES.html === true) {
	            addToSet(ALLOWED_TAGS, html$1);
	            addToSet(ALLOWED_ATTR, html);
	          }

	          if (USE_PROFILES.svg === true) {
	            addToSet(ALLOWED_TAGS, svg$1);
	            addToSet(ALLOWED_ATTR, svg);
	            addToSet(ALLOWED_ATTR, xml);
	          }

	          if (USE_PROFILES.svgFilters === true) {
	            addToSet(ALLOWED_TAGS, svgFilters);
	            addToSet(ALLOWED_ATTR, svg);
	            addToSet(ALLOWED_ATTR, xml);
	          }

	          if (USE_PROFILES.mathMl === true) {
	            addToSet(ALLOWED_TAGS, mathMl$1);
	            addToSet(ALLOWED_ATTR, mathMl);
	            addToSet(ALLOWED_ATTR, xml);
	          }
	        }
	        /* Merge configuration parameters */


	        if (cfg.ADD_TAGS) {
	          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
	            ALLOWED_TAGS = clone(ALLOWED_TAGS);
	          }

	          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
	        }

	        if (cfg.ADD_ATTR) {
	          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
	            ALLOWED_ATTR = clone(ALLOWED_ATTR);
	          }

	          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
	        }

	        if (cfg.ADD_URI_SAFE_ATTR) {
	          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
	        }

	        if (cfg.FORBID_CONTENTS) {
	          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
	            FORBID_CONTENTS = clone(FORBID_CONTENTS);
	          }

	          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
	        }
	        /* Add #text in case KEEP_CONTENT is set to true */


	        if (KEEP_CONTENT) {
	          ALLOWED_TAGS['#text'] = true;
	        }
	        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


	        if (WHOLE_DOCUMENT) {
	          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
	        }
	        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


	        if (ALLOWED_TAGS.table) {
	          addToSet(ALLOWED_TAGS, ['tbody']);
	          delete FORBID_TAGS.tbody;
	        } // Prevent further manipulation of configuration.
	        // Not available in IE8, Safari 5, etc.


	        if (freeze) {
	          freeze(cfg);
	        }

	        CONFIG = cfg;
	      };

	      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
	      var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
	      // namespace. We need to specify them explicitly
	      // so that they don't get erroneously deleted from
	      // HTML namespace.

	      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
	      /* Keep track of all possible SVG and MathML tags
	       * so that we can perform the namespace checks
	       * correctly. */

	      var ALL_SVG_TAGS = addToSet({}, svg$1);
	      addToSet(ALL_SVG_TAGS, svgFilters);
	      addToSet(ALL_SVG_TAGS, svgDisallowed);
	      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
	      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
	      /**
	       *
	       *
	       * @param  {Element} element a DOM element whose namespace is being checked
	       * @returns {boolean} Return false if the element has a
	       *  namespace that a spec-compliant parser would never
	       *  return. Return true otherwise.
	       */

	      var _checkValidNamespace = function _checkValidNamespace(element) {
	        var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
	        // can be null. We just simulate parent in this case.

	        if (!parent || !parent.tagName) {
	          parent = {
	            namespaceURI: HTML_NAMESPACE,
	            tagName: 'template'
	          };
	        }

	        var tagName = stringToLowerCase(element.tagName);
	        var parentTagName = stringToLowerCase(parent.tagName);

	        if (element.namespaceURI === SVG_NAMESPACE) {
	          // The only way to switch from HTML namespace to SVG
	          // is via <svg>. If it happens via any other tag, then
	          // it should be killed.
	          if (parent.namespaceURI === HTML_NAMESPACE) {
	            return tagName === 'svg';
	          } // The only way to switch from MathML to SVG is via
	          // svg if parent is either <annotation-xml> or MathML
	          // text integration points.


	          if (parent.namespaceURI === MATHML_NAMESPACE) {
	            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
	          } // We only allow elements that are defined in SVG
	          // spec. All others are disallowed in SVG namespace.


	          return Boolean(ALL_SVG_TAGS[tagName]);
	        }

	        if (element.namespaceURI === MATHML_NAMESPACE) {
	          // The only way to switch from HTML namespace to MathML
	          // is via <math>. If it happens via any other tag, then
	          // it should be killed.
	          if (parent.namespaceURI === HTML_NAMESPACE) {
	            return tagName === 'math';
	          } // The only way to switch from SVG to MathML is via
	          // <math> and HTML integration points


	          if (parent.namespaceURI === SVG_NAMESPACE) {
	            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
	          } // We only allow elements that are defined in MathML
	          // spec. All others are disallowed in MathML namespace.


	          return Boolean(ALL_MATHML_TAGS[tagName]);
	        }

	        if (element.namespaceURI === HTML_NAMESPACE) {
	          // The only way to switch from SVG to HTML is via
	          // HTML integration points, and from MathML to HTML
	          // is via MathML text integration points
	          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
	            return false;
	          }

	          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
	            return false;
	          } // We disallow tags that are specific for MathML
	          // or SVG and should never appear in HTML namespace


	          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
	        } // The code should never reach this place (this means
	        // that the element somehow got namespace that is not
	        // HTML, SVG or MathML). Return false just in case.


	        return false;
	      };
	      /**
	       * _forceRemove
	       *
	       * @param  {Node} node a DOM node
	       */


	      var _forceRemove = function _forceRemove(node) {
	        arrayPush(DOMPurify.removed, {
	          element: node
	        });

	        try {
	          // eslint-disable-next-line unicorn/prefer-dom-node-remove
	          node.parentNode.removeChild(node);
	        } catch (_) {
	          try {
	            node.outerHTML = emptyHTML;
	          } catch (_) {
	            node.remove();
	          }
	        }
	      };
	      /**
	       * _removeAttribute
	       *
	       * @param  {String} name an Attribute name
	       * @param  {Node} node a DOM node
	       */


	      var _removeAttribute = function _removeAttribute(name, node) {
	        try {
	          arrayPush(DOMPurify.removed, {
	            attribute: node.getAttributeNode(name),
	            from: node
	          });
	        } catch (_) {
	          arrayPush(DOMPurify.removed, {
	            attribute: null,
	            from: node
	          });
	        }

	        node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

	        if (name === 'is' && !ALLOWED_ATTR[name]) {
	          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
	            try {
	              _forceRemove(node);
	            } catch (_) {}
	          } else {
	            try {
	              node.setAttribute(name, '');
	            } catch (_) {}
	          }
	        }
	      };
	      /**
	       * _initDocument
	       *
	       * @param  {String} dirty a string of dirty markup
	       * @return {Document} a DOM, filled with the dirty markup
	       */


	      var _initDocument = function _initDocument(dirty) {
	        /* Create a HTML document */
	        var doc;
	        var leadingWhitespace;

	        if (FORCE_BODY) {
	          dirty = '<remove></remove>' + dirty;
	        } else {
	          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
	          var matches = stringMatch(dirty, /^[\r\n\t ]+/);
	          leadingWhitespace = matches && matches[0];
	        }

	        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
	          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
	          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
	        }

	        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
	        /*
	         * Use the DOMParser API by default, fallback later if needs be
	         * DOMParser not work for svg when has multiple root element.
	         */

	        if (NAMESPACE === HTML_NAMESPACE) {
	          try {
	            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
	          } catch (_) {}
	        }
	        /* Use createHTMLDocument in case DOMParser is not available */


	        if (!doc || !doc.documentElement) {
	          doc = implementation.createDocument(NAMESPACE, 'template', null);

	          try {
	            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
	          } catch (_) {// Syntax error if dirtyPayload is invalid xml
	          }
	        }

	        var body = doc.body || doc.documentElement;

	        if (dirty && leadingWhitespace) {
	          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
	        }
	        /* Work on whole document or just its body */


	        if (NAMESPACE === HTML_NAMESPACE) {
	          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
	        }

	        return WHOLE_DOCUMENT ? doc.documentElement : body;
	      };
	      /**
	       * _createIterator
	       *
	       * @param  {Document} root document/fragment to create iterator for
	       * @return {Iterator} iterator instance
	       */


	      var _createIterator = function _createIterator(root) {
	        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
	        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
	      };
	      /**
	       * _isClobbered
	       *
	       * @param  {Node} elm element to check for clobbering attacks
	       * @return {Boolean} true if clobbered, false if safe
	       */


	      var _isClobbered = function _isClobbered(elm) {
	        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
	      };
	      /**
	       * _isNode
	       *
	       * @param  {Node} obj object to check whether it's a DOM node
	       * @return {Boolean} true is object is a DOM node
	       */


	      var _isNode = function _isNode(object) {
	        return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
	      };
	      /**
	       * _executeHook
	       * Execute user configurable hooks
	       *
	       * @param  {String} entryPoint  Name of the hook's entry point
	       * @param  {Node} currentNode node to work on with the hook
	       * @param  {Object} data additional hook parameters
	       */


	      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
	        if (!hooks[entryPoint]) {
	          return;
	        }

	        arrayForEach(hooks[entryPoint], function (hook) {
	          hook.call(DOMPurify, currentNode, data, CONFIG);
	        });
	      };
	      /**
	       * _sanitizeElements
	       *
	       * @protect nodeName
	       * @protect textContent
	       * @protect removeChild
	       *
	       * @param   {Node} currentNode to check for permission to exist
	       * @return  {Boolean} true if node was killed, false if left alive
	       */


	      var _sanitizeElements = function _sanitizeElements(currentNode) {
	        var content;
	        /* Execute a hook if present */

	        _executeHook('beforeSanitizeElements', currentNode, null);
	        /* Check if element is clobbered or can clobber */


	        if (_isClobbered(currentNode)) {
	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Check if tagname contains Unicode */


	        if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Now let's check the element's type and name */


	        var tagName = transformCaseFunc(currentNode.nodeName);
	        /* Execute a hook if present */

	        _executeHook('uponSanitizeElement', currentNode, {
	          tagName: tagName,
	          allowedTags: ALLOWED_TAGS
	        });
	        /* Detect mXSS attempts abusing namespace confusion */


	        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Mitigate a problem with templates inside select */


	        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Remove element if anything forbids its presence */


	        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
	          /* Check if we have a custom element to handle */
	          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
	            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
	            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
	          }
	          /* Keep content except for bad-listed elements */


	          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
	            var parentNode = getParentNode(currentNode) || currentNode.parentNode;
	            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

	            if (childNodes && parentNode) {
	              var childCount = childNodes.length;

	              for (var i = childCount - 1; i >= 0; --i) {
	                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
	              }
	            }
	          }

	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Check whether element has a valid namespace */


	        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
	          _forceRemove(currentNode);

	          return true;
	        }

	        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
	          _forceRemove(currentNode);

	          return true;
	        }
	        /* Sanitize element content to be template-safe */


	        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
	          /* Get the element's text content */
	          content = currentNode.textContent;
	          content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
	          content = stringReplace(content, ERB_EXPR$1, ' ');

	          if (currentNode.textContent !== content) {
	            arrayPush(DOMPurify.removed, {
	              element: currentNode.cloneNode()
	            });
	            currentNode.textContent = content;
	          }
	        }
	        /* Execute a hook if present */


	        _executeHook('afterSanitizeElements', currentNode, null);

	        return false;
	      };
	      /**
	       * _isValidAttribute
	       *
	       * @param  {string} lcTag Lowercase tag name of containing element.
	       * @param  {string} lcName Lowercase attribute name.
	       * @param  {string} value Attribute value.
	       * @return {Boolean} Returns true if `value` is valid, otherwise false.
	       */
	      // eslint-disable-next-line complexity


	      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
	        /* Make sure attribute cannot clobber */
	        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
	          return false;
	        }
	        /* Allow valid data-* attributes: At least one character after "-"
	            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
	            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
	            We don't need to check the value; it's always URI safe. */


	        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
	          if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
	          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
	          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
	          _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
	          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
	          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {
	            return false;
	          }
	          /* Check value is safe. First, is attr inert? If so, is safe */
	        } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ;else if (!value) ;else {
	          return false;
	        }
	        return true;
	      };
	      /**
	       * _basicCustomElementCheck
	       * checks if at least one dash is included in tagName, and it's not the first char
	       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
	       * @param {string} tagName name of the tag of the node to sanitize
	       */


	      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
	        return tagName.indexOf('-') > 0;
	      };
	      /**
	       * _sanitizeAttributes
	       *
	       * @protect attributes
	       * @protect nodeName
	       * @protect removeAttribute
	       * @protect setAttribute
	       *
	       * @param  {Node} currentNode to sanitize
	       */


	      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
	        var attr;
	        var value;
	        var lcName;
	        var l;
	        /* Execute a hook if present */

	        _executeHook('beforeSanitizeAttributes', currentNode, null);

	        var attributes = currentNode.attributes;
	        /* Check if we have attributes; if not we might have a text node */

	        if (!attributes) {
	          return;
	        }

	        var hookEvent = {
	          attrName: '',
	          attrValue: '',
	          keepAttr: true,
	          allowedAttributes: ALLOWED_ATTR
	        };
	        l = attributes.length;
	        /* Go backwards over all attributes; safely remove bad ones */

	        while (l--) {
	          attr = attributes[l];
	          var _attr = attr,
	              name = _attr.name,
	              namespaceURI = _attr.namespaceURI;
	          value = name === 'value' ? attr.value : stringTrim(attr.value);
	          lcName = transformCaseFunc(name);
	          /* Execute a hook if present */

	          hookEvent.attrName = lcName;
	          hookEvent.attrValue = value;
	          hookEvent.keepAttr = true;
	          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

	          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

	          value = hookEvent.attrValue;
	          /* Did the hooks approve of the attribute? */

	          if (hookEvent.forceKeepAttr) {
	            continue;
	          }
	          /* Remove attribute */


	          _removeAttribute(name, currentNode);
	          /* Did the hooks approve of the attribute? */


	          if (!hookEvent.keepAttr) {
	            continue;
	          }
	          /* Work around a security issue in jQuery 3.0 */


	          if (regExpTest(/\/>/i, value)) {
	            _removeAttribute(name, currentNode);

	            continue;
	          }
	          /* Sanitize attribute content to be template-safe */


	          if (SAFE_FOR_TEMPLATES) {
	            value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
	            value = stringReplace(value, ERB_EXPR$1, ' ');
	          }
	          /* Is `value` valid for this attribute? */


	          var lcTag = transformCaseFunc(currentNode.nodeName);

	          if (!_isValidAttribute(lcTag, lcName, value)) {
	            continue;
	          }
	          /* Handle attributes that require Trusted Types */


	          if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
	            if (namespaceURI) ;else {
	              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
	                case 'TrustedHTML':
	                  value = trustedTypesPolicy.createHTML(value);
	                  break;

	                case 'TrustedScriptURL':
	                  value = trustedTypesPolicy.createScriptURL(value);
	                  break;
	              }
	            }
	          }
	          /* Handle invalid data-* attribute set by try-catching it */


	          try {
	            if (namespaceURI) {
	              currentNode.setAttributeNS(namespaceURI, name, value);
	            } else {
	              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
	              currentNode.setAttribute(name, value);
	            }

	            arrayPop(DOMPurify.removed);
	          } catch (_) {}
	        }
	        /* Execute a hook if present */


	        _executeHook('afterSanitizeAttributes', currentNode, null);
	      };
	      /**
	       * _sanitizeShadowDOM
	       *
	       * @param  {DocumentFragment} fragment to iterate over recursively
	       */


	      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
	        var shadowNode;

	        var shadowIterator = _createIterator(fragment);
	        /* Execute a hook if present */


	        _executeHook('beforeSanitizeShadowDOM', fragment, null);

	        while (shadowNode = shadowIterator.nextNode()) {
	          /* Execute a hook if present */
	          _executeHook('uponSanitizeShadowNode', shadowNode, null);
	          /* Sanitize tags and elements */


	          if (_sanitizeElements(shadowNode)) {
	            continue;
	          }
	          /* Deep shadow DOM detected */


	          if (shadowNode.content instanceof DocumentFragment) {
	            _sanitizeShadowDOM(shadowNode.content);
	          }
	          /* Check attributes, sanitize if necessary */


	          _sanitizeAttributes(shadowNode);
	        }
	        /* Execute a hook if present */


	        _executeHook('afterSanitizeShadowDOM', fragment, null);
	      };
	      /**
	       * Sanitize
	       * Public method providing core sanitation functionality
	       *
	       * @param {String|Node} dirty string or DOM node
	       * @param {Object} configuration object
	       */
	      // eslint-disable-next-line complexity


	      DOMPurify.sanitize = function (dirty, cfg) {
	        var body;
	        var importedNode;
	        var currentNode;
	        var oldNode;
	        var returnNode;
	        /* Make sure we have a string to sanitize.
	          DO NOT return early, as this will return the wrong type if
	          the user has requested a DOM object rather than a string */

	        IS_EMPTY_INPUT = !dirty;

	        if (IS_EMPTY_INPUT) {
	          dirty = '<!-->';
	        }
	        /* Stringify, in case dirty is an object */


	        if (typeof dirty !== 'string' && !_isNode(dirty)) {
	          // eslint-disable-next-line no-negated-condition
	          if (typeof dirty.toString !== 'function') {
	            throw typeErrorCreate('toString is not a function');
	          } else {
	            dirty = dirty.toString();

	            if (typeof dirty !== 'string') {
	              throw typeErrorCreate('dirty is not a string, aborting');
	            }
	          }
	        }
	        /* Check we can run. Otherwise fall back or ignore */


	        if (!DOMPurify.isSupported) {
	          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
	            if (typeof dirty === 'string') {
	              return window.toStaticHTML(dirty);
	            }

	            if (_isNode(dirty)) {
	              return window.toStaticHTML(dirty.outerHTML);
	            }
	          }

	          return dirty;
	        }
	        /* Assign config vars */


	        if (!SET_CONFIG) {
	          _parseConfig(cfg);
	        }
	        /* Clean up removed elements */


	        DOMPurify.removed = [];
	        /* Check if dirty is correctly typed for IN_PLACE */

	        if (typeof dirty === 'string') {
	          IN_PLACE = false;
	        }

	        if (IN_PLACE) {
	          /* Do some early pre-sanitization to avoid unsafe root nodes */
	          if (dirty.nodeName) {
	            var tagName = transformCaseFunc(dirty.nodeName);

	            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
	              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
	            }
	          }
	        } else if (dirty instanceof Node) {
	          /* If dirty is a DOM element, append to an empty document to avoid
	             elements being stripped by the parser */
	          body = _initDocument('<!---->');
	          importedNode = body.ownerDocument.importNode(dirty, true);

	          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
	            /* Node is already a body, use as is */
	            body = importedNode;
	          } else if (importedNode.nodeName === 'HTML') {
	            body = importedNode;
	          } else {
	            // eslint-disable-next-line unicorn/prefer-dom-node-append
	            body.appendChild(importedNode);
	          }
	        } else {
	          /* Exit directly if we have nothing to do */
	          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
	          dirty.indexOf('<') === -1) {
	            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
	          }
	          /* Initialize the document to work on */


	          body = _initDocument(dirty);
	          /* Check we have a DOM node from the data */

	          if (!body) {
	            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
	          }
	        }
	        /* Remove first element node (ours) if FORCE_BODY is set */


	        if (body && FORCE_BODY) {
	          _forceRemove(body.firstChild);
	        }
	        /* Get node iterator */


	        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
	        /* Now start iterating over the created document */


	        while (currentNode = nodeIterator.nextNode()) {
	          /* Fix IE's strange behavior with manipulated textNodes #89 */
	          if (currentNode.nodeType === 3 && currentNode === oldNode) {
	            continue;
	          }
	          /* Sanitize tags and elements */


	          if (_sanitizeElements(currentNode)) {
	            continue;
	          }
	          /* Shadow DOM detected, sanitize it */


	          if (currentNode.content instanceof DocumentFragment) {
	            _sanitizeShadowDOM(currentNode.content);
	          }
	          /* Check attributes, sanitize if necessary */


	          _sanitizeAttributes(currentNode);

	          oldNode = currentNode;
	        }

	        oldNode = null;
	        /* If we sanitized `dirty` in-place, return it. */

	        if (IN_PLACE) {
	          return dirty;
	        }
	        /* Return sanitized string or DOM */


	        if (RETURN_DOM) {
	          if (RETURN_DOM_FRAGMENT) {
	            returnNode = createDocumentFragment.call(body.ownerDocument);

	            while (body.firstChild) {
	              // eslint-disable-next-line unicorn/prefer-dom-node-append
	              returnNode.appendChild(body.firstChild);
	            }
	          } else {
	            returnNode = body;
	          }

	          if (ALLOWED_ATTR.shadowroot) {
	            /*
	              AdoptNode() is not used because internal state is not reset
	              (e.g. the past names map of a HTMLFormElement), this is safe
	              in theory but we would rather not risk another attack vector.
	              The state that is cloned by importNode() is explicitly defined
	              by the specs.
	            */
	            returnNode = importNode.call(originalDocument, returnNode, true);
	          }

	          return returnNode;
	        }

	        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
	        /* Serialize doctype if allowed */

	        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
	          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
	        }
	        /* Sanitize final string template-safe */


	        if (SAFE_FOR_TEMPLATES) {
	          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
	          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
	        }

	        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
	      };
	      /**
	       * Public method to set the configuration once
	       * setConfig
	       *
	       * @param {Object} cfg configuration object
	       */


	      DOMPurify.setConfig = function (cfg) {
	        _parseConfig(cfg);

	        SET_CONFIG = true;
	      };
	      /**
	       * Public method to remove the configuration
	       * clearConfig
	       *
	       */


	      DOMPurify.clearConfig = function () {
	        CONFIG = null;
	        SET_CONFIG = false;
	      };
	      /**
	       * Public method to check if an attribute value is valid.
	       * Uses last set config, if any. Otherwise, uses config defaults.
	       * isValidAttribute
	       *
	       * @param  {string} tag Tag name of containing element.
	       * @param  {string} attr Attribute name.
	       * @param  {string} value Attribute value.
	       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
	       */


	      DOMPurify.isValidAttribute = function (tag, attr, value) {
	        /* Initialize shared config vars if necessary. */
	        if (!CONFIG) {
	          _parseConfig({});
	        }

	        var lcTag = transformCaseFunc(tag);
	        var lcName = transformCaseFunc(attr);
	        return _isValidAttribute(lcTag, lcName, value);
	      };
	      /**
	       * AddHook
	       * Public method to add DOMPurify hooks
	       *
	       * @param {String} entryPoint entry point for the hook to add
	       * @param {Function} hookFunction function to execute
	       */


	      DOMPurify.addHook = function (entryPoint, hookFunction) {
	        if (typeof hookFunction !== 'function') {
	          return;
	        }

	        hooks[entryPoint] = hooks[entryPoint] || [];
	        arrayPush(hooks[entryPoint], hookFunction);
	      };
	      /**
	       * RemoveHook
	       * Public method to remove a DOMPurify hook at a given entryPoint
	       * (pops it from the stack of hooks if more are present)
	       *
	       * @param {String} entryPoint entry point for the hook to remove
	       * @return {Function} removed(popped) hook
	       */


	      DOMPurify.removeHook = function (entryPoint) {
	        if (hooks[entryPoint]) {
	          return arrayPop(hooks[entryPoint]);
	        }
	      };
	      /**
	       * RemoveHooks
	       * Public method to remove all DOMPurify hooks at a given entryPoint
	       *
	       * @param  {String} entryPoint entry point for the hooks to remove
	       */


	      DOMPurify.removeHooks = function (entryPoint) {
	        if (hooks[entryPoint]) {
	          hooks[entryPoint] = [];
	        }
	      };
	      /**
	       * RemoveAllHooks
	       * Public method to remove all DOMPurify hooks
	       *
	       */


	      DOMPurify.removeAllHooks = function () {
	        hooks = {};
	      };

	      return DOMPurify;
	    }

	    var purify = createDOMPurify();
	    return purify;
	  });
	});

	var file$F = "src/widgets/message/media/ReaderView.svelte";

	function create_fragment$F(ctx) {
	  var div2;
	  var div1;
	  var div0;
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      div1 = element("div");
	      div0 = element("div");
	      attr_dev(div0, "class", "kai-option-menu-body svelte-jc6vbt");
	      attr_dev(div0, "data-pad-top", "26");
	      attr_dev(div0, "data-pad-bottom", "0");
	      add_location(div0, file$F, 55, 4, 1455);
	      attr_dev(div1, "class", "kai-option-menu-content svelte-jc6vbt");
	      add_location(div1, file$F, 54, 2, 1413);
	      attr_dev(div2, "class", "kai-option-menu svelte-jc6vbt");
	      add_location(div2, file$F, 53, 0, 1381);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div1);
	      append_dev(div1, div0);
	      div0.innerHTML =
	      /*template*/
	      ctx[0];
	      /*div0_binding*/

	      ctx[6](div0);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*template*/
	      1) div0.innerHTML =
	      /*template*/
	      ctx[0];
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      /*div0_binding*/

	      ctx[6](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$F.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$F($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('ReaderView', slots, []);
	  var _$$props$template = $$props.template,
	      template = _$$props$template === void 0 ? '' : _$$props$template;
	  var _$$props$onEnter = $$props.onEnter,
	      onEnter = _$$props$onEnter === void 0 ? evt => {} : _$$props$onEnter;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? evt => {} : _$$props$onBackspace;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  var nodeRef;
	  var navOptions = {
	    arrowUpListener(evt) {
	      $$invalidate(1, nodeRef.scrollTop -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      $$invalidate(1, nodeRef.scrollTop += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      $$invalidate(1, nodeRef.scrollLeft -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      $$invalidate(1, nodeRef.scrollLeft += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    enterListener(evt) {
	      if (onEnter == null) return;
	      onEnter(evt);
	    },

	    backspaceListener(evt) {
	      if (onBackspace == null) return;
	      onBackspace(evt);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {
	    navInstance.attachListener();
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    onClosed();
	  });
	  var writable_props = ['template', 'onEnter', 'onBackspace', 'onOpened', 'onClosed'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ReaderView> was created with unknown prop '${key}'`);
	  });

	  function div0_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(1, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('template' in $$props) $$invalidate(0, template = $$props.template);
	    if ('onEnter' in $$props) $$invalidate(2, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(3, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(4, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(5, onClosed = $$props.onClosed);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    template,
	    onEnter,
	    onBackspace,
	    onOpened,
	    onClosed,
	    nodeRef,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('template' in $$props) $$invalidate(0, template = $$props.template);
	    if ('onEnter' in $$props) $$invalidate(2, onEnter = $$props.onEnter);
	    if ('onBackspace' in $$props) $$invalidate(3, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(4, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(5, onClosed = $$props.onClosed);
	    if ('nodeRef' in $$props) $$invalidate(1, nodeRef = $$props.nodeRef);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [template, nodeRef, onEnter, onBackspace, onOpened, onClosed, div0_binding];
	}

	class ReaderView extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$F, create_fragment$F, not_equal, {
	      template: 0,
	      onEnter: 2,
	      onBackspace: 3,
	      onOpened: 4,
	      onClosed: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ReaderView",
	      options,
	      id: create_fragment$F.name
	    });
	  }

	  get template() {
	    return this.$$.ctx[0];
	  }

	  set template(template) {
	    this.$$set({
	      template
	    });
	    flush();
	  }

	  get onEnter() {
	    return this.$$.ctx[2];
	  }

	  set onEnter(onEnter) {
	    this.$$set({
	      onEnter
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[3];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[4];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[5];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	}

	var console_1$5 = globals.console;
	var file$E = "src/widgets/message/media/MessageMediaWebPage.svelte"; // (166:4) {#if message.media.webpage.siteName}

	function create_if_block_2$1(ctx) {
	  var h5;
	  var t_value =
	  /*message*/
	  ctx[0].media.webpage.siteName + "";
	  var t;
	  var block = {
	    c: function create() {
	      h5 = element("h5");
	      t = text(t_value);
	      attr_dev(h5, "class", "site-name svelte-1tifo30");
	      add_location(h5, file$E, 166, 4, 7001);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, h5, anchor);
	      append_dev(h5, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].media.webpage.siteName + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(h5);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$1.name,
	    type: "if",
	    source: "(166:4) {#if message.media.webpage.siteName}",
	    ctx
	  });
	  return block;
	} // (169:4) {#if message.media.webpage.title}


	function create_if_block_1$2(ctx) {
	  var p;
	  var t_value = (
	  /*message*/
	  ctx[0].media.webpage.title.length > 20 ?
	  /*message*/
	  ctx[0].media.webpage.title.substring(0, 20) + '...' :
	  /*message*/
	  ctx[0].media.webpage.title) + "";
	  var t;
	  var block = {
	    c: function create() {
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "title svelte-1tifo30");
	      add_location(p, file$E, 169, 4, 7113);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, p, anchor);
	      append_dev(p, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value = (
	      /*message*/
	      ctx[0].media.webpage.title.length > 20 ?
	      /*message*/
	      ctx[0].media.webpage.title.substring(0, 20) + '...' :
	      /*message*/
	      ctx[0].media.webpage.title) + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(p);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$2.name,
	    type: "if",
	    source: "(169:4) {#if message.media.webpage.title}",
	    ctx
	  });
	  return block;
	} // (172:4) {#if message.media.webpage.description}


	function create_if_block$5(ctx) {
	  var p;
	  var t_value = (
	  /*message*/
	  ctx[0].media.webpage.description.length > 50 ?
	  /*message*/
	  ctx[0].media.webpage.description.substring(0, 50) + '...' :
	  /*message*/
	  ctx[0].media.webpage.description) + "";
	  var t;
	  var block = {
	    c: function create() {
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "description svelte-1tifo30");
	      add_location(p, file$E, 172, 4, 7319);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, p, anchor);
	      append_dev(p, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value = (
	      /*message*/
	      ctx[0].media.webpage.description.length > 50 ?
	      /*message*/
	      ctx[0].media.webpage.description.substring(0, 50) + '...' :
	      /*message*/
	      ctx[0].media.webpage.description) + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(p);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$5.name,
	    type: "if",
	    source: "(172:4) {#if message.media.webpage.description}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$E(ctx) {
	  var div1;
	  var div0;
	  var t0;
	  var t1;
	  var if_block0 =
	  /*message*/
	  ctx[0].media.webpage.siteName && create_if_block_2$1(ctx);
	  var if_block1 =
	  /*message*/
	  ctx[0].media.webpage.title && create_if_block_1$2(ctx);
	  var if_block2 =
	  /*message*/
	  ctx[0].media.webpage.description && create_if_block$5(ctx);
	  var block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      if (if_block0) if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      if (if_block2) if_block2.c();
	      attr_dev(div0, "class", "quote svelte-1tifo30");
	      add_location(div0, file$E, 164, 2, 6936);
	      attr_dev(div1, "class", "media-container svelte-1tifo30");
	      add_location(div1, file$E, 163, 0, 6904);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      if (if_block0) if_block0.m(div0, null);
	      append_dev(div0, t0);
	      if (if_block1) if_block1.m(div0, null);
	      append_dev(div0, t1);
	      if (if_block2) if_block2.m(div0, null);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*message*/
	      ctx[0].media.webpage.siteName) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_2$1(ctx);
	          if_block0.c();
	          if_block0.m(div0, t0);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (
	      /*message*/
	      ctx[0].media.webpage.title) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block_1$2(ctx);
	          if_block1.c();
	          if_block1.m(div0, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (
	      /*message*/
	      ctx[0].media.webpage.description) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);
	        } else {
	          if_block2 = create_if_block$5(ctx);
	          if_block2.c();
	          if_block2.m(div0, null);
	        }
	      } else if (if_block2) {
	        if_block2.d(1);
	        if_block2 = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div1);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$E.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$E($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaWebPage', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var loadingBar;
	  var menu;
	  var reader;

	  function showLoadingBar() {
	    loadingBar = new LoadingBar({
	      target: document.body,
	      props: {
	        onOpened: () => {
	          parentNavInstance.detachListener();
	        },
	        onClosed: () => {
	          parentNavInstance.attachListener();
	          loadingBar = null;
	        }
	      }
	    });
	  }

	  function actionMenu() {
	    setTimeout(() => {
	      var _menu = [{
	        title: 'Open with Reader View'
	      }, {
	        title: 'Open in In-App Browser'
	      }, {
	        title: 'Open in Browser'
	      }];
	      menu = new OptionMenu({
	        target: document.body,
	        props: {
	          title: 'Action Menu',
	          focusIndex: 0,
	          options: _menu,
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => {
	            menu.$destroy();

	            if (scope.selected.title === 'Open in In-App Browser') {
	              window.open(message.media.webpage.url);
	            } else if (scope.selected.title === 'Open in Browser') {
	              window.open(message.media.webpage.url, '_blank').focus();
	            } else if (scope.selected.title === 'Open with Reader View') {
	              getReaderable();
	            }
	          },
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            menu.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: scope => {
	            parentNavInstance.attachListener();
	            menu = null;
	          }
	        }
	      });
	    }, 100);
	  }

	  function openReader(title, template) {
	    setTimeout(() => {
	      reader = new ReaderView({
	        target: document.body,
	        props: {
	          template,
	          onEnter: evt => {},
	          onBackspace: evt => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            reader.$destroy();
	          },
	          onOpened: () => {
	            parentNavInstance.detachListener();
	          },
	          onClosed: () => {
	            parentNavInstance.attachListener();
	            reader = null;
	          }
	        }
	      });
	    }, 100);
	  }

	  function getReaderable() {
	    return __awaiter(this, void 0, void 0, function* () {
	      var webpageId = message.media.webpage.id.value.toString();
	      var cached = yield (yield cachedDatabase).get('offlineWebpages', webpageId);

	      if (cached != null) {
	        var sanitizedContent = purify.sanitize(cached);
	        openReader('Reader View', sanitizedContent);
	        return;
	      }

	      if (loadingBar == null) showLoadingBar();
	      var xhttp = new XMLHttpRequest({
	        mozSystem: true
	      });

	      xhttp.onreadystatechange = function () {
	        return __awaiter(this, void 0, void 0, function* () {
	          if (xhttp.readyState == 4 && xhttp.status == 200) {
	            var parser = new DOMParser();

	            try {
	              var doc = parser.parseFromString(xhttp.responseText, "text/html");

	              if (readability.isProbablyReaderable(doc)) {
	                var url = new URL(message.media.webpage.url);
	                var result = new readability.Readability(doc).parse();
	                result.content = result.content.replace(/(<img[^>]*?) *\/?>/g, '$1 style="width:100%;height:auto;" />');
	                result.content = result.content.replaceAll(document.location.origin, url.origin);
	                result.content = `<style>img{}</style><h4 style="margin-top:0px;padding-top:0px;">${message.media.webpage.title}</h4>` + result.content;
	                yield (yield cachedDatabase).put('offlineWebpages', result.content, webpageId);

	                var _sanitizedContent = purify.sanitize(result.content);

	                openReader('Reader View', _sanitizedContent);
	                if (loadingBar) loadingBar.$destroy();
	              } else {
	                console.log('notReaderable');
	                if (loadingBar) loadingBar.$destroy();
	              }
	            } catch (e) {
	              console.log(e);
	              if (loadingBar) loadingBar.$destroy();
	            }
	          } else if (xhttp.readyState == 4 && xhttp.status != 200) {
	            console.log(xhttp.status);
	            if (loadingBar) loadingBar.$destroy();
	          }
	        });
	      };

	      xhttp.open("GET", `https://api.codetabs.com/v1/proxy/?quest=${message.media.webpage.url}`, true);
	      xhttp.send();
	    });
	  }

	  onMount(() => {
	    // console.log(message.media);
	    // .webpage: description, displayUrl, siteName, title, url, cachedPage(instantview)
	    registerCallButtonHandler(message.id.toString(), actionMenu);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<MessageMediaWebPage> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    cachedDatabase,
	    Readability: readability.Readability,
	    isProbablyReaderable: readability.isProbablyReaderable,
	    DOMPurify: purify,
	    OptionMenu,
	    LoadingBar,
	    ReaderView,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    loadingBar,
	    menu,
	    reader,
	    showLoadingBar,
	    actionMenu,
	    openReader,
	    getReaderable
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	    if ('loadingBar' in $$props) loadingBar = $$props.loadingBar;
	    if ('menu' in $$props) menu = $$props.menu;
	    if ('reader' in $$props) reader = $$props.reader;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaWebPage extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$E, create_fragment$E, not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaWebPage",
	      options,
	      id: create_fragment$E.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console_1$5.warn("<MessageMediaWebPage> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$D = "src/widgets/message/media/MessageMediaUnsupported.svelte";

	function create_fragment$D(ctx) {
	  var div;
	  var span;
	  var t_value =
	  /*message*/
	  ctx[0].media.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      t = text(t_value);
	      set_style(span, "color", "#A20000");
	      add_location(span, file$D, 16, 2, 469);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$D, 15, 0, 437);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	      append_dev(span, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].media.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$D.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu$1() {}

	function instance$D($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageMediaUnsupported', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu$1);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageMediaUnsupported> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu: actionMenu$1
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageMediaUnsupported extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$D, create_fragment$D, not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageMediaUnsupported",
	      options,
	      id: create_fragment$D.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageMediaUnsupported> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$C = "src/widgets/message/media/Dummy.svelte";

	function create_fragment$C(ctx) {
	  var div;
	  var span;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[0].media.className + "";
	  var t1;
	  var block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      t0 = text("Unsupported: ");
	      t1 = text(t1_value);
	      set_style(span, "color", "#A20000");
	      add_location(span, file$C, 16, 2, 469);
	      attr_dev(div, "class", "media-container svelte-16i9emv");
	      add_location(div, file$C, 15, 0, 437);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	      append_dev(span, t0);
	      append_dev(span, t1);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value =
	      /*message*/
	      ctx[0].media.className + "")) set_data_dev(t1, t1_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$C.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function actionMenu() {}

	function instance$C($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Dummy', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {
	    registerCallButtonHandler(message.id.toString(), actionMenu);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dummy> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    actionMenu
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Dummy$1 extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$C, create_fragment$C, not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Dummy",
	      options,
	      id: create_fragment$C.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<Dummy> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var Media = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MessageMediaDocument: index,
		MessageMediaGeoLive: MessageMediaGeoLive,
		MessageMediaEmpty: MessageMediaEmpty,
		MessageMediaPhoto: MessageMediaPhoto,
		MessageMediaGeo: MessageMediaGeo,
		MessageMediaPoll: MessageMediaPoll,
		MessageMediaVenue: MessageMediaVenue,
		MessageMediaGame: MessageMediaGame,
		MessageMediaInvoice: MessageMediaInvoice,
		MessageMediaDice: MessageMediaDice,
		MessageMediaContact: MessageMediaContact,
		MessageMediaWebPage: MessageMediaWebPage,
		MessageMediaUnsupported: MessageMediaUnsupported,
		Dummy: Dummy$1
	});

	/* src/widgets/message/Message.svelte generated by Svelte v3.46.4 */
	var console_1$4 = globals.console;
	var file$B = "src/widgets/message/Message.svelte"; // (265:2) {#if hasAvatar && !chat.isUser }

	function create_if_block_14(ctx) {
	  var html_tag;
	  var raw_value = purify.sanitize(
	  /*avatarSrc*/
	  ctx[14]) + "";
	  var html_anchor;
	  var block = {
	    c: function create() {
	      html_tag = new HtmlTag();
	      html_anchor = empty();
	      html_tag.a = html_anchor;
	    },
	    m: function mount(target, anchor) {
	      html_tag.m(raw_value, target, anchor);
	      insert_dev(target, html_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*avatarSrc*/
	      16384 && raw_value !== (raw_value = purify.sanitize(
	      /*avatarSrc*/
	      ctx[14]) + "")) html_tag.p(raw_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(html_anchor);
	      if (detaching) html_tag.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_14.name,
	    type: "if",
	    source: "(265:2) {#if hasAvatar && !chat.isUser }",
	    ctx
	  });
	  return block;
	} // (266:2) {#if !self && chat.entity.__isSavedMessages }


	function create_if_block_13(ctx) {
	  var html_tag;
	  var raw_value = purify.sanitize(
	  /*avatarSrc*/
	  ctx[14]) + "";
	  var html_anchor;
	  var block = {
	    c: function create() {
	      html_tag = new HtmlTag();
	      html_anchor = empty();
	      html_tag.a = html_anchor;
	    },
	    m: function mount(target, anchor) {
	      html_tag.m(raw_value, target, anchor);
	      insert_dev(target, html_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*avatarSrc*/
	      16384 && raw_value !== (raw_value = purify.sanitize(
	      /*avatarSrc*/
	      ctx[14]) + "")) html_tag.p(raw_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(html_anchor);
	      if (detaching) html_tag.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_13.name,
	    type: "if",
	    source: "(266:2) {#if !self && chat.entity.__isSavedMessages }",
	    ctx
	  });
	  return block;
	} // (270:30) 


	function create_if_block_12(ctx) {
	  var b;
	  var t0;
	  var t1_value = (
	  /*fullName*/
	  ctx[16] ||
	  /*getFullname*/
	  ctx[22](
	  /*message*/
	  ctx[2])) + "";
	  var t1;
	  var block = {
	    c: function create() {
	      b = element("b");
	      t0 = text(
	      /*forwardedPrefix*/
	      ctx[17]);
	      t1 = text(t1_value);
	      add_location(b, file$B, 270, 6, 10639);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, b, anchor);
	      append_dev(b, t0);
	      append_dev(b, t1);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*forwardedPrefix*/
	      131072) set_data_dev(t0,
	      /*forwardedPrefix*/
	      ctx[17]);
	      if (dirty[0] &
	      /*fullName, message*/
	      65540 && t1_value !== (t1_value = (
	      /*fullName*/
	      ctx[16] ||
	      /*getFullname*/
	      ctx[22](
	      /*message*/
	      ctx[2])) + "")) set_data_dev(t1, t1_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(b);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_12.name,
	    type: "if",
	    source: "(270:30) ",
	    ctx
	  });
	  return block;
	} // (268:4) {#if hasAvatar && !self && !chat.isUser}


	function create_if_block_11(ctx) {
	  var b;
	  var t_value = (
	  /*fullName*/
	  ctx[16] ||
	  /*getFullname*/
	  ctx[22](
	  /*message*/
	  ctx[2])) + "";
	  var t;
	  var block = {
	    c: function create() {
	      b = element("b");
	      t = text(t_value);
	      add_location(b, file$B, 268, 6, 10560);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, b, anchor);
	      append_dev(b, t);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*fullName, message*/
	      65540 && t_value !== (t_value = (
	      /*fullName*/
	      ctx[16] ||
	      /*getFullname*/
	      ctx[22](
	      /*message*/
	      ctx[2])) + "")) set_data_dev(t, t_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(b);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_11.name,
	    type: "if",
	    source: "(268:4) {#if hasAvatar && !self && !chat.isUser}",
	    ctx
	  });
	  return block;
	} // (273:4) {#if replyTo && replyTo !== false && replyTo.id && replyThreadId !== replyTo.id }


	function create_if_block_9(ctx) {
	  var div;

	  function select_block_type_1(ctx, dirty) {
	    if (
	    /*replyTo*/
	    ctx[8] === -1) return create_if_block_10;
	    return create_else_block$1;
	  }

	  var current_block_type = select_block_type_1(ctx);
	  var if_block = current_block_type(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      if_block.c();
	      attr_dev(div, "class", "reply-box svelte-1o4zint");
	      add_location(div, file$B, 273, 6, 10800);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if_block.m(div, null);
	    },
	    p: function update(ctx, dirty) {
	      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(div, null);
	        }
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_9.name,
	    type: "if",
	    source: "(273:4) {#if replyTo && replyTo !== false && replyTo.id && replyThreadId !== replyTo.id }",
	    ctx
	  });
	  return block;
	} // (277:6) {:else}


	function create_else_block$1(ctx) {
	  var html_tag;
	  var raw_value = purify.sanitize(
	  /*renderReplyHeader*/
	  ctx[21](
	  /*replyTo*/
	  ctx[8])) + "";
	  var html_anchor;
	  var block = {
	    c: function create() {
	      html_tag = new HtmlTag();
	      html_anchor = empty();
	      html_tag.a = html_anchor;
	    },
	    m: function mount(target, anchor) {
	      html_tag.m(raw_value, target, anchor);
	      insert_dev(target, html_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*replyTo*/
	      256 && raw_value !== (raw_value = purify.sanitize(
	      /*renderReplyHeader*/
	      ctx[21](
	      /*replyTo*/
	      ctx[8])) + "")) html_tag.p(raw_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(html_anchor);
	      if (detaching) html_tag.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$1.name,
	    type: "else",
	    source: "(277:6) {:else}",
	    ctx
	  });
	  return block;
	} // (275:6) {#if replyTo === -1}


	function create_if_block_10(ctx) {
	  var small;
	  var block = {
	    c: function create() {
	      small = element("small");
	      small.textContent = "Deleted";
	      add_location(small, file$B, 275, 8, 10859);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	    },
	    p: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_10.name,
	    type: "if",
	    source: "(275:6) {#if replyTo === -1}",
	    ctx
	  });
	  return block;
	} // (282:4) {#if hasMedia }


	function create_if_block_8(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value =
	  /*mediaWidget*/
	  ctx[20];

	  function switch_props(ctx) {
	    return {
	      props: {
	        chat:
	        /*chat*/
	        ctx[1],
	        message:
	        /*message*/
	        ctx[2],
	        parentNavInstance:
	        /*parentNavInstance*/
	        ctx[5],
	        registerCallButtonHandler:
	        /*registerCallButtonHandler*/
	        ctx[6],
	        refetchMessage:
	        /*refetchMessage*/
	        ctx[7]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty[0] &
	      /*chat*/
	      2) switch_instance_changes.chat =
	      /*chat*/
	      ctx[1];
	      if (dirty[0] &
	      /*message*/
	      4) switch_instance_changes.message =
	      /*message*/
	      ctx[2];
	      if (dirty[0] &
	      /*parentNavInstance*/
	      32) switch_instance_changes.parentNavInstance =
	      /*parentNavInstance*/
	      ctx[5];
	      if (dirty[0] &
	      /*registerCallButtonHandler*/
	      64) switch_instance_changes.registerCallButtonHandler =
	      /*registerCallButtonHandler*/
	      ctx[6];
	      if (dirty[0] &
	      /*refetchMessage*/
	      128) switch_instance_changes.refetchMessage =
	      /*refetchMessage*/
	      ctx[7];

	      if (switch_value !== (switch_value =
	      /*mediaWidget*/
	      ctx[20])) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_8.name,
	    type: "if",
	    source: "(282:4) {#if hasMedia }",
	    ctx
	  });
	  return block;
	} // (285:4) {#if message.message }


	function create_if_block_7(ctx) {
	  var p;
	  var raw_value = purify.sanitize(
	  /*message*/
	  ctx[2].message.length > 80 &&
	  /*short*/
	  ctx[9] ?
	  /*message*/
	  ctx[2].message.substring(0, 80) + '...&#13;<i style="font-size:12px;">(see more)</i>' :
	  /*message*/
	  ctx[2].message) + "";
	  var block = {
	    c: function create() {
	      p = element("p");
	      attr_dev(p, "class", "svelte-1o4zint");
	      add_location(p, file$B, 285, 6, 11184);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, p, anchor);
	      p.innerHTML = raw_value;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*message, short*/
	      516 && raw_value !== (raw_value = purify.sanitize(
	      /*message*/
	      ctx[2].message.length > 80 &&
	      /*short*/
	      ctx[9] ?
	      /*message*/
	      ctx[2].message.substring(0, 80) + '...&#13;<i style="font-size:12px;">(see more)</i>' :
	      /*message*/
	      ctx[2].message) + "")) p.innerHTML = raw_value;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(p);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_7.name,
	    type: "if",
	    source: "(285:4) {#if message.message }",
	    ctx
	  });
	  return block;
	} // (289:6) {#if message.media && message.media.webpage}


	function create_if_block_6(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "buttons");
	      if (!src_url_equal(img.src, img_src_value = "/icons/globe.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 289, 29, 11481);
	      attr_dev(small, "class", "buttons");
	      add_location(small, file$B, 289, 6, 11458);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_6.name,
	    type: "if",
	    source: "(289:6) {#if message.media && message.media.webpage}",
	    ctx
	  });
	  return block;
	} // (292:6) {#if message.replyMarkup && message.replyMarkup.rows}


	function create_if_block_5(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "buttons");
	      if (!src_url_equal(img.src, img_src_value = "/icons/keyboard.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 292, 29, 11668);
	      attr_dev(small, "class", "buttons");
	      add_location(small, file$B, 292, 6, 11645);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_5.name,
	    type: "if",
	    source: "(292:6) {#if message.replyMarkup && message.replyMarkup.rows}",
	    ctx
	  });
	  return block;
	} // (295:6) {#if message.pinned}


	function create_if_block_4(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t = text(";");
	      attr_dev(img, "alt", "pinned");
	      if (!src_url_equal(img.src, img_src_value = "/icons/pinned.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 295, 28, 11824);
	      attr_dev(small, "class", "pinned");
	      add_location(small, file$B, 295, 6, 11802);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_4.name,
	    type: "if",
	    source: "(295:6) {#if message.pinned}",
	    ctx
	  });
	  return block;
	} // (298:6) {#if message.views}


	function create_if_block_3(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[2].views + "";
	  var t1;
	  var t2;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t0 = text("");
	      t1 = text(t1_value);
	      t2 = text("");
	      attr_dev(img, "alt", "views");
	      if (!src_url_equal(img.src, img_src_value = "/icons/eye.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 298, 27, 11976);
	      attr_dev(small, "class", "views");
	      add_location(small, file$B, 298, 6, 11955);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t0);
	      append_dev(small, t1);
	      append_dev(small, t2);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*message*/
	      4 && t1_value !== (t1_value =
	      /*message*/
	      ctx[2].views + "")) set_data_dev(t1, t1_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_3.name,
	    type: "if",
	    source: "(298:6) {#if message.views}",
	    ctx
	  });
	  return block;
	} // (301:6) {#if message.editDate && message.editHide == false}


	function create_if_block_2(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t = text("");
	      attr_dev(img, "alt", "edited");
	      if (!src_url_equal(img.src, img_src_value = "/icons/edited.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 301, 28, 12177);
	      attr_dev(small, "class", "edited");
	      add_location(small, file$B, 301, 6, 12155);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2.name,
	    type: "if",
	    source: "(301:6) {#if message.editDate && message.editHide == false}",
	    ctx
	  });
	  return block;
	} // (304:6) {#if message.replies && message.replies.replies > 0}


	function create_if_block_1$1(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[2].replies.replies + "";
	  var t1;
	  var t2;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t0 = text("");
	      t1 = text(t1_value);
	      t2 = text("");
	      attr_dev(img, "alt", "reply");
	      if (!src_url_equal(img.src, img_src_value = "/icons/reply.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 304, 27, 12361);
	      attr_dev(small, "class", "reply");
	      add_location(small, file$B, 304, 6, 12340);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t0);
	      append_dev(small, t1);
	      append_dev(small, t2);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*message*/
	      4 && t1_value !== (t1_value =
	      /*message*/
	      ctx[2].replies.replies + "")) set_data_dev(t1, t1_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$1.name,
	    type: "if",
	    source: "(304:6) {#if message.replies && message.replies.replies > 0}",
	    ctx
	  });
	  return block;
	} // (307:6) {#if message.forwards && message.forwards > 0}


	function create_if_block$4(ctx) {
	  var small;
	  var img;
	  var img_src_value;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[2].forwards + "";
	  var t1;
	  var t2;
	  var block = {
	    c: function create() {
	      small = element("small");
	      img = element("img");
	      t0 = text("");
	      t1 = text(t1_value);
	      t2 = text("");
	      attr_dev(img, "alt", "forwards");
	      if (!src_url_equal(img.src, img_src_value = "/icons/forward.svg")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "width", "10px");
	      attr_dev(img, "height", "10px");
	      add_location(img, file$B, 307, 30, 12571);
	      attr_dev(small, "class", "forwards");
	      add_location(small, file$B, 307, 6, 12547);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, small, anchor);
	      append_dev(small, img);
	      append_dev(small, t0);
	      append_dev(small, t1);
	      append_dev(small, t2);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*message*/
	      4 && t1_value !== (t1_value =
	      /*message*/
	      ctx[2].forwards + "")) set_data_dev(t1, t1_value);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(small);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$4.name,
	    type: "if",
	    source: "(307:6) {#if message.forwards && message.forwards > 0}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$B(ctx) {
	  var div2;
	  var t0;
	  var t1;
	  var div1;
	  var t2;
	  var t3;
	  var t4;
	  var t5;
	  var div0;
	  var t6;
	  var t7;
	  var t8;
	  var t9;
	  var t10;
	  var t11;
	  var t12;
	  var small;
	  var t13_value =
	  /*getTime*/
	  ctx[23](
	  /*message*/
	  ctx[2]) + "";
	  var t13;
	  var div2_class_value;
	  var div2_style_value;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block0 =
	  /*hasAvatar*/
	  ctx[13] && !
	  /*chat*/
	  ctx[1].isUser && create_if_block_14(ctx);
	  var if_block1 = !
	  /*self*/
	  ctx[12] &&
	  /*chat*/
	  ctx[1].entity.__isSavedMessages && create_if_block_13(ctx);

	  function select_block_type(ctx, dirty) {
	    if (
	    /*hasAvatar*/
	    ctx[13] && !
	    /*self*/
	    ctx[12] && !
	    /*chat*/
	    ctx[1].isUser) return create_if_block_11;
	    if (
	    /*message*/
	    ctx[2].fwdFrom) return create_if_block_12;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block2 = current_block_type && current_block_type(ctx);
	  var if_block3 =
	  /*replyTo*/
	  ctx[8] &&
	  /*replyTo*/
	  ctx[8] !== false &&
	  /*replyTo*/
	  ctx[8].id &&
	  /*replyThreadId*/
	  ctx[10] !==
	  /*replyTo*/
	  ctx[8].id && create_if_block_9(ctx);
	  var if_block4 =
	  /*hasMedia*/
	  ctx[19] && create_if_block_8(ctx);
	  var if_block5 =
	  /*message*/
	  ctx[2].message && create_if_block_7(ctx);
	  var if_block6 =
	  /*message*/
	  ctx[2].media &&
	  /*message*/
	  ctx[2].media.webpage && create_if_block_6(ctx);
	  var if_block7 =
	  /*message*/
	  ctx[2].replyMarkup &&
	  /*message*/
	  ctx[2].replyMarkup.rows && create_if_block_5(ctx);
	  var if_block8 =
	  /*message*/
	  ctx[2].pinned && create_if_block_4(ctx);
	  var if_block9 =
	  /*message*/
	  ctx[2].views && create_if_block_3(ctx);
	  var if_block10 =
	  /*message*/
	  ctx[2].editDate &&
	  /*message*/
	  ctx[2].editHide == false && create_if_block_2(ctx);
	  var if_block11 =
	  /*message*/
	  ctx[2].replies &&
	  /*message*/
	  ctx[2].replies.replies > 0 && create_if_block_1$1(ctx);
	  var if_block12 =
	  /*message*/
	  ctx[2].forwards &&
	  /*message*/
	  ctx[2].forwards > 0 && create_if_block$4(ctx);
	  var block = {
	    c: function create() {
	      div2 = element("div");
	      if (if_block0) if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      div1 = element("div");
	      if (if_block2) if_block2.c();
	      t2 = space();
	      if (if_block3) if_block3.c();
	      t3 = space();
	      if (if_block4) if_block4.c();
	      t4 = space();
	      if (if_block5) if_block5.c();
	      t5 = space();
	      div0 = element("div");
	      if (if_block6) if_block6.c();
	      t6 = space();
	      if (if_block7) if_block7.c();
	      t7 = space();
	      if (if_block8) if_block8.c();
	      t8 = space();
	      if (if_block9) if_block9.c();
	      t9 = space();
	      if (if_block10) if_block10.c();
	      t10 = space();
	      if (if_block11) if_block11.c();
	      t11 = space();
	      if (if_block12) if_block12.c();
	      t12 = space();
	      small = element("small");
	      t13 = text(t13_value);
	      attr_dev(small, "class", "time");
	      add_location(small, file$B, 309, 6, 12702);
	      attr_dev(div0, "class", "indicator svelte-1o4zint");
	      add_location(div0, file$B, 287, 4, 11377);
	      attr_dev(div1, "class", "kai-list-view-content svelte-1o4zint");
	      set_style(div1, "margin-left",
	      /*hasAvatar*/
	      ctx[13] && !
	      /*chat*/
	      ctx[1].isUser || !
	      /*self*/
	      ctx[12] &&
	      /*chat*/
	      ctx[1].entity.__isSavedMessages ? '45px' : '0px');
	      add_location(div1, file$B, 266, 2, 10363);
	      attr_dev(div2, "data-key",
	      /*key*/
	      ctx[0]);
	      attr_dev(div2, "class", div2_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-1o4zint");
	      attr_dev(div2, "style", div2_style_value = "background-color:" + (!
	      /*short*/
	      ctx[9] ? 'var(--themeColorLight)' : 'inherit') + ";" + (
	      /*showFull*/
	      ctx[18] ? 'height' : 'min-height') + ":" + (!
	      /*short*/
	      ctx[9] ? '92%' : 'auto') + ";overflow:" + (!
	      /*short*/
	      ctx[9] ? 'scroll' : 'inherit') + ";justify-content:" + (
	      /*chat*/
	      ctx[1].entity.className === 'Channel' && !
	      /*chat*/
	      ctx[1].entity.megagroup ? 'start' :
	      /*justifyContent*/
	      ctx[15]) + ";min-height:" + (
	      /*hasAvatar*/
	      ctx[13] ? '50px' : '0px') + ";");
	      add_location(div2, file$B, 263, 0, 9756);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      if (if_block0) if_block0.m(div2, null);
	      append_dev(div2, t0);
	      if (if_block1) if_block1.m(div2, null);
	      append_dev(div2, t1);
	      append_dev(div2, div1);
	      if (if_block2) if_block2.m(div1, null);
	      append_dev(div1, t2);
	      if (if_block3) if_block3.m(div1, null);
	      append_dev(div1, t3);
	      if (if_block4) if_block4.m(div1, null);
	      append_dev(div1, t4);
	      if (if_block5) if_block5.m(div1, null);
	      append_dev(div1, t5);
	      append_dev(div1, div0);
	      if (if_block6) if_block6.m(div0, null);
	      append_dev(div0, t6);
	      if (if_block7) if_block7.m(div0, null);
	      append_dev(div0, t7);
	      if (if_block8) if_block8.m(div0, null);
	      append_dev(div0, t8);
	      if (if_block9) if_block9.m(div0, null);
	      append_dev(div0, t9);
	      if (if_block10) if_block10.m(div0, null);
	      append_dev(div0, t10);
	      if (if_block11) if_block11.m(div0, null);
	      append_dev(div0, t11);
	      if (if_block12) if_block12.m(div0, null);
	      append_dev(div0, t12);
	      append_dev(div0, small);
	      append_dev(small, t13);
	      /*div2_binding*/

	      ctx[26](div2);
	      current = true;

	      if (!mounted) {
	        dispose = listen_dev(div2, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[4]))
	            /*onClick*/
	            ctx[4].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;

	      if (
	      /*hasAvatar*/
	      ctx[13] && !
	      /*chat*/
	      ctx[1].isUser) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_14(ctx);
	          if_block0.c();
	          if_block0.m(div2, t0);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (!
	      /*self*/
	      ctx[12] &&
	      /*chat*/
	      ctx[1].entity.__isSavedMessages) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block_13(ctx);
	          if_block1.c();
	          if_block1.m(div2, t1);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
	        if_block2.p(ctx, dirty);
	      } else {
	        if (if_block2) if_block2.d(1);
	        if_block2 = current_block_type && current_block_type(ctx);

	        if (if_block2) {
	          if_block2.c();
	          if_block2.m(div1, t2);
	        }
	      }

	      if (
	      /*replyTo*/
	      ctx[8] &&
	      /*replyTo*/
	      ctx[8] !== false &&
	      /*replyTo*/
	      ctx[8].id &&
	      /*replyThreadId*/
	      ctx[10] !==
	      /*replyTo*/
	      ctx[8].id) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block_9(ctx);
	          if_block3.c();
	          if_block3.m(div1, t3);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }

	      if (
	      /*hasMedia*/
	      ctx[19]) {
	        if (if_block4) {
	          if_block4.p(ctx, dirty);

	          if (dirty[0] &
	          /*hasMedia*/
	          524288) {
	            transition_in(if_block4, 1);
	          }
	        } else {
	          if_block4 = create_if_block_8(ctx);
	          if_block4.c();
	          transition_in(if_block4, 1);
	          if_block4.m(div1, t4);
	        }
	      } else if (if_block4) {
	        group_outros();
	        transition_out(if_block4, 1, 1, () => {
	          if_block4 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*message*/
	      ctx[2].message) {
	        if (if_block5) {
	          if_block5.p(ctx, dirty);
	        } else {
	          if_block5 = create_if_block_7(ctx);
	          if_block5.c();
	          if_block5.m(div1, t5);
	        }
	      } else if (if_block5) {
	        if_block5.d(1);
	        if_block5 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].media &&
	      /*message*/
	      ctx[2].media.webpage) {
	        if (if_block6) ; else {
	          if_block6 = create_if_block_6(ctx);
	          if_block6.c();
	          if_block6.m(div0, t6);
	        }
	      } else if (if_block6) {
	        if_block6.d(1);
	        if_block6 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].replyMarkup &&
	      /*message*/
	      ctx[2].replyMarkup.rows) {
	        if (if_block7) ; else {
	          if_block7 = create_if_block_5(ctx);
	          if_block7.c();
	          if_block7.m(div0, t7);
	        }
	      } else if (if_block7) {
	        if_block7.d(1);
	        if_block7 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].pinned) {
	        if (if_block8) ; else {
	          if_block8 = create_if_block_4(ctx);
	          if_block8.c();
	          if_block8.m(div0, t8);
	        }
	      } else if (if_block8) {
	        if_block8.d(1);
	        if_block8 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].views) {
	        if (if_block9) {
	          if_block9.p(ctx, dirty);
	        } else {
	          if_block9 = create_if_block_3(ctx);
	          if_block9.c();
	          if_block9.m(div0, t9);
	        }
	      } else if (if_block9) {
	        if_block9.d(1);
	        if_block9 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].editDate &&
	      /*message*/
	      ctx[2].editHide == false) {
	        if (if_block10) ; else {
	          if_block10 = create_if_block_2(ctx);
	          if_block10.c();
	          if_block10.m(div0, t10);
	        }
	      } else if (if_block10) {
	        if_block10.d(1);
	        if_block10 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].replies &&
	      /*message*/
	      ctx[2].replies.replies > 0) {
	        if (if_block11) {
	          if_block11.p(ctx, dirty);
	        } else {
	          if_block11 = create_if_block_1$1(ctx);
	          if_block11.c();
	          if_block11.m(div0, t11);
	        }
	      } else if (if_block11) {
	        if_block11.d(1);
	        if_block11 = null;
	      }

	      if (
	      /*message*/
	      ctx[2].forwards &&
	      /*message*/
	      ctx[2].forwards > 0) {
	        if (if_block12) {
	          if_block12.p(ctx, dirty);
	        } else {
	          if_block12 = create_if_block$4(ctx);
	          if_block12.c();
	          if_block12.m(div0, t12);
	        }
	      } else if (if_block12) {
	        if_block12.d(1);
	        if_block12 = null;
	      }

	      if ((!current || dirty[0] &
	      /*message*/
	      4) && t13_value !== (t13_value =
	      /*getTime*/
	      ctx[23](
	      /*message*/
	      ctx[2]) + "")) set_data_dev(t13, t13_value);

	      if (!current || dirty[0] &
	      /*hasAvatar, chat, self*/
	      12290) {
	        set_style(div1, "margin-left",
	        /*hasAvatar*/
	        ctx[13] && !
	        /*chat*/
	        ctx[1].isUser || !
	        /*self*/
	        ctx[12] &&
	        /*chat*/
	        ctx[1].entity.__isSavedMessages ? '45px' : '0px');
	      }

	      if (!current || dirty[0] &
	      /*key*/
	      1) {
	        attr_dev(div2, "data-key",
	        /*key*/
	        ctx[0]);
	      }

	      if (!current || dirty[0] &
	      /*className*/
	      8 && div2_class_value !== (div2_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-1o4zint")) {
	        attr_dev(div2, "class", div2_class_value);
	      }

	      if (!current || dirty[0] &
	      /*short, showFull, chat, justifyContent, hasAvatar*/
	      303618 && div2_style_value !== (div2_style_value = "background-color:" + (!
	      /*short*/
	      ctx[9] ? 'var(--themeColorLight)' : 'inherit') + ";" + (
	      /*showFull*/
	      ctx[18] ? 'height' : 'min-height') + ":" + (!
	      /*short*/
	      ctx[9] ? '92%' : 'auto') + ";overflow:" + (!
	      /*short*/
	      ctx[9] ? 'scroll' : 'inherit') + ";justify-content:" + (
	      /*chat*/
	      ctx[1].entity.className === 'Channel' && !
	      /*chat*/
	      ctx[1].entity.megagroup ? 'start' :
	      /*justifyContent*/
	      ctx[15]) + ";min-height:" + (
	      /*hasAvatar*/
	      ctx[13] ? '50px' : '0px') + ";")) {
	        attr_dev(div2, "style", div2_style_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block4);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block4);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div2);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();

	      if (if_block2) {
	        if_block2.d();
	      }

	      if (if_block3) if_block3.d();
	      if (if_block4) if_block4.d();
	      if (if_block5) if_block5.d();
	      if (if_block6) if_block6.d();
	      if (if_block7) if_block7.d();
	      if (if_block8) if_block8.d();
	      if (if_block9) if_block9.d();
	      if (if_block10) if_block10.d();
	      if (if_block11) if_block11.d();
	      if (if_block12) if_block12.d();
	      /*div2_binding*/

	      ctx[26](null);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$B.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$B($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Message', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var _$$props$key = $$props.key,
	      key = _$$props$key === void 0 ? '' : _$$props$key;
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? null : _$$props$className;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var _$$props$destroyCallb = $$props.destroyCallback,
	      destroyCallback = _$$props$destroyCallb === void 0 ? () => {} : _$$props$destroyCallb;
	  var replyTo = $$props.replyTo;
	  var _$$props$short = $$props.short,
	      short = _$$props$short === void 0 ? false : _$$props$short;
	  var _$$props$scrollable = $$props.scrollable,
	      scrollable = _$$props$scrollable === void 0 ? false : _$$props$scrollable;
	  var replyThreadId = $$props.replyThreadId;
	  var nodeRef;
	  var self = false;
	  var uncachedThumbnails;
	  var hasAvatar = false;
	  var avatarSrc = '';
	  var justifyContent = 'start';
	  var expandable = false;
	  var fullName = '';
	  var forwardedPrefix = '';
	  var showFull = false;
	  var hasMedia = false;
	  var mediaWidget;
	  var navOptions = {
	    arrowUpListener(evt) {
	      $$invalidate(11, nodeRef.scrollTop -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      $$invalidate(11, nodeRef.scrollTop += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      $$invalidate(11, nodeRef.scrollLeft -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      $$invalidate(11, nodeRef.scrollLeft += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    softkeyLeftListener(evt) {
	      return __awaiter(this, void 0, void 0, function* () {});
	    },

	    softkeyRightListener(evt) {},

	    enterListener(evt) {},

	    backspaceListener(evt) {
	      evt.preventDefault();
	      destroyCallback();
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function renderReplyHeader(msg) {
	    var columns = [];

	    if (msg.media) {
	      columns.push(`<div>${msg.media.className}</div>`);
	    }

	    if (msg.message && msg.message !== '') {
	      columns.push(`<div>${short && msg.message.length > 20 ? msg.message.substring(0, 20) + '...' : msg.message}</div>`);
	    }

	    return `<div>${columns.join('')}<div>`;
	  }

	  function getFullname(msg) {
	    var fullname = '';

	    try {
	      var sender = msg.sender || msg.__sender;

	      if (msg.fwdFrom && msg.fwdFrom.fromName) {
	        fullname = msg.fwdFrom.fromName;
	      } else if (msg.fwdFrom && msg.fwdFrom.sender) {
	        var fn = '';
	        if (msg.fwdFrom.sender.firstName) fn += msg.fwdFrom.sender.firstName;
	        if (msg.fwdFrom.sender.lastName) fn += ' ' + msg.fwdFrom.sender.lastName;
	        if (msg.fwdFrom.sender.title) fn = msg.fwdFrom.sender.title;
	        fullname = fn;
	      } else if (sender) {
	        var _fn = '';
	        if (sender.firstName) _fn += sender.firstName;
	        if (sender.lastName) _fn += ' ' + sender.lastName;
	        fullname = _fn;
	      }
	    } catch (err) {
	      console.log(err, message);
	    }

	    return fullname;
	  }

	  function getTime(msg) {
	    var t = new Date(msg.date * 1000);
	    if (scrollable) return t.toLocaleString();
	    t = t.toLocaleTimeString();
	    var ts = t.split(' ');
	    var hms = ts[0].split(':');
	    hms.pop();
	    return hms.join(':') + ' ' + ts[1];
	  }

	  function resolveMediaWidget(msg) {
	    var media;

	    if (msg.media.className === 'MessageMediaDocument') {
	      switch (msg.media.document.mimeType) {
	        case 'application/x-tgsticker':
	          media = Sticker;
	          break;

	        case 'video/mp4':
	          media = Video;
	          break;

	        case 'image/jpeg':
	        case 'image/png':
	        case 'image/gif':
	        case 'image/webp':
	          media = MessageMediaPhoto;
	          break;

	        case 'audio/mpeg':
	        case 'audio/ogg':
	          media = Audio;
	          break;

	        default:
	          media = Doc;
	      }
	    } else if (Media[msg.media.className]) {
	      media = Media[msg.media.className];
	    } else {
	      media = Dummy$1;
	    }

	    return media;
	  }

	  onMount(() => {}); // MessageEntityMention
	  // MessageEntityBotCommand
	  // MessageEntityUrl
	  // MessageEntityEmail
	  // MessageEntityTextUrl
	  // MessageEntityMentionName
	  // InputMessageEntityMentionName
	  // MessageEntityPhone
	  // console.log(message.id, message.entities);
	  // console.log(message.id, `short:${!short}`, `scrollable:${scrollable}`, `pinned:${message.pinned}`, `out:${message.out}`, `post:${message.post}`, `ttlPeriod:${message.ttlPeriod}`, `mentioned:${message.mentioned}`, `fromScheduled:${message.fromScheduled}`, message.buttons);

	  beforeUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
	    if (!short && scrollable) {
	      $$invalidate(18, showFull = true);
	      parentNavInstance.detachListener();
	      navInstance.attachListener();
	    }

	    try {
	      if (message.media) {
	        $$invalidate(19, hasMedia = true);
	        $$invalidate(20, mediaWidget = resolveMediaWidget(message));
	      } else {
	        $$invalidate(19, hasMedia = false);
	        $$invalidate(20, mediaWidget = null);
	      }

	      if (message.message.length > 80 && short) expandable = true;

	      var _hasAvatar;

	      var _justifyContent;

	      var _self = false;
	      var user = yield getAuthorizedUser();
	      var sender = message.sender || message.__sender;

	      if (sender && user[0] && sender.id.toString() === user[0].id.toString()) {
	        _self = true;
	        _hasAvatar = false;
	        _justifyContent = 'end';
	      } else {
	        _self = false;
	        _hasAvatar = true;
	        _justifyContent = 'start';

	        if (chat.entity.className === 'Channel' && !chat.entity.megagroup) {
	          _hasAvatar = false;
	        }
	      }

	      if (message.fwdFrom) {
	        if (chat.entity.id && chat.entity.id.value.toString() !== user[0].id.toString()) {
	          $$invalidate(17, forwardedPrefix = 'Forwarded from ');
	        }

	        if (sender.id && sender.id.toString() === user[0].id.toString() && sender.id.toString() === chat.entity.id.value.toString()) {
	          _hasAvatar = true;
	          _justifyContent = 'start';
	          _self = false;
	        }

	        if (message.fwdFrom.fromName) {
	          delete message.iconRef;
	        } else if (message.fwdFrom.fromId) {
	          if (message.fwdFrom.fromId.className === 'PeerUser') {
	            $$invalidate(16, fullName = getFullname(message));
	          } else if (message.fwdFrom.fromId.className === 'PeerChannel') {
	            $$invalidate(16, fullName = getFullname(message));
	          }
	        }
	      }

	      if (chat.entity.__isSavedMessages) _hasAvatar = true;
	      $$invalidate(13, hasAvatar = _hasAvatar);
	      $$invalidate(15, justifyContent = _justifyContent);
	      $$invalidate(12, self = _self);
	      if (!hasAvatar) return;
	      if (uncachedThumbnails) uncachedThumbnails();
	      uncachedThumbnails = cachedThumbnails.subscribe(data => {
	        if (message.iconRef && data[message.iconRef]) {
	          $$invalidate(14, avatarSrc = `<img alt="icon" style="position:absolute;${!short ? 'top:0' : 'bottom:0'};background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;"" src="${data[message.iconRef]}"/>`);
	        } else {
	          try {
	            var name = getFullname(message).split(' ').map(text => text[0].toUpperCase()).splice(0, 2).join('');
	            $$invalidate(14, avatarSrc = `<div style="position:absolute;${!short ? 'top:0' : 'bottom:0'};display:flex;flex-direction:column;justify-content:center;align-items:center;font-weight:bold;color:#fff;background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;">${name}</div>`);
	          } catch (err) {
	            $$invalidate(14, avatarSrc = `<div style="position:absolute;${!short ? 'top:0' : 'bottom:0'};display:flex;flex-direction:column;justify-content:center;align-items:center;font-weight:bold;color:#fff;background-color:var(--themeColor);width:40px;height:40px;border-radius:50%;box-sizing:border-box;border: 2px solid #fff;">DA</div>`);
	          }
	        }
	      });
	    } catch (err) {
	      console.log('beforeUpdate:', err);
	    }
	  }));
	  onDestroy(() => {
	    if (!short && scrollable) {
	      parentNavInstance.attachListener();
	      navInstance.detachListener();
	    }

	    if (uncachedThumbnails) uncachedThumbnails();
	  });
	  var writable_props = ['key', 'chat', 'message', 'className', 'onClick', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage', 'destroyCallback', 'replyTo', 'short', 'scrollable', 'replyThreadId'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Message> was created with unknown prop '${key}'`);
	  });

	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(11, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('destroyCallback' in $$props) $$invalidate(24, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(8, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(9, short = $$props.short);
	    if ('scrollable' in $$props) $$invalidate(25, scrollable = $$props.scrollable);
	    if ('replyThreadId' in $$props) $$invalidate(10, replyThreadId = $$props.replyThreadId);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    onMount,
	    onDestroy,
	    beforeUpdate,
	    createKaiNavigator,
	    Media,
	    DOMPurify: purify,
	    cachedThumbnails,
	    getAuthorizedUser,
	    key,
	    chat,
	    message,
	    className,
	    onClick,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    destroyCallback,
	    replyTo,
	    short,
	    scrollable,
	    replyThreadId,
	    nodeRef,
	    self,
	    uncachedThumbnails,
	    hasAvatar,
	    avatarSrc,
	    justifyContent,
	    expandable,
	    fullName,
	    forwardedPrefix,
	    showFull,
	    hasMedia,
	    mediaWidget,
	    navOptions,
	    navInstance,
	    renderReplyHeader,
	    getFullname,
	    getTime,
	    resolveMediaWidget
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('destroyCallback' in $$props) $$invalidate(24, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(8, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(9, short = $$props.short);
	    if ('scrollable' in $$props) $$invalidate(25, scrollable = $$props.scrollable);
	    if ('replyThreadId' in $$props) $$invalidate(10, replyThreadId = $$props.replyThreadId);
	    if ('nodeRef' in $$props) $$invalidate(11, nodeRef = $$props.nodeRef);
	    if ('self' in $$props) $$invalidate(12, self = $$props.self);
	    if ('uncachedThumbnails' in $$props) uncachedThumbnails = $$props.uncachedThumbnails;
	    if ('hasAvatar' in $$props) $$invalidate(13, hasAvatar = $$props.hasAvatar);
	    if ('avatarSrc' in $$props) $$invalidate(14, avatarSrc = $$props.avatarSrc);
	    if ('justifyContent' in $$props) $$invalidate(15, justifyContent = $$props.justifyContent);
	    if ('expandable' in $$props) expandable = $$props.expandable;
	    if ('fullName' in $$props) $$invalidate(16, fullName = $$props.fullName);
	    if ('forwardedPrefix' in $$props) $$invalidate(17, forwardedPrefix = $$props.forwardedPrefix);
	    if ('showFull' in $$props) $$invalidate(18, showFull = $$props.showFull);
	    if ('hasMedia' in $$props) $$invalidate(19, hasMedia = $$props.hasMedia);
	    if ('mediaWidget' in $$props) $$invalidate(20, mediaWidget = $$props.mediaWidget);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [key, chat, message, className, onClick, parentNavInstance, registerCallButtonHandler, refetchMessage, replyTo, short, replyThreadId, nodeRef, self, hasAvatar, avatarSrc, justifyContent, fullName, forwardedPrefix, showFull, hasMedia, mediaWidget, renderReplyHeader, getFullname, getTime, destroyCallback, scrollable, div2_binding];
	}

	class Message$1 extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$B, create_fragment$B, not_equal, {
	      key: 0,
	      chat: 1,
	      message: 2,
	      className: 3,
	      onClick: 4,
	      parentNavInstance: 5,
	      registerCallButtonHandler: 6,
	      refetchMessage: 7,
	      destroyCallback: 24,
	      replyTo: 8,
	      short: 9,
	      scrollable: 25,
	      replyThreadId: 10
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Message",
	      options,
	      id: create_fragment$B.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[5] === undefined && !('parentNavInstance' in props)) {
	      console_1$4.warn("<Message> was created without expected prop 'parentNavInstance'");
	    }

	    if (
	    /*replyTo*/
	    ctx[8] === undefined && !('replyTo' in props)) {
	      console_1$4.warn("<Message> was created without expected prop 'replyTo'");
	    }

	    if (
	    /*replyThreadId*/
	    ctx[10] === undefined && !('replyThreadId' in props)) {
	      console_1$4.warn("<Message> was created without expected prop 'replyThreadId'");
	    }
	  }

	  get key() {
	    return this.$$.ctx[0];
	  }

	  set key(key) {
	    this.$$set({
	      key
	    });
	    flush();
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get className() {
	    return this.$$.ctx[3];
	  }

	  set className(className) {
	    this.$$set({
	      className
	    });
	    flush();
	  }

	  get onClick() {
	    return this.$$.ctx[4];
	  }

	  set onClick(onClick) {
	    this.$$set({
	      onClick
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[5];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[6];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[7];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	  get destroyCallback() {
	    return this.$$.ctx[24];
	  }

	  set destroyCallback(destroyCallback) {
	    this.$$set({
	      destroyCallback
	    });
	    flush();
	  }

	  get replyTo() {
	    return this.$$.ctx[8];
	  }

	  set replyTo(replyTo) {
	    this.$$set({
	      replyTo
	    });
	    flush();
	  }

	  get short() {
	    return this.$$.ctx[9];
	  }

	  set short(short) {
	    this.$$set({
	      short
	    });
	    flush();
	  }

	  get scrollable() {
	    return this.$$.ctx[25];
	  }

	  set scrollable(scrollable) {
	    this.$$set({
	      scrollable
	    });
	    flush();
	  }

	  get replyThreadId() {
	    return this.$$.ctx[10];
	  }

	  set replyThreadId(replyThreadId) {
	    this.$$set({
	      replyThreadId
	    });
	    flush();
	  }

	}

	var file$A = "src/widgets/message/action/MessageActionEmpty.svelte";

	function create_fragment$A(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-x2q8ou");
	      add_location(p, file$A, 13, 2, 363);
	      attr_dev(div, "class", "MessageActionEmpty svelte-x2q8ou");
	      add_location(div, file$A, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$A.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$A($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionEmpty', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionEmpty> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionEmpty extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$A, create_fragment$A, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionEmpty",
	      options,
	      id: create_fragment$A.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionEmpty> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionEmpty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionEmpty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* src/widgets/message/action/MessageActionChatCreate.svelte generated by Svelte v3.46.4 */
	var file$z = "src/widgets/message/action/MessageActionChatCreate.svelte";

	function create_fragment$z(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Chat created";
	      attr_dev(p, "class", "svelte-108wyqm");
	      add_location(p, file$z, 15, 2, 414);
	      attr_dev(div, "class", "MessageActionChatCreate svelte-108wyqm");
	      add_location(div, file$z, 14, 0, 374);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$z.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$z($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatCreate', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatCreate> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatCreate extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$z, create_fragment$z, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatCreate",
	      options,
	      id: create_fragment$z.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatCreate> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$y = "src/widgets/message/action/MessageActionChatEditTitle.svelte";

	function create_fragment$y(ctx) {
	  var div;
	  var p;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[0].action.title + "";
	  var t1;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text("Title updated, ");
	      t1 = text(t1_value);
	      attr_dev(p, "class", "svelte-atedv4");
	      add_location(p, file$y, 13, 2, 371);
	      attr_dev(div, "class", "MessageActionChatEditTitle svelte-atedv4");
	      add_location(div, file$y, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value =
	      /*message*/
	      ctx[0].action.title + "")) set_data_dev(t1, t1_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$y.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$y($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatEditTitle', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatEditTitle> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatEditTitle extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$y, create_fragment$y, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatEditTitle",
	      options,
	      id: create_fragment$y.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatEditTitle> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionChatEditTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$x = "src/widgets/message/action/MessageActionChatEditPhoto.svelte";

	function create_fragment$x(ctx) {
	  var div;
	  var p;
	  var t1;
	  var img;
	  var img_src_value;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Photo updated";
	      t1 = space();
	      img = element("img");
	      attr_dev(p, "class", "svelte-1khqr45");
	      add_location(p, file$x, 19, 2, 618);
	      attr_dev(img, "alt", "icon");
	      if (!src_url_equal(img.src, img_src_value =
	      /*src*/
	      ctx[0])) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "class", "svelte-1khqr45");
	      add_location(img, file$x, 20, 2, 641);
	      attr_dev(div, "class", "MessageActionChatEditPhoto svelte-1khqr45");
	      add_location(div, file$x, 18, 0, 575);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(div, t1);
	      append_dev(div, img);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*src*/
	      1 && !src_url_equal(img.src, img_src_value =
	      /*src*/
	      ctx[0])) {
	        attr_dev(img, "src", img_src_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$x.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$x($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatEditPhoto', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var src = '';
	  onMount(() => {
	    var cached = getCachedThumbnails();
	    if (cached[message.action.photo.id.toString()]) $$invalidate(0, src = cached[message.action.photo.id.toString()]);
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatEditPhoto> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    getCachedThumbnails,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    src
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	    if ('src' in $$props) $$invalidate(0, src = $$props.src);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [src, chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatEditPhoto extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$x, create_fragment$x, not_equal, {
	      chat: 1,
	      message: 2,
	      parentNavInstance: 3,
	      registerCallButtonHandler: 4,
	      refetchMessage: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatEditPhoto",
	      options,
	      id: create_fragment$x.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[3] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatEditPhoto> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[3];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[4];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[5];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/action/MessageActionChatDeletePhoto.svelte generated by Svelte v3.46.4 */
	var file$w = "src/widgets/message/action/MessageActionChatDeletePhoto.svelte";

	function create_fragment$w(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Photo deleted";
	      attr_dev(p, "class", "svelte-elenwi");
	      add_location(p, file$w, 15, 2, 419);
	      attr_dev(div, "class", "MessageActionChatDeletePhoto svelte-elenwi");
	      add_location(div, file$w, 14, 0, 374);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$w.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$w($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatDeletePhoto', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatDeletePhoto> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatDeletePhoto extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$w, create_fragment$w, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatDeletePhoto",
	      options,
	      id: create_fragment$w.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatDeletePhoto> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$3 = globals.console;
	var file$v = "src/widgets/message/action/MessageActionChatAddUser.svelte"; // (34:5) {#if username}

	function create_if_block$3(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*username*/
	      ctx[0]);
	      t1 = space();
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*username*/
	      1) set_data_dev(t0,
	      /*username*/
	      ctx[0]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$3.name,
	    type: "if",
	    source: "(34:5) {#if username}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$v(ctx) {
	  var div;
	  var p;
	  var t;
	  var if_block =
	  /*username*/
	  ctx[0] && create_if_block$3(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      if (if_block) if_block.c();
	      t = text("joined the group");
	      attr_dev(p, "class", "svelte-1m9vdrs");
	      add_location(p, file$v, 33, 2, 1026);
	      attr_dev(div, "class", "MessageActionChatAddUser svelte-1m9vdrs");
	      add_location(div, file$v, 32, 0, 985);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      if (if_block) if_block.m(p, null);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*username*/
	      ctx[0]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$3(ctx);
	          if_block.c();
	          if_block.m(p, t);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$v.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$v($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatAddUser', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var username = false;
	  onMount(() => {
	    client.invoke(new Api.users.GetUsers({
	      id: message.action.users
	    })).then(users => {
	      if (users.length > 0) {
	        var u = '';
	        if (users[0].firstName) u = users[0].firstName;
	        if (users[0].lastName) u += ' ' + users[0].lastName;
	        if (u == '' && users[0].username) u = users[0].username;
	        u = u == '' ? false : u;
	        $$invalidate(0, username = u);
	      }
	    }).catch(err => {
	      console.log("MessageActionChatAddUser:", err);
	    });
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<MessageActionChatAddUser> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    Api,
	    client,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    username
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	    if ('username' in $$props) $$invalidate(0, username = $$props.username);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [username, chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatAddUser extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$v, create_fragment$v, not_equal, {
	      chat: 1,
	      message: 2,
	      parentNavInstance: 3,
	      registerCallButtonHandler: 4,
	      refetchMessage: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatAddUser",
	      options,
	      id: create_fragment$v.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[3] === undefined && !('parentNavInstance' in props)) {
	      console_1$3.warn("<MessageActionChatAddUser> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[3];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[4];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[5];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var console_1$2 = globals.console;
	var file$u = "src/widgets/message/action/MessageActionChatDeleteUser.svelte"; // (34:5) {#if username}

	function create_if_block$2(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(
	      /*username*/
	      ctx[0]);
	      t1 = space();
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*username*/
	      1) set_data_dev(t0,
	      /*username*/
	      ctx[0]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$2.name,
	    type: "if",
	    source: "(34:5) {#if username}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$u(ctx) {
	  var div;
	  var p;
	  var t;
	  var if_block =
	  /*username*/
	  ctx[0] && create_if_block$2(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      if (if_block) if_block.c();
	      t = text("left the group");
	      attr_dev(p, "class", "svelte-vtb1xu");
	      add_location(p, file$u, 33, 2, 1035);
	      attr_dev(div, "class", "MessageActionChatDeleteUser svelte-vtb1xu");
	      add_location(div, file$u, 32, 0, 991);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      if (if_block) if_block.m(p, null);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*username*/
	      ctx[0]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$2(ctx);
	          if_block.c();
	          if_block.m(p, t);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$u.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$u($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatDeleteUser', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var username = false;
	  onMount(() => {
	    client.invoke(new Api.users.GetUsers({
	      id: [message.action.userId]
	    })).then(users => {
	      if (users.length > 0) {
	        var u = '';
	        if (users[0].firstName) u = users[0].firstName;
	        if (users[0].lastName) u += ' ' + users[0].lastName;
	        if (u == '' && users[0].username) u = users[0].username;
	        u = u == '' ? false : u;
	        $$invalidate(0, username = u);
	      }
	    }).catch(err => {
	      console.log("MessageActionChatDeleteUser:", err);
	    });
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<MessageActionChatDeleteUser> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    Api,
	    client,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    username
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	    if ('username' in $$props) $$invalidate(0, username = $$props.username);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [username, chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatDeleteUser extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$u, create_fragment$u, not_equal, {
	      chat: 1,
	      message: 2,
	      parentNavInstance: 3,
	      registerCallButtonHandler: 4,
	      refetchMessage: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatDeleteUser",
	      options,
	      id: create_fragment$u.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[3] === undefined && !('parentNavInstance' in props)) {
	      console_1$2.warn("<MessageActionChatDeleteUser> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[3];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[4];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[5];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/action/MessageActionChatJoinedByLink.svelte generated by Svelte v3.46.4 */
	var file$t = "src/widgets/message/action/MessageActionChatJoinedByLink.svelte";

	function create_fragment$t(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Joined by link";
	      add_location(p, file$t, 13, 2, 374);
	      attr_dev(div, "class", "MessageActionChatJoinedByLink svelte-69i83z");
	      add_location(div, file$t, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$t.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$t($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatJoinedByLink', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatJoinedByLink> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatJoinedByLink extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$t, create_fragment$t, safe_not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatJoinedByLink",
	      options,
	      id: create_fragment$t.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatJoinedByLink> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionChatJoinedByLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* src/widgets/message/action/MessageActionChannelCreate.svelte generated by Svelte v3.46.4 */
	var file$s = "src/widgets/message/action/MessageActionChannelCreate.svelte";

	function create_fragment$s(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Channel created";
	      attr_dev(p, "class", "svelte-o3rlsq");
	      add_location(p, file$s, 15, 2, 417);
	      attr_dev(div, "class", "MessageActionChannelCreate svelte-o3rlsq");
	      add_location(div, file$s, 14, 0, 374);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$s.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$s($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChannelCreate', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChannelCreate> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChannelCreate extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$s, create_fragment$s, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChannelCreate",
	      options,
	      id: create_fragment$s.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChannelCreate> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	/* src/widgets/message/action/MessageActionChatMigrateTo.svelte generated by Svelte v3.46.4 */
	var file$r = "src/widgets/message/action/MessageActionChatMigrateTo.svelte";

	function create_fragment$r(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Chat migrate to channel";
	      attr_dev(p, "class", "svelte-vceezg");
	      add_location(p, file$r, 13, 2, 371);
	      attr_dev(div, "class", "MessageActionChatMigrateTo svelte-vceezg");
	      add_location(div, file$r, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$r.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$r($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatMigrateTo', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatMigrateTo> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatMigrateTo extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$r, create_fragment$r, safe_not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatMigrateTo",
	      options,
	      id: create_fragment$r.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatMigrateTo> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionChatMigrateTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$q = "src/widgets/message/action/MessageActionChannelMigrateFrom.svelte";

	function create_fragment$q(ctx) {
	  var div;
	  var p;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[0].action.title + "";
	  var t1;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text("Channel migrate from ");
	      t1 = text(t1_value);
	      attr_dev(p, "class", "svelte-1wjmegi");
	      add_location(p, file$q, 15, 2, 422);
	      attr_dev(div, "class", "MessageActionChannelMigrateFrom svelte-1wjmegi");
	      add_location(div, file$q, 14, 0, 374);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value =
	      /*message*/
	      ctx[0].action.title + "")) set_data_dev(t1, t1_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$q.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$q($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChannelMigrateFrom', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChannelMigrateFrom> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChannelMigrateFrom extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$q, create_fragment$q, not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChannelMigrateFrom",
	      options,
	      id: create_fragment$q.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChannelMigrateFrom> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[0];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$p = "src/widgets/message/action/MessageActionPinMessage.svelte";

	function create_fragment$p(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1iwd9h6");
	      add_location(p, file$p, 13, 2, 368);
	      attr_dev(div, "class", "MessageActionPinMessage svelte-1iwd9h6");
	      add_location(div, file$p, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$p.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$p($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionPinMessage', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionPinMessage> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionPinMessage extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$p, create_fragment$p, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionPinMessage",
	      options,
	      id: create_fragment$p.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionPinMessage> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionPinMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionPinMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionPinMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionPinMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionPinMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionPinMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionPinMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionPinMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionPinMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionPinMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$o = "src/widgets/message/action/MessageActionHistoryClear.svelte";

	function create_fragment$o(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-vc9uzi");
	      add_location(p, file$o, 13, 2, 370);
	      attr_dev(div, "class", "MessageActionHistoryClear svelte-vc9uzi");
	      add_location(div, file$o, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$o.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$o($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionHistoryClear', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionHistoryClear> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionHistoryClear extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$o, create_fragment$o, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionHistoryClear",
	      options,
	      id: create_fragment$o.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionHistoryClear> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionHistoryClear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$n = "src/widgets/message/action/MessageActionGameScore.svelte";

	function create_fragment$n(ctx) {
	  var div;
	  var p;
	  var t0_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t0;
	  var t1;
	  var t2_value =
	  /*message*/
	  ctx[0].action.score + "";
	  var t2;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(t0_value);
	      t1 = text(": ");
	      t2 = text(t2_value);
	      attr_dev(p, "class", "svelte-y81l7k");
	      add_location(p, file$n, 13, 2, 367);
	      attr_dev(div, "class", "MessageActionGameScore svelte-y81l7k");
	      add_location(div, file$n, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	      append_dev(p, t2);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t2_value !== (t2_value =
	      /*message*/
	      ctx[0].action.score + "")) set_data_dev(t2, t2_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$n.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$n($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionGameScore', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionGameScore> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionGameScore extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$n, create_fragment$n, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionGameScore",
	      options,
	      id: create_fragment$n.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionGameScore> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionGameScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionGameScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionGameScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionGameScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionGameScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionGameScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionGameScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionGameScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionGameScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionGameScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$m = "src/widgets/message/action/MessageActionPaymentSentMe.svelte";

	function create_fragment$m(ctx) {
	  var div;
	  var p;
	  var t0_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t0;
	  var t1;
	  var t2_value =
	  /*message*/
	  ctx[0].action.currency + "";
	  var t2;
	  var t3_value =
	  /*message*/
	  ctx[0].action.totalAmount + "";
	  var t3;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(t0_value);
	      t1 = text(": ");
	      t2 = text(t2_value);
	      t3 = text(t3_value);
	      attr_dev(p, "class", "svelte-grkh5g");
	      add_location(p, file$m, 13, 2, 371);
	      attr_dev(div, "class", "MessageActionPaymentSentMe svelte-grkh5g");
	      add_location(div, file$m, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	      append_dev(p, t2);
	      append_dev(p, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t2_value !== (t2_value =
	      /*message*/
	      ctx[0].action.currency + "")) set_data_dev(t2, t2_value);
	      if (dirty &
	      /*message*/
	      1 && t3_value !== (t3_value =
	      /*message*/
	      ctx[0].action.totalAmount + "")) set_data_dev(t3, t3_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$m.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$m($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionPaymentSentMe', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionPaymentSentMe> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionPaymentSentMe extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$m, create_fragment$m, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionPaymentSentMe",
	      options,
	      id: create_fragment$m.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionPaymentSentMe> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionPaymentSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$l = "src/widgets/message/action/MessageActionPaymentSent.svelte";

	function create_fragment$l(ctx) {
	  var div;
	  var p;
	  var t0_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t0;
	  var t1;
	  var t2_value =
	  /*message*/
	  ctx[0].action.currency + "";
	  var t2;
	  var t3_value =
	  /*message*/
	  ctx[0].action.totalAmount + "";
	  var t3;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(t0_value);
	      t1 = text(": ");
	      t2 = text(t2_value);
	      t3 = text(t3_value);
	      attr_dev(p, "class", "svelte-1kkdhas");
	      add_location(p, file$l, 13, 2, 369);
	      attr_dev(div, "class", "MessageActionPaymentSent svelte-1kkdhas");
	      add_location(div, file$l, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	      append_dev(p, t2);
	      append_dev(p, t3);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t2_value !== (t2_value =
	      /*message*/
	      ctx[0].action.currency + "")) set_data_dev(t2, t2_value);
	      if (dirty &
	      /*message*/
	      1 && t3_value !== (t3_value =
	      /*message*/
	      ctx[0].action.totalAmount + "")) set_data_dev(t3, t3_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$l.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$l($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionPaymentSent', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionPaymentSent> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionPaymentSent extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$l, create_fragment$l, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionPaymentSent",
	      options,
	      id: create_fragment$l.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionPaymentSent> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionPaymentSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$k = "src/widgets/message/action/MessageActionPhoneCall.svelte";

	function create_fragment$k(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1dlvg4o");
	      add_location(p, file$k, 13, 2, 367);
	      attr_dev(div, "class", "MessageActionPhoneCall svelte-1dlvg4o");
	      add_location(div, file$k, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$k.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$k($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionPhoneCall', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionPhoneCall> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionPhoneCall extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$k, create_fragment$k, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionPhoneCall",
	      options,
	      id: create_fragment$k.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionPhoneCall> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$j = "src/widgets/message/action/MessageActionScreenshotTaken.svelte";

	function create_fragment$j(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-flynnq");
	      add_location(p, file$j, 13, 2, 373);
	      attr_dev(div, "class", "MessageActionScreenshotTaken svelte-flynnq");
	      add_location(div, file$j, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$j.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$j($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionScreenshotTaken', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionScreenshotTaken> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionScreenshotTaken extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionScreenshotTaken",
	      options,
	      id: create_fragment$j.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionScreenshotTaken> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionScreenshotTaken>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$i = "src/widgets/message/action/MessageActionCustomAction.svelte";

	function create_fragment$i(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-9br0ga");
	      add_location(p, file$i, 13, 2, 370);
	      attr_dev(div, "class", "MessageActionCustomAction svelte-9br0ga");
	      add_location(div, file$i, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$i.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$i($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionCustomAction', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionCustomAction> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionCustomAction extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$i, create_fragment$i, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionCustomAction",
	      options,
	      id: create_fragment$i.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionCustomAction> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionCustomAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionCustomAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionCustomAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionCustomAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionCustomAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionCustomAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionCustomAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionCustomAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionCustomAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionCustomAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* src/widgets/message/action/MessageActionBotAllowed.svelte generated by Svelte v3.46.4 */
	var file$h = "src/widgets/message/action/MessageActionBotAllowed.svelte";

	function create_fragment$h(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Bot allowed";
	      attr_dev(p, "class", "svelte-n94dpq");
	      add_location(p, file$h, 15, 2, 414);
	      attr_dev(div, "class", "MessageActionBotAllowed svelte-n94dpq");
	      add_location(div, file$h, 14, 0, 374);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$h.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$h($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionBotAllowed', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionBotAllowed> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionBotAllowed extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$h, create_fragment$h, not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionBotAllowed",
	      options,
	      id: create_fragment$h.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionBotAllowed> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    return this.$$.ctx[0];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[1];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[2];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[3];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[4];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	}

	var file$g = "src/widgets/message/action/MessageActionSecureValuesSentMe.svelte";

	function create_fragment$g(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-10vt2xa");
	      add_location(p, file$g, 13, 2, 376);
	      attr_dev(div, "class", "MessageActionSecureValuesSentMe svelte-10vt2xa");
	      add_location(div, file$g, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$g.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$g($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionSecureValuesSentMe', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionSecureValuesSentMe> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionSecureValuesSentMe extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$g, create_fragment$g, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionSecureValuesSentMe",
	      options,
	      id: create_fragment$g.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionSecureValuesSentMe> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionSecureValuesSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$f = "src/widgets/message/action/MessageActionSecureValuesSent.svelte";

	function create_fragment$f(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1qfe2b2");
	      add_location(p, file$f, 13, 2, 374);
	      attr_dev(div, "class", "MessageActionSecureValuesSent svelte-1qfe2b2");
	      add_location(div, file$f, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$f.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$f($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionSecureValuesSent', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionSecureValuesSent> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionSecureValuesSent extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$f, create_fragment$f, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionSecureValuesSent",
	      options,
	      id: create_fragment$f.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionSecureValuesSent> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionSecureValuesSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* src/widgets/message/action/MessageActionContactSignUp.svelte generated by Svelte v3.46.4 */
	var file$e = "src/widgets/message/action/MessageActionContactSignUp.svelte";

	function create_fragment$e(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Contact sign up";
	      attr_dev(p, "class", "svelte-42b9dc");
	      add_location(p, file$e, 13, 2, 371);
	      attr_dev(div, "class", "MessageActionContactSignUp svelte-42b9dc");
	      add_location(div, file$e, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$e.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$e($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionContactSignUp', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionContactSignUp> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionContactSignUp extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionContactSignUp",
	      options,
	      id: create_fragment$e.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionContactSignUp> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionContactSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$d = "src/widgets/message/action/MessageActionGeoProximityReached.svelte";

	function create_fragment$d(ctx) {
	  var div;
	  var p;
	  var t0_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t0;
	  var t1;
	  var t2_value =
	  /*message*/
	  ctx[0].action.distance + "";
	  var t2;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(t0_value);
	      t1 = text(": ");
	      t2 = text(t2_value);
	      attr_dev(p, "class", "svelte-1i46c4s");
	      add_location(p, file$d, 13, 2, 377);
	      attr_dev(div, "class", "MessageActionGeoProximityReached svelte-1i46c4s");
	      add_location(div, file$d, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	      append_dev(p, t2);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t2_value !== (t2_value =
	      /*message*/
	      ctx[0].action.distance + "")) set_data_dev(t2, t2_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$d.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$d($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionGeoProximityReached', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionGeoProximityReached> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionGeoProximityReached extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$d, create_fragment$d, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionGeoProximityReached",
	      options,
	      id: create_fragment$d.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionGeoProximityReached> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionGeoProximityReached>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$c = "src/widgets/message/action/MessageActionGroupCall.svelte";

	function create_fragment$c(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-amvfri");
	      add_location(p, file$c, 13, 2, 367);
	      attr_dev(div, "class", "MessageActionGroupCall svelte-amvfri");
	      add_location(div, file$c, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$c.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$c($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionGroupCall', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionGroupCall> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionGroupCall extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$c, create_fragment$c, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionGroupCall",
	      options,
	      id: create_fragment$c.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionGroupCall> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$b = "src/widgets/message/action/MessageActionInviteToGroupCall.svelte";

	function create_fragment$b(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1melmze");
	      add_location(p, file$b, 13, 2, 375);
	      attr_dev(div, "class", "MessageActionInviteToGroupCall svelte-1melmze");
	      add_location(div, file$b, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$b.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$b($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionInviteToGroupCall', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionInviteToGroupCall> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionInviteToGroupCall extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$b, create_fragment$b, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionInviteToGroupCall",
	      options,
	      id: create_fragment$b.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionInviteToGroupCall> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionInviteToGroupCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$a = "src/widgets/message/action/MessageActionSetMessagesTTL.svelte";

	function create_fragment$a(ctx) {
	  var div;
	  var p;
	  var t0_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t0;
	  var t1;
	  var t2_value =
	  /*message*/
	  ctx[0].action.period + "";
	  var t2;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text(t0_value);
	      t1 = text(": ");
	      t2 = text(t2_value);
	      attr_dev(p, "class", "svelte-8t5zf6");
	      add_location(p, file$a, 13, 2, 372);
	      attr_dev(div, "class", "MessageActionSetMessagesTTL svelte-8t5zf6");
	      add_location(div, file$a, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	      append_dev(p, t2);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t0_value !== (t0_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t0, t0_value);
	      if (dirty &
	      /*message*/
	      1 && t2_value !== (t2_value =
	      /*message*/
	      ctx[0].action.period + "")) set_data_dev(t2, t2_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$a.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$a($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionSetMessagesTTL', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionSetMessagesTTL> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionSetMessagesTTL extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$a, create_fragment$a, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionSetMessagesTTL",
	      options,
	      id: create_fragment$a.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionSetMessagesTTL> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionSetMessagesTTL>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var console_1$1 = globals.console;
	var file$9 = "src/widgets/message/action/MessageActionGroupCallScheduled.svelte"; // (21:31) {#if dt}

	function create_if_block$1(ctx) {
	  var t0;
	  var t1;
	  var block = {
	    c: function create() {
	      t0 = text(": ");
	      t1 = text(
	      /*dt*/
	      ctx[1]);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, t0, anchor);
	      insert_dev(target, t1, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty &
	      /*dt*/
	      2) set_data_dev(t1,
	      /*dt*/
	      ctx[1]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(t0);
	      if (detaching) detach_dev(t1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1.name,
	    type: "if",
	    source: "(21:31) {#if dt}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$9(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var if_block =
	  /*dt*/
	  ctx[1] && create_if_block$1(ctx);
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      if (if_block) if_block.c();
	      attr_dev(p, "class", "svelte-htwnci");
	      add_location(p, file$9, 20, 2, 569);
	      attr_dev(div, "class", "MessageActionGroupCallScheduled svelte-htwnci");
	      add_location(div, file$9, 19, 0, 521);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	      if (if_block) if_block.m(p, null);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);

	      if (
	      /*dt*/
	      ctx[1]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$1(ctx);
	          if_block.c();
	          if_block.m(p, null);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (if_block) if_block.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$9.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$9($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionGroupCallScheduled', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var dt = false;
	  onMount(() => {
	    // console.log(message);
	    try {
	      $$invalidate(1, dt = new Date(message.action.scheduleDate * 1000).toLocaleString());
	    } catch (err) {
	      console.log("MessageActionGroupCallScheduled", err);
	    }
	  });
	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<MessageActionGroupCallScheduled> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(2, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    dt
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(2, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(3, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(4, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(5, refetchMessage = $$props.refetchMessage);
	    if ('dt' in $$props) $$invalidate(1, dt = $$props.dt);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, dt, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionGroupCallScheduled extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$9, create_fragment$9, safe_not_equal, {
	      chat: 2,
	      message: 0,
	      parentNavInstance: 3,
	      registerCallButtonHandler: 4,
	      refetchMessage: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionGroupCallScheduled",
	      options,
	      id: create_fragment$9.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[3] === undefined && !('parentNavInstance' in props)) {
	      console_1$1.warn("<MessageActionGroupCallScheduled> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionGroupCallScheduled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$8 = "src/widgets/message/action/MessageActionSetChatTheme.svelte";

	function create_fragment$8(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1fful8m");
	      add_location(p, file$8, 13, 2, 370);
	      attr_dev(div, "class", "MessageActionSetChatTheme svelte-1fful8m");
	      add_location(div, file$8, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$8.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$8($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionSetChatTheme', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionSetChatTheme> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionSetChatTheme extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$8, create_fragment$8, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionSetChatTheme",
	      options,
	      id: create_fragment$8.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionSetChatTheme> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionSetChatTheme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	/* src/widgets/message/action/MessageActionChatJoinedByRequest.svelte generated by Svelte v3.46.4 */
	var file$7 = "src/widgets/message/action/MessageActionChatJoinedByRequest.svelte";

	function create_fragment$7(ctx) {
	  var div;
	  var p;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      p.textContent = "Joined by request";
	      attr_dev(p, "class", "svelte-enhkiq");
	      add_location(p, file$7, 13, 2, 377);
	      attr_dev(div, "class", "MessageActionChatJoinedByRequest svelte-enhkiq");
	      add_location(div, file$7, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$7.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$7($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionChatJoinedByRequest', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionChatJoinedByRequest> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(0, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(1, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [chat, message, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionChatJoinedByRequest extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$7, create_fragment$7, safe_not_equal, {
	      chat: 0,
	      message: 1,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionChatJoinedByRequest",
	      options,
	      id: create_fragment$7.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionChatJoinedByRequest> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionChatJoinedByRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$6 = "src/widgets/message/action/MessageActionWebViewDataSentMe.svelte";

	function create_fragment$6(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-1mdpnae");
	      add_location(p, file$6, 13, 2, 375);
	      attr_dev(div, "class", "MessageActionWebViewDataSentMe svelte-1mdpnae");
	      add_location(div, file$6, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$6.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$6($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionWebViewDataSentMe', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionWebViewDataSentMe> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionWebViewDataSentMe extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionWebViewDataSentMe",
	      options,
	      id: create_fragment$6.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionWebViewDataSentMe> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionWebViewDataSentMe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$5 = "src/widgets/message/action/MessageActionWebViewDataSent.svelte";

	function create_fragment$5(ctx) {
	  var div;
	  var p;
	  var t_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t = text(t_value);
	      attr_dev(p, "class", "svelte-6n8dj2");
	      add_location(p, file$5, 13, 2, 373);
	      attr_dev(div, "class", "MessageActionWebViewDataSent svelte-6n8dj2");
	      add_location(div, file$5, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t_value !== (t_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t, t_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$5.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$5($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageActionWebViewDataSent', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageActionWebViewDataSent> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class MessageActionWebViewDataSent extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageActionWebViewDataSent",
	      options,
	      id: create_fragment$5.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageActionWebViewDataSent> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<MessageActionWebViewDataSent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var file$4 = "src/widgets/message/action/Dummy.svelte";

	function create_fragment$4(ctx) {
	  var div;
	  var p;
	  var t0;
	  var t1_value =
	  /*message*/
	  ctx[0].action.className + "";
	  var t1;
	  var block = {
	    c: function create() {
	      div = element("div");
	      p = element("p");
	      t0 = text("WIP: ");
	      t1 = text(t1_value);
	      attr_dev(p, "class", "svelte-5qc57e");
	      add_location(p, file$4, 13, 2, 350);
	      attr_dev(div, "class", "Dummy svelte-5qc57e");
	      add_location(div, file$4, 12, 0, 328);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, p);
	      append_dev(p, t0);
	      append_dev(p, t1);
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*message*/
	      1 && t1_value !== (t1_value =
	      /*message*/
	      ctx[0].action.className + "")) set_data_dev(t1, t1_value);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$4($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Dummy', slots, []);
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  onMount(() => {}); // console.log(message);

	  var writable_props = ['chat', 'message', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dummy> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    chat,
	    message,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage
	  });

	  $$self.$inject_state = $$props => {
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(0, message = $$props.message);
	    if ('parentNavInstance' in $$props) $$invalidate(2, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(3, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(4, refetchMessage = $$props.refetchMessage);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [message, chat, parentNavInstance, registerCallButtonHandler, refetchMessage];
	}

	class Dummy extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$4, create_fragment$4, safe_not_equal, {
	      chat: 1,
	      message: 0,
	      parentNavInstance: 2,
	      registerCallButtonHandler: 3,
	      refetchMessage: 4
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Dummy",
	      options,
	      id: create_fragment$4.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[2] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<Dummy> was created without expected prop 'parentNavInstance'");
	    }
	  }

	  get chat() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set chat(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get message() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set message(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get parentNavInstance() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set parentNavInstance(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get registerCallButtonHandler() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set registerCallButtonHandler(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get refetchMessage() {
	    throw new Error("<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set refetchMessage(value) {
	    throw new Error("<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var Actions = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MessageActionEmpty: MessageActionEmpty,
		MessageActionChatCreate: MessageActionChatCreate,
		MessageActionChatEditTitle: MessageActionChatEditTitle,
		MessageActionChatEditPhoto: MessageActionChatEditPhoto,
		MessageActionChatDeletePhoto: MessageActionChatDeletePhoto,
		MessageActionChatAddUser: MessageActionChatAddUser,
		MessageActionChatDeleteUser: MessageActionChatDeleteUser,
		MessageActionChatJoinedByLink: MessageActionChatJoinedByLink,
		MessageActionChannelCreate: MessageActionChannelCreate,
		MessageActionChatMigrateTo: MessageActionChatMigrateTo,
		MessageActionChannelMigrateFrom: MessageActionChannelMigrateFrom,
		MessageActionPinMessage: MessageActionPinMessage,
		MessageActionHistoryClear: MessageActionHistoryClear,
		MessageActionGameScore: MessageActionGameScore,
		MessageActionPaymentSentMe: MessageActionPaymentSentMe,
		MessageActionPaymentSent: MessageActionPaymentSent,
		MessageActionPhoneCall: MessageActionPhoneCall,
		MessageActionScreenshotTaken: MessageActionScreenshotTaken,
		MessageActionCustomAction: MessageActionCustomAction,
		MessageActionBotAllowed: MessageActionBotAllowed,
		MessageActionSecureValuesSentMe: MessageActionSecureValuesSentMe,
		MessageActionSecureValuesSent: MessageActionSecureValuesSent,
		MessageActionContactSignUp: MessageActionContactSignUp,
		MessageActionGeoProximityReached: MessageActionGeoProximityReached,
		MessageActionGroupCall: MessageActionGroupCall,
		MessageActionInviteToGroupCall: MessageActionInviteToGroupCall,
		MessageActionSetMessagesTTL: MessageActionSetMessagesTTL,
		MessageActionGroupCallScheduled: MessageActionGroupCallScheduled,
		MessageActionSetChatTheme: MessageActionSetChatTheme,
		MessageActionChatJoinedByRequest: MessageActionChatJoinedByRequest,
		MessageActionWebViewDataSentMe: MessageActionWebViewDataSentMe,
		MessageActionWebViewDataSent: MessageActionWebViewDataSent,
		Dummy: Dummy
	});

	var file$3 = "src/widgets/message/MessageService.svelte";

	function create_fragment$3(ctx) {
	  var div1;
	  var div0;
	  var switch_instance;
	  var div1_class_value;
	  var current;
	  var mounted;
	  var dispose;
	  var switch_value =
	  /*resolveActionWidget*/
	  ctx[8](
	  /*message*/
	  ctx[2]);

	  function switch_props(ctx) {
	    return {
	      props: {
	        chat:
	        /*chat*/
	        ctx[1],
	        message:
	        /*message*/
	        ctx[2],
	        parentNavInstance:
	        /*parentNavInstance*/
	        ctx[5],
	        registerCallButtonHandler:
	        /*registerCallButtonHandler*/
	        ctx[6],
	        refetchMessage:
	        /*refetchMessage*/
	        ctx[7]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr_dev(div0, "class", "kai-list-view-content svelte-gay9lv");
	      add_location(div0, file$3, 33, 2, 1140);
	      attr_dev(div1, "data-key",
	      /*key*/
	      ctx[0]);
	      attr_dev(div1, "class", div1_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-gay9lv");
	      add_location(div1, file$3, 32, 0, 1045);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);

	      if (switch_instance) {
	        mount_component(switch_instance, div0, null);
	      }

	      current = true;

	      if (!mounted) {
	        dispose = listen_dev(div1, "click", function () {
	          if (is_function(
	          /*onClick*/
	          ctx[4]))
	            /*onClick*/
	            ctx[4].apply(this, arguments);
	        }, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      ctx = new_ctx;
	      var switch_instance_changes = {};
	      if (dirty &
	      /*chat*/
	      2) switch_instance_changes.chat =
	      /*chat*/
	      ctx[1];
	      if (dirty &
	      /*message*/
	      4) switch_instance_changes.message =
	      /*message*/
	      ctx[2];
	      if (dirty &
	      /*parentNavInstance*/
	      32) switch_instance_changes.parentNavInstance =
	      /*parentNavInstance*/
	      ctx[5];
	      if (dirty &
	      /*registerCallButtonHandler*/
	      64) switch_instance_changes.registerCallButtonHandler =
	      /*registerCallButtonHandler*/
	      ctx[6];
	      if (dirty &
	      /*refetchMessage*/
	      128) switch_instance_changes.refetchMessage =
	      /*refetchMessage*/
	      ctx[7];

	      if (switch_value !== (switch_value =
	      /*resolveActionWidget*/
	      ctx[8](
	      /*message*/
	      ctx[2]))) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, div0, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }

	      if (!current || dirty &
	      /*key*/
	      1) {
	        attr_dev(div1, "data-key",
	        /*key*/
	        ctx[0]);
	      }

	      if (!current || dirty &
	      /*className*/
	      8 && div1_class_value !== (div1_class_value = "kai-list-view " + (
	      /*className*/
	      ctx[3] ?
	      /*className*/
	      ctx[3] : '') + " svelte-gay9lv")) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div1);
	      if (switch_instance) destroy_component(switch_instance);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$3($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('MessageService', slots, []);
	  var _$$props$key = $$props.key,
	      key = _$$props$key === void 0 ? '' : _$$props$key;
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var _$$props$message = $$props.message,
	      message = _$$props$message === void 0 ? {} : _$$props$message;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? null : _$$props$className;
	  var _$$props$onClick = $$props.onClick,
	      onClick = _$$props$onClick === void 0 ? evt => {} : _$$props$onClick;
	  var parentNavInstance = $$props.parentNavInstance;
	  var _$$props$registerCall = $$props.registerCallButtonHandler,
	      registerCallButtonHandler = _$$props$registerCall === void 0 ? (id, callback) => {} : _$$props$registerCall;
	  var _$$props$refetchMessa = $$props.refetchMessage,
	      refetchMessage = _$$props$refetchMessa === void 0 ? id => {} : _$$props$refetchMessa;
	  var _$$props$destroyCallb = $$props.destroyCallback,
	      destroyCallback = _$$props$destroyCallb === void 0 ? () => {} : _$$props$destroyCallb;
	  var replyTo = $$props.replyTo;
	  var _$$props$short = $$props.short,
	      short = _$$props$short === void 0 ? false : _$$props$short;
	  var _$$props$scrollable = $$props.scrollable,
	      scrollable = _$$props$scrollable === void 0 ? false : _$$props$scrollable;
	  var replyThreadId = $$props.replyThreadId;
	  var navOptions = {
	    softkeyLeftListener(evt) {},

	    softkeyRightListener(evt) {},

	    enterListener(evt) {},

	    backspaceListener(evt) {}

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function resolveActionWidget(msg) {
	    if (Actions[msg.action.className]) return Actions[msg.action.className];
	    return Dummy;
	  }

	  onMount(() => {}); // console.log(message);

	  var writable_props = ['key', 'chat', 'message', 'className', 'onClick', 'parentNavInstance', 'registerCallButtonHandler', 'refetchMessage', 'destroyCallback', 'replyTo', 'short', 'scrollable', 'replyThreadId'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageService> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('destroyCallback' in $$props) $$invalidate(9, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(10, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(11, short = $$props.short);
	    if ('scrollable' in $$props) $$invalidate(12, scrollable = $$props.scrollable);
	    if ('replyThreadId' in $$props) $$invalidate(13, replyThreadId = $$props.replyThreadId);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    createKaiNavigator,
	    Actions,
	    key,
	    chat,
	    message,
	    className,
	    onClick,
	    parentNavInstance,
	    registerCallButtonHandler,
	    refetchMessage,
	    destroyCallback,
	    replyTo,
	    short,
	    scrollable,
	    replyThreadId,
	    navOptions,
	    navInstance,
	    resolveActionWidget
	  });

	  $$self.$inject_state = $$props => {
	    if ('key' in $$props) $$invalidate(0, key = $$props.key);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('message' in $$props) $$invalidate(2, message = $$props.message);
	    if ('className' in $$props) $$invalidate(3, className = $$props.className);
	    if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
	    if ('parentNavInstance' in $$props) $$invalidate(5, parentNavInstance = $$props.parentNavInstance);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(6, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('refetchMessage' in $$props) $$invalidate(7, refetchMessage = $$props.refetchMessage);
	    if ('destroyCallback' in $$props) $$invalidate(9, destroyCallback = $$props.destroyCallback);
	    if ('replyTo' in $$props) $$invalidate(10, replyTo = $$props.replyTo);
	    if ('short' in $$props) $$invalidate(11, short = $$props.short);
	    if ('scrollable' in $$props) $$invalidate(12, scrollable = $$props.scrollable);
	    if ('replyThreadId' in $$props) $$invalidate(13, replyThreadId = $$props.replyThreadId);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) navInstance = $$props.navInstance;
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [key, chat, message, className, onClick, parentNavInstance, registerCallButtonHandler, refetchMessage, resolveActionWidget, destroyCallback, replyTo, short, scrollable, replyThreadId];
	}

	class MessageService extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3, create_fragment$3, not_equal, {
	      key: 0,
	      chat: 1,
	      message: 2,
	      className: 3,
	      onClick: 4,
	      parentNavInstance: 5,
	      registerCallButtonHandler: 6,
	      refetchMessage: 7,
	      destroyCallback: 9,
	      replyTo: 10,
	      short: 11,
	      scrollable: 12,
	      replyThreadId: 13
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "MessageService",
	      options,
	      id: create_fragment$3.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*parentNavInstance*/
	    ctx[5] === undefined && !('parentNavInstance' in props)) {
	      console.warn("<MessageService> was created without expected prop 'parentNavInstance'");
	    }

	    if (
	    /*replyTo*/
	    ctx[10] === undefined && !('replyTo' in props)) {
	      console.warn("<MessageService> was created without expected prop 'replyTo'");
	    }

	    if (
	    /*replyThreadId*/
	    ctx[13] === undefined && !('replyThreadId' in props)) {
	      console.warn("<MessageService> was created without expected prop 'replyThreadId'");
	    }
	  }

	  get key() {
	    return this.$$.ctx[0];
	  }

	  set key(key) {
	    this.$$set({
	      key
	    });
	    flush();
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get message() {
	    return this.$$.ctx[2];
	  }

	  set message(message) {
	    this.$$set({
	      message
	    });
	    flush();
	  }

	  get className() {
	    return this.$$.ctx[3];
	  }

	  set className(className) {
	    this.$$set({
	      className
	    });
	    flush();
	  }

	  get onClick() {
	    return this.$$.ctx[4];
	  }

	  set onClick(onClick) {
	    this.$$set({
	      onClick
	    });
	    flush();
	  }

	  get parentNavInstance() {
	    return this.$$.ctx[5];
	  }

	  set parentNavInstance(parentNavInstance) {
	    this.$$set({
	      parentNavInstance
	    });
	    flush();
	  }

	  get registerCallButtonHandler() {
	    return this.$$.ctx[6];
	  }

	  set registerCallButtonHandler(registerCallButtonHandler) {
	    this.$$set({
	      registerCallButtonHandler
	    });
	    flush();
	  }

	  get refetchMessage() {
	    return this.$$.ctx[7];
	  }

	  set refetchMessage(refetchMessage) {
	    this.$$set({
	      refetchMessage
	    });
	    flush();
	  }

	  get destroyCallback() {
	    return this.$$.ctx[9];
	  }

	  set destroyCallback(destroyCallback) {
	    this.$$set({
	      destroyCallback
	    });
	    flush();
	  }

	  get replyTo() {
	    return this.$$.ctx[10];
	  }

	  set replyTo(replyTo) {
	    this.$$set({
	      replyTo
	    });
	    flush();
	  }

	  get short() {
	    return this.$$.ctx[11];
	  }

	  set short(short) {
	    this.$$set({
	      short
	    });
	    flush();
	  }

	  get scrollable() {
	    return this.$$.ctx[12];
	  }

	  set scrollable(scrollable) {
	    this.$$set({
	      scrollable
	    });
	    flush();
	  }

	  get replyThreadId() {
	    return this.$$.ctx[13];
	  }

	  set replyThreadId(replyThreadId) {
	    this.$$set({
	      replyThreadId
	    });
	    flush();
	  }

	}

	var Message = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Dummy: Dummy$2,
		Message: Message$1,
		MessageService: MessageService
	});

	var file$2 = "src/widgets/Replies.svelte";

	function get_each_context$1(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[16] = list[i];
	  return child_ctx;
	} // (77:6) {#each messages as message}


	function create_each_block$1(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value =
	  /*resolveMessageWidget*/
	  ctx[3](
	  /*message*/
	  ctx[16]);

	  function switch_props(ctx) {
	    return {
	      props: {
	        className: "replies",
	        message:
	        /*message*/
	        ctx[16],
	        registerCallButtonHandler:
	        /*registerCallButtonHandler*/
	        ctx[7],
	        parentNavInstance:
	        /*navInstance*/
	        ctx[8],
	        replyTo:
	        /*getReplyHeader*/
	        ctx[4](
	        /*message*/
	        ctx[16]),
	        chat:
	        /*chat*/
	        ctx[1],
	        short: false,
	        scrollable: false,
	        replyThreadId:
	        /*replyThreadId*/
	        ctx[5]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty &
	      /*messages*/
	      4) switch_instance_changes.message =
	      /*message*/
	      ctx[16];
	      if (dirty &
	      /*getReplyHeader, messages*/
	      20) switch_instance_changes.replyTo =
	      /*getReplyHeader*/
	      ctx[4](
	      /*message*/
	      ctx[16]);
	      if (dirty &
	      /*chat*/
	      2) switch_instance_changes.chat =
	      /*chat*/
	      ctx[1];
	      if (dirty &
	      /*replyThreadId*/
	      32) switch_instance_changes.replyThreadId =
	      /*replyThreadId*/
	      ctx[5];

	      if (switch_value !== (switch_value =
	      /*resolveMessageWidget*/
	      ctx[3](
	      /*message*/
	      ctx[16]))) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1.name,
	    type: "each",
	    source: "(77:6) {#each messages as message}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$2(ctx) {
	  var div3;
	  var div2;
	  var div0;
	  var t0;
	  var t1;
	  var div1;
	  var current;
	  var each_value =
	  /*messages*/
	  ctx[2];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      div3 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      t0 = text(
	      /*title*/
	      ctx[0]);
	      t1 = space();
	      div1 = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr_dev(div0, "class", "kai-option-menu-header svelte-1benrhe");
	      add_location(div0, file$2, 74, 4, 2036);
	      attr_dev(div1, "class", "kai-option-menu-body svelte-1benrhe");
	      attr_dev(div1, "data-pad-top", "66");
	      attr_dev(div1, "data-pad-bottom", "30");
	      add_location(div1, file$2, 75, 4, 2090);
	      attr_dev(div2, "class", "kai-option-menu-content svelte-1benrhe");
	      add_location(div2, file$2, 73, 2, 1994);
	      attr_dev(div3, "class", "kai-option-menu svelte-1benrhe");
	      add_location(div3, file$2, 72, 0, 1962);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      append_dev(div2, div0);
	      append_dev(div0, t0);
	      append_dev(div2, t1);
	      append_dev(div2, div1);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div1, null);
	      }
	      /*div1_binding*/


	      ctx[13](div1);
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (!current || dirty &
	      /*title*/
	      1) set_data_dev(t0,
	      /*title*/
	      ctx[0]);

	      if (dirty &
	      /*resolveMessageWidget, messages, registerCallButtonHandler, navInstance, getReplyHeader, chat, replyThreadId*/
	      446) {
	        each_value =
	        /*messages*/
	        ctx[2];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$1(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block$1(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(div1, null);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div3);
	      destroy_each(each_blocks, detaching);
	      /*div1_binding*/

	      ctx[13](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	var navClass = 'optionMenuNav';

	function instance$2($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Replies', slots, []);
	  var _$$props$title = $$props.title,
	      title = _$$props$title === void 0 ? 'Option Menu' : _$$props$title;
	  var _$$props$chat = $$props.chat,
	      chat = _$$props$chat === void 0 ? {} : _$$props$chat;
	  var messages = $$props.messages;
	  var _$$props$onBackspace = $$props.onBackspace,
	      onBackspace = _$$props$onBackspace === void 0 ? evt => {} : _$$props$onBackspace;
	  var _$$props$onOpened = $$props.onOpened,
	      onOpened = _$$props$onOpened === void 0 ? () => {} : _$$props$onOpened;
	  var _$$props$onClosed = $$props.onClosed,
	      onClosed = _$$props$onClosed === void 0 ? () => {} : _$$props$onClosed;
	  var _$$props$resolveMessa = $$props.resolveMessageWidget,
	      resolveMessageWidget = _$$props$resolveMessa === void 0 ? msg => {} : _$$props$resolveMessa;
	  var _$$props$getReplyHead = $$props.getReplyHeader,
	      getReplyHeader = _$$props$getReplyHead === void 0 ? msg => {} : _$$props$getReplyHead;
	  var replyThreadId = $$props.replyThreadId;
	  var softwareKey;
	  var nodeRef;

	  var registerCallButtonHandler = (id, callback) => {};

	  function setTitleText(text) {
	    $$invalidate(0, title = text);
	  }

	  var navOptions = {
	    arrowUpListener(evt) {
	      $$invalidate(6, nodeRef.scrollTop -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowDownListener(evt) {
	      $$invalidate(6, nodeRef.scrollTop += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowLeftListener(evt) {
	      $$invalidate(6, nodeRef.scrollLeft -= 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    arrowRightListener(evt) {
	      $$invalidate(6, nodeRef.scrollLeft += 20, nodeRef);
	      evt.preventDefault();
	      evt.stopPropagation();
	    },

	    softkeyLeftListener(evt) {},

	    softkeyRightListener(evt) {
	      onBackspace(evt);
	    },

	    backspaceListener(evt) {
	      onBackspace(evt);
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);
	  onMount(() => {
	    navInstance.attachListener();
	    softwareKey = new SoftwareKey({
	      target: document.body,
	      props: {
	        isInvert: true,
	        leftText: '',
	        centerText: '',
	        rightText: 'Close'
	      }
	    });
	    onOpened();
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    softwareKey.$destroy();
	    onClosed();
	  });
	  var writable_props = ['title', 'chat', 'messages', 'onBackspace', 'onOpened', 'onClosed', 'resolveMessageWidget', 'getReplyHeader', 'replyThreadId'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Replies> was created with unknown prop '${key}'`);
	  });

	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      nodeRef = $$value;
	      $$invalidate(6, nodeRef);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('messages' in $$props) $$invalidate(2, messages = $$props.messages);
	    if ('onBackspace' in $$props) $$invalidate(9, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(10, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(11, onClosed = $$props.onClosed);
	    if ('resolveMessageWidget' in $$props) $$invalidate(3, resolveMessageWidget = $$props.resolveMessageWidget);
	    if ('getReplyHeader' in $$props) $$invalidate(4, getReplyHeader = $$props.getReplyHeader);
	    if ('replyThreadId' in $$props) $$invalidate(5, replyThreadId = $$props.replyThreadId);
	  };

	  $$self.$capture_state = () => ({
	    onMount,
	    onDestroy,
	    createKaiNavigator,
	    SoftwareKey,
	    navClass,
	    title,
	    chat,
	    messages,
	    onBackspace,
	    onOpened,
	    onClosed,
	    resolveMessageWidget,
	    getReplyHeader,
	    replyThreadId,
	    softwareKey,
	    nodeRef,
	    registerCallButtonHandler,
	    setTitleText,
	    navOptions,
	    navInstance
	  });

	  $$self.$inject_state = $$props => {
	    if ('title' in $$props) $$invalidate(0, title = $$props.title);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('messages' in $$props) $$invalidate(2, messages = $$props.messages);
	    if ('onBackspace' in $$props) $$invalidate(9, onBackspace = $$props.onBackspace);
	    if ('onOpened' in $$props) $$invalidate(10, onOpened = $$props.onOpened);
	    if ('onClosed' in $$props) $$invalidate(11, onClosed = $$props.onClosed);
	    if ('resolveMessageWidget' in $$props) $$invalidate(3, resolveMessageWidget = $$props.resolveMessageWidget);
	    if ('getReplyHeader' in $$props) $$invalidate(4, getReplyHeader = $$props.getReplyHeader);
	    if ('replyThreadId' in $$props) $$invalidate(5, replyThreadId = $$props.replyThreadId);
	    if ('softwareKey' in $$props) softwareKey = $$props.softwareKey;
	    if ('nodeRef' in $$props) $$invalidate(6, nodeRef = $$props.nodeRef);
	    if ('registerCallButtonHandler' in $$props) $$invalidate(7, registerCallButtonHandler = $$props.registerCallButtonHandler);
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) $$invalidate(8, navInstance = $$props.navInstance);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [title, chat, messages, resolveMessageWidget, getReplyHeader, replyThreadId, nodeRef, registerCallButtonHandler, navInstance, onBackspace, onOpened, onClosed, setTitleText, div1_binding];
	}

	class Replies extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2, create_fragment$2, not_equal, {
	      title: 0,
	      chat: 1,
	      messages: 2,
	      onBackspace: 9,
	      onOpened: 10,
	      onClosed: 11,
	      resolveMessageWidget: 3,
	      getReplyHeader: 4,
	      replyThreadId: 5,
	      setTitleText: 12
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Replies",
	      options,
	      id: create_fragment$2.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*messages*/
	    ctx[2] === undefined && !('messages' in props)) {
	      console.warn("<Replies> was created without expected prop 'messages'");
	    }

	    if (
	    /*replyThreadId*/
	    ctx[5] === undefined && !('replyThreadId' in props)) {
	      console.warn("<Replies> was created without expected prop 'replyThreadId'");
	    }
	  }

	  get title() {
	    return this.$$.ctx[0];
	  }

	  set title(title) {
	    this.$$set({
	      title
	    });
	    flush();
	  }

	  get chat() {
	    return this.$$.ctx[1];
	  }

	  set chat(chat) {
	    this.$$set({
	      chat
	    });
	    flush();
	  }

	  get messages() {
	    return this.$$.ctx[2];
	  }

	  set messages(messages) {
	    this.$$set({
	      messages
	    });
	    flush();
	  }

	  get onBackspace() {
	    return this.$$.ctx[9];
	  }

	  set onBackspace(onBackspace) {
	    this.$$set({
	      onBackspace
	    });
	    flush();
	  }

	  get onOpened() {
	    return this.$$.ctx[10];
	  }

	  set onOpened(onOpened) {
	    this.$$set({
	      onOpened
	    });
	    flush();
	  }

	  get onClosed() {
	    return this.$$.ctx[11];
	  }

	  set onClosed(onClosed) {
	    this.$$set({
	      onClosed
	    });
	    flush();
	  }

	  get resolveMessageWidget() {
	    return this.$$.ctx[3];
	  }

	  set resolveMessageWidget(resolveMessageWidget) {
	    this.$$set({
	      resolveMessageWidget
	    });
	    flush();
	  }

	  get getReplyHeader() {
	    return this.$$.ctx[4];
	  }

	  set getReplyHeader(getReplyHeader) {
	    this.$$set({
	      getReplyHeader
	    });
	    flush();
	  }

	  get replyThreadId() {
	    return this.$$.ctx[5];
	  }

	  set replyThreadId(replyThreadId) {
	    this.$$set({
	      replyThreadId
	    });
	    flush();
	  }

	  get setTitleText() {
	    return this.$$.ctx[12];
	  }

	  set setTitleText(value) {
	    throw new Error("<Replies>: Cannot set read-only property 'setTitleText'");
	  }

	}

	/* src/routes/Room.svelte generated by Svelte v3.46.4 */
	var Object_1 = globals.Object,
	    console_1 = globals.console;
	var file$1 = "src/routes/Room.svelte";

	function get_each_context(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[53] = list[i];
	  return child_ctx;
	} // (1399:2) {:else}


	function create_else_block(ctx) {
	  var div;
	  var block = {
	    c: function create() {
	      div = element("div");
	      div.textContent = "Loading";
	      set_style(div, "margin-top", "45%");
	      add_location(div, file$1, 1399, 4, 62882);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block.name,
	    type: "else",
	    source: "(1399:2) {:else}",
	    ctx
	  });
	  return block;
	} // (1393:2) {#if ready }


	function create_if_block(ctx) {
	  var each_1_anchor;
	  var current;
	  var each_value =
	  /*messages*/
	  ctx[2];
	  validate_each_argument(each_value);
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	  }

	  var out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });

	  var block = {
	    c: function create() {
	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*resolveMessageWidget, messages, registerCallButtonHandler, refetchMessage, navInstance, getReplyHeader, chat, messageMetadata*/
	      510) {
	        each_value =
	        /*messages*/
	        ctx[2];
	        validate_each_argument(each_value);

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);

	            transition_in(each_blocks[_i3], 1);
	          } else {
	            each_blocks[_i3] = create_each_block(child_ctx);

	            each_blocks[_i3].c();

	            transition_in(each_blocks[_i3], 1);

	            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        group_outros();

	        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
	          out(_i3);
	        }

	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;

	      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
	        transition_in(each_blocks[_i4]);
	      }

	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        transition_out(each_blocks[_i5]);
	      }

	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach_dev(each_1_anchor);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block.name,
	    type: "if",
	    source: "(1393:2) {#if ready }",
	    ctx
	  });
	  return block;
	} // (1395:4) {#if message && message.id && messageMetadata[message.id.toString()] && messageMetadata[message.id.toString()].deleted === false}


	function create_if_block_1(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value =
	  /*resolveMessageWidget*/
	  ctx[5](
	  /*message*/
	  ctx[53]);

	  function switch_props(ctx) {
	    return {
	      props: {
	        className: "roomNav",
	        message:
	        /*message*/
	        ctx[53],
	        registerCallButtonHandler:
	        /*registerCallButtonHandler*/
	        ctx[6],
	        refetchMessage:
	        /*refetchMessage*/
	        ctx[7],
	        parentNavInstance:
	        /*navInstance*/
	        ctx[4],
	        replyTo:
	        /*getReplyHeader*/
	        ctx[8](
	        /*message*/
	        ctx[53]),
	        chat:
	        /*chat*/
	        ctx[1],
	        short: true,
	        scrollable: false,
	        replyThreadId: null
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty[0] &
	      /*messages*/
	      4) switch_instance_changes.message =
	      /*message*/
	      ctx[53];
	      if (dirty[0] &
	      /*navInstance*/
	      16) switch_instance_changes.parentNavInstance =
	      /*navInstance*/
	      ctx[4];
	      if (dirty[0] &
	      /*messages*/
	      4) switch_instance_changes.replyTo =
	      /*getReplyHeader*/
	      ctx[8](
	      /*message*/
	      ctx[53]);
	      if (dirty[0] &
	      /*chat*/
	      2) switch_instance_changes.chat =
	      /*chat*/
	      ctx[1];

	      if (switch_value !== (switch_value =
	      /*resolveMessageWidget*/
	      ctx[5](
	      /*message*/
	      ctx[53]))) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1.name,
	    type: "if",
	    source: "(1395:4) {#if message && message.id && messageMetadata[message.id.toString()] && messageMetadata[message.id.toString()].deleted === false}",
	    ctx
	  });
	  return block;
	} // (1394:2) {#each messages as message}


	function create_each_block(ctx) {
	  var show_if =
	  /*message*/
	  ctx[53] &&
	  /*message*/
	  ctx[53].id &&
	  /*messageMetadata*/
	  ctx[3][
	  /*message*/
	  ctx[53].id.toString()] &&
	  /*messageMetadata*/
	  ctx[3][
	  /*message*/
	  ctx[53].id.toString()].deleted === false;
	  var if_block_anchor;
	  var current;
	  var if_block = show_if && create_if_block_1(ctx);
	  var block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] &
	      /*messages, messageMetadata*/
	      12) show_if =
	      /*message*/
	      ctx[53] &&
	      /*message*/
	      ctx[53].id &&
	      /*messageMetadata*/
	      ctx[3][
	      /*message*/
	      ctx[53].id.toString()] &&
	      /*messageMetadata*/
	      ctx[3][
	      /*message*/
	      ctx[53].id.toString()].deleted === false;

	      if (show_if) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*messages, messageMetadata*/
	          12) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_1(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach_dev(if_block_anchor);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block.name,
	    type: "each",
	    source: "(1394:2) {#each messages as message}",
	    ctx
	  });
	  return block;
	}

	function create_fragment$1(ctx) {
	  var main;
	  var current_block_type_index;
	  var if_block;
	  var current;
	  var if_block_creators = [create_if_block, create_else_block];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*ready*/
	    ctx[0]) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  var block = {
	    c: function create() {
	      main = element("main");
	      if_block.c();
	      attr_dev(main, "id", "room-screen");
	      attr_dev(main, "data-pad-top", "50");
	      attr_dev(main, "data-pad-bottom", "30");
	      attr_dev(main, "class", "svelte-yfuvl7");
	      add_location(main, file$1, 1391, 0, 62337);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, main, anchor);
	      if_blocks[current_block_type_index].m(main, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(main, null);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(main);
	      if_blocks[current_block_type_index].d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance$1($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('Room', slots, []);

	  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = Promise))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  var location = $$props.location;
	  var navigate = $$props.navigate;
	  var getAppProp = $$props.getAppProp;
	  var sendMessageDialog;
	  var repliesDialog;
	  var contextMenu;
	  var deleteMessageDialog;
	  var replyButtons;
	  var entitiesMenu;
	  var fetchForwardedUsers = [];
	  var forwardedUsersIndex = [];
	  var cachedForwardedUsers = {};
	  var fetchForwardedChannels = [];
	  var forwardedChannelsIndex = [];
	  var cachedForwardedChannels = {};
	  var messagesToMerge = [];
	  var roomStack = [];
	  var scrollAt = 0;
	  var ready = false;
	  var chat;
	  var name = 'Room';
	  var messages = [];
	  var messageMetadata = {};
	  var pollMetadata = {};
	  var replyIndex = {};
	  var muteUntil = false;
	  var navOptions = {
	    verticalNavClass: 'roomNav',

	    softkeyLeftListener(evt) {
	      var msg = messages[navInstance.verticalNavIndex];
	      if (msg && msg.className === "Message") openContextMenu(msg, navInstance.verticalNavIndex);
	    },

	    softkeyRightListener(evt) {
	      if (!ready && chat == null) return; // send attachment + bot command
	    },

	    // send attachment + bot command
	    enterListener(evt) {
	      return __awaiter(this, void 0, void 0, function* () {
	        if (!ready && chat == null) return;

	        if (location.state.entity.className === 'Channel' && !location.state.entity.megagroup) {
	          // Channel
	          if (location.state.entity.creator) {
	            openSendMessage(null);
	          } else if (location.state.entity.left) {
	            joinChannel();
	          } else if (!location.state.entity.left) {
	            leaveChannel();
	          }
	        } else if (location.state.entity.className === 'Channel' && location.state.entity.megagroup) {
	          // Group
	          if (location.state.entity.left) {
	            joinChannel();
	          } else if (!location.state.entity.left) {
	            openSendMessage(null);
	          }
	        } else if (location.state.entity.bot && messages.length == 0) {
	          try {
	            var result = yield client.sendMessage(chat, {
	              message: "/start"
	            });
	            var tmessages = yield client.getMessages(chat, {
	              ids: result.id
	            });

	            if (tmessages.length > 0) {
	              pushMessageToMerge(tmessages[0]);
	            }
	          } catch (err) {
	            alert(err.errorMessage);
	          }
	        } else if (location.state.entity.className !== 'Channel') {
	          openSendMessage(null);
	        }
	      });
	    },

	    arrowUpListener: evt => __awaiter(void 0, void 0, void 0, function* () {
	      try {
	        if (ready && navInstance.verticalNavIndex !== 0) {
	          evt.preventDefault();
	          navInstance.navigateListNav(-1);
	          var msg = messages[navInstance.verticalNavIndex];
	          if (msg == null) return;
	          if (msg.markAsRead) msg.markAsRead();
	          updateScrollAt(msg);

	          if (navInstance.verticalNavIndex == 1) {
	            if (!ready) return;

	            if (window.confirm('Fetch previous messages ?')) {
	              var start = new Date().getTime();
	              var _msg = messages[navInstance.verticalNavIndex - 1];
	              var query = {
	                limit: 50,
	                maxId: _msg.id
	              };
	              var newMessages = yield client.getMessages(chat, query);

	              if (newMessages.length > 0) {
	                newMessages.reverse();
	                var temp = [...newMessages, ...messages];
	                $$invalidate(2, messages = yield buildIndex(temp));
	                $$invalidate(4, navInstance.verticalNavIndex = newMessages.length, navInstance);
	                setTimeout(() => {
	                  navInstance.navigateListNav(1);
	                }, 200);
	              }

	              console.log(`Fetch previous: ${new Date().getTime() - start}ms`);
	            }
	          }
	        }
	      } catch (err) {
	        console.log('arrowUpListener:', err);
	      }
	    }),
	    arrowDownListener: evt => __awaiter(void 0, void 0, void 0, function* () {
	      try {
	        if (ready && navInstance.verticalNavIndex !== Object.keys(messageMetadata).length - 1) {
	          evt.preventDefault();
	          navInstance.navigateListNav(1);
	          var msg = messages[navInstance.verticalNavIndex];
	          if (msg == null) return;
	          if (msg.markAsRead) msg.markAsRead();
	          updateScrollAt(msg);
	        } else {
	          if (!ready) return;

	          if (window.confirm('Fetch newest messages ?')) {
	            var start = new Date().getTime();
	            var _msg2 = messages[navInstance.verticalNavIndex];
	            var query = {
	              limit: 50,
	              minId: _msg2.id,
	              reverse: true
	            };
	            var newMessages = yield client.getMessages(chat, query);

	            if (newMessages.length > 0) {
	              var temp = [...messages, ...newMessages];
	              $$invalidate(2, messages = yield buildIndex(temp));
	            } else {
	              alert('No new messages');
	            }

	            console.log(`Fetch newest: ${new Date().getTime() - start}ms`);
	          }
	        }
	      } catch (err) {
	        console.log('arrowDownListener:', err);
	      }
	    }),

	    backspaceListener(evt) {
	      evt.preventDefault();

	      if (roomStack.length > 0) {
	        var prev = roomStack.pop();

	        var _getAppProp = getAppProp(),
	            appBar = _getAppProp.appBar;

	        $$invalidate(9, location.state.name = prev.name, location);
	        $$invalidate(9, location.state.entity = prev.entity, location);
	        $$invalidate(9, location.state.scrollAt = prev.scrollAt, location);
	        appBar.setTitleText(location.state.name);
	        fetchForwardedUsers = [];
	        forwardedUsersIndex = [];
	        cachedForwardedUsers = {};
	        fetchForwardedChannels = [];
	        forwardedChannelsIndex = [];
	        cachedForwardedChannels = {};
	        messagesToMerge = [];
	        $$invalidate(3, messageMetadata = {});
	        pollMetadata = {};
	        replyIndex = {};
	        $$invalidate(2, messages = []);
	        fetchMessages(location.state.entity, location.state.scrollAt);
	      } else {
	        shouldGetDialogs.update(n => true);
	        navigate(-1);
	      }
	    }

	  };
	  var navInstance = createKaiNavigator(navOptions);

	  function updateScrollAt(msg) {
	    return __awaiter(this, void 0, void 0, function* () {
	      scrollAt = msg.id;

	      try {
	        var chatId = chat.entity.id.value.toString();
	        var pref = yield (yield cachedDatabase).get('chatPreferences', chatId);
	        pref['scrollAt'] = msg.id;
	        (yield cachedDatabase).put('chatPreferences', pref, chatId);
	      } catch (err) {} // console.log('updateScrollAt:', err);

	    });
	  }

	  function joinChannel() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var _getAppProp2 = getAppProp(),
	            softwareKey = _getAppProp2.softwareKey;

	        var channels = yield client.invoke(new Api.channels.GetChannels({
	          id: [location.state.entity.id.value]
	        }));
	        yield client.invoke(new Api.channels.JoinChannel({
	          channel: channels.chats[0]
	        }));
	        $$invalidate(9, location.state.entity.left = false, location);

	        if (location.state.entity.className === 'Channel' && !location.state.entity.megagroup) {
	          // Channel
	          if (location.state.entity.creator) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'BROADCAST',
	              right: ''
	            });
	          } else if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SUB',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'UNSUB',
	              right: ''
	            });
	          }
	        } else if (location.state.entity.className === 'Channel' && location.state.entity.megagroup) {
	          // Group
	          if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'JOIN',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SEND',
	              right: ''
	            });
	          }
	        }
	      } catch (err) {
	        console.log('joinChannel', err);
	      }
	    });
	  }

	  function leaveChannel() {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (!confirm('Are you sure to leave ?')) {
	        return;
	      }

	      try {
	        var _getAppProp3 = getAppProp(),
	            softwareKey = _getAppProp3.softwareKey;

	        var channels = yield client.invoke(new Api.channels.GetChannels({
	          id: [location.state.entity.id.value]
	        }));
	        yield client.invoke(new Api.channels.LeaveChannel({
	          channel: channels.chats[0]
	        }));
	        $$invalidate(9, location.state.entity.left = true, location);

	        if (location.state.entity.className === 'Channel' && !location.state.entity.megagroup) {
	          // Channel
	          if (location.state.entity.creator) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'BROADCAST',
	              right: ''
	            });
	          } else if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SUB',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'UNSUB',
	              right: ''
	            });
	          }
	        } else if (location.state.entity.className === 'Channel' && location.state.entity.megagroup) {
	          // Group
	          if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'JOIN',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SEND',
	              right: ''
	            });
	          }
	        }
	      } catch (err) {
	        console.log('leaveChannel', err);
	      }
	    });
	  }

	  function openSendMessage() {
	    var messageEntity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var edit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    try {
	      sendMessageDialog = new TextAreaDialog({
	        target: document.body,
	        props: {
	          title: 'Message',
	          softKeyLeftText: messageEntity != null ? edit ? 'Save' : 'Reply' : 'Send',
	          softKeyCenterText: 'New line',
	          softKeyRightText: 'Cancel',
	          value: edit ? messageEntity.message : '',
	          placeholder: 'Enter you text',
	          type: 'text',
	          rows: 3,
	          onSoftkeyLeft: (evt, value) => __awaiter(this, void 0, void 0, function* () {
	            var msg = value.trim();

	            if (msg.length > 0) {
	              var _start = new Date().getTime();

	              sendMessageDialog.$destroy();
	              var result;

	              if (messageEntity && edit) {
	                result = yield client.editMessage(chat, {
	                  message: messageEntity.id,
	                  text: msg
	                });
	              } else if (messageEntity) {
	                result = yield messageEntity.reply({
	                  message: msg
	                });
	              } else {
	                result = yield client.sendMessage(chat, {
	                  message: msg
	                });
	              }

	              var tmessages = yield client.getMessages(chat, {
	                ids: result.id
	              });

	              if (tmessages.length > 0) {
	                if (edit && messageMetadata[tmessages[0].id.toString()]) {
	                  var idx = messageMetadata[tmessages[0].id.toString()].index;
	                  $$invalidate(2, messages[idx] = tmessages[0], messages);
	                  $$invalidate(2, messages = [...messages]);
	                } else {
	                  pushMessageToMerge(tmessages[0]);
	                }
	              }

	              console.log(`sendMessage: ${new Date().getTime() - _start}ms`);
	            }
	          }),
	          onSoftkeyRight: (evt, value) => {
	            sendMessageDialog.$destroy();
	          },
	          onEnter: (evt, value) => {},
	          onBackspace: (evt, value) => {
	            evt.stopPropagation();

	            if (value.length === 0) {
	              sendMessageDialog.$destroy();
	              evt.preventDefault();
	            }
	          },
	          onOpened: () => {
	            navInstance.detachListener();
	          },
	          onClosed: value => {
	            navInstance.attachListener();
	            sendMessageDialog = null;
	          }
	        }
	      });
	    } catch (err) {
	      console.log('openSendMessage:', err);
	    }
	  }

	  function showFull(msg, index) {
	    var className = new resolveMessageWidget(msg);
	    var full = new className({
	      target: document.body,
	      props: {
	        className: "",
	        message: msg,
	        registerCallButtonHandler: evt => {},
	        parentNavInstance: navInstance,
	        replyTo: getReplyHeader(msg),
	        chat,
	        short: false,
	        scrollable: true,
	        destroyCallback: () => {
	          full.$destroy();
	        }
	      }
	    });
	  }

	  function deleteMessage(msg, index) {
	    try {
	      deleteMessageDialog = new Dialog({
	        target: document.body,
	        props: {
	          title: 'Confirm',
	          body: 'Do you want to delete this message ?',
	          softKeyLeftText: 'Cancel',
	          softKeyCenterText: '',
	          softKeyRightText: 'Yes',
	          onSoftkeyLeft: evt => {
	            console.log('cancel');
	            deleteMessageDialog.$destroy();
	          },
	          onSoftkeyRight: evt => __awaiter(this, void 0, void 0, function* () {
	            yield client.deleteMessages(chat, [msg.id], {
	              revoke: true
	            });
	            var scroll = navInstance.verticalNavIndex !== Object.keys(messageMetadata).length - 1;
	            var pops = [];
	            var temp = [];
	            var id = msg.id;

	            if (messageMetadata[id.toString()]) {
	              $$invalidate(3, messageMetadata[id.toString()].deleted = true, messageMetadata);
	              pops.push(messageMetadata[id.toString()].index);
	              delete messageMetadata[id.toString()];
	              navInstance.navigateListNav(-1);
	            }

	            for (var i in messages) {
	              if (!isNaN(parseInt(i))) {
	                if (pops.indexOf(parseInt(i)) === -1) {
	                  temp.push(messages[i]);
	                }
	              }
	            }

	            if (temp.length > 0) {
	              $$invalidate(2, messages = yield buildIndex(temp));
	              if (scroll) autoScroll();
	            }

	            deleteMessageDialog.$destroy();
	          }),
	          onEnter: evt => {},
	          onBackspace: evt => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            deleteMessageDialog.$destroy();
	          },
	          onOpened: () => {
	            navInstance.detachListener();
	          },
	          onClosed: () => {
	            navInstance.attachListener();
	            deleteMessageDialog = null;
	          }
	        }
	      });
	    } catch (err) {
	      console.log('deleteMessage:', err);
	    }
	  }

	  function pinnedMessage(msg, index) {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        if (msg.pinned) yield msg.unpin();else yield msg.pin();
	        var tmessages = yield client.getMessages(chat, {
	          ids: msg.id
	        });

	        if (tmessages.length > 0) {
	          $$invalidate(2, messages[index] = tmessages[0], messages);
	          $$invalidate(2, messages = [...messages]);
	        }
	      } catch (err) {
	        console.log('pinnedMessage', err);
	      }
	    });
	  }

	  function showReplyButtons(msg) {
	    try {
	      var buttons = []; // ReplyKeyboardHide | ReplyKeyboardForceReply | ReplyKeyboardMarkup.row | ReplyInlineMarkup.row

	      msg.replyMarkup.rows.forEach(row => {
	        row.buttons.forEach(button => {
	          buttons.push({
	            title: button.text,
	            subtitle: null,
	            button
	          });
	        });
	      });
	      replyButtons = new OptionMenu({
	        target: document.body,
	        props: {
	          title: 'Reply Buttons',
	          focusIndex: 0,
	          options: buttons,
	          softKeyCenterText: 'select',
	          onSoftkeyRight: (evt, scope) => {},
	          onSoftkeyLeft: (evt, scope) => {},
	          onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	            replyButtons.$destroy(); // https://gram.js.org/beta/classes/Api.Message.html#click

	            var result = yield msg.click(scope.selected.button);

	            if (result) {
	              if (result.className && result.className === "messages.BotCallbackAnswer" && result.message) {
	                alert(result.message);
	              } else if (result.className && result.className === "messages.BotCallbackAnswer" && result.url || typeof result === 'string') {
	                handleTelegramLink(result.url || result);
	              } else if (result.className && result.className === "Message") {
	                pushMessageToMerge(result);
	              }
	            }
	          }),
	          onBackspace: (evt, scope) => {
	            evt.preventDefault();
	            evt.stopPropagation();
	            replyButtons.$destroy();
	          },
	          onOpened: () => {
	            navInstance.detachListener();
	          },
	          onClosed: scope => {
	            navInstance.attachListener();
	            replyButtons = null;
	          }
	        }
	      });
	    } catch (err) {
	      console.log('showReplyButtons:', err);
	    }
	  }

	  function handleTelegramLink(url) {
	    var parsed = new URL(url);

	    if (parsed.hostname.indexOf('t.me') > -1) {
	      var t_entity = parsed.hostname.split('.');

	      if (t_entity.length === 3) {
	        if (parsed.pathname == '/') {
	          openRoom(t_entity[0]);
	        } else {
	          var t_pathname = parsed.pathname.split('/');

	          if (t_pathname.length == 2) {
	            var scrollTo = parseInt(t_pathname[1]);
	            openRoom(t_entity[0], isNaN(scrollTo) ? null : scrollTo);
	          } else {
	            openRoom(t_entity[0]);
	          }
	        }
	      } else if (t_entity.length === 2 || parsed.hostname.indexOf('telegram.me') > -1) {
	        var _t_entity = parsed.pathname.split('/');

	        if (_t_entity.length == 2) {
	          openRoom(_t_entity[1]);
	        } else if (_t_entity.length == 3) {
	          var _scrollTo = parseInt(_t_entity[2]);

	          openRoom(_t_entity[1], isNaN(_scrollTo) ? null : _scrollTo);
	        } else {
	          window.open(url);
	        }
	      } else {
	        window.open(url);
	      }
	    } else {
	      window.open(url);
	    }
	  }

	  function openRoom(value, scrollTo) {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var entity = yield client.getEntity(value);
	        if (entity.id.value.toString() === location.state.entity.id.value.toString()) return;
	        roomStack.push({
	          name: location.state.name,
	          entity: location.state.entity,
	          scrollAt
	        });

	        var _getAppProp4 = getAppProp(),
	            appBar = _getAppProp4.appBar;

	        var _name = '';
	        if (entity.firstName) _name = entity.firstName;
	        if (entity.lastName) _name += ' ' + entity.lastName;
	        if (_name === '' && entity.username) _name = entity.username;else if (_name === '' && entity.phone) _name = entity.phone;else if (_name === '') _name = entity.id.value.toString();
	        $$invalidate(9, location.state.name = _name, location);
	        $$invalidate(9, location.state.entity = entity, location);
	        $$invalidate(9, location.state.scrollAt = scrollTo || null, location);
	        appBar.setTitleText(location.state.name || _name);
	        fetchForwardedUsers = [];
	        forwardedUsersIndex = [];
	        cachedForwardedUsers = {};
	        fetchForwardedChannels = [];
	        forwardedChannelsIndex = [];
	        cachedForwardedChannels = {};
	        messagesToMerge = [];
	        $$invalidate(3, messageMetadata = {});
	        pollMetadata = {};
	        replyIndex = {};
	        $$invalidate(2, messages = []);
	        fetchMessages(location.state.entity, location.state.scrollAt);
	      } catch (err) {
	        roomStack.pop();
	      }
	    });
	  }

	  function showEntities(entities) {
	    entitiesMenu = new OptionMenu({
	      target: document.body,
	      props: {
	        title: 'Entities',
	        focusIndex: 0,
	        options: entities,
	        softKeyCenterText: 'select',
	        onSoftkeyRight: (evt, scope) => {},
	        onSoftkeyLeft: (evt, scope) => {},
	        onEnter: (evt, scope) => __awaiter(this, void 0, void 0, function* () {
	          entitiesMenu.$destroy();

	          if (scope.selected.args.className === 'MessageEntityMention') {
	            openRoom(scope.selected.title.replace('@', ''));
	          } else if (scope.selected.args.className === 'MessageEntityBotCommand') {
	            try {
	              var result = yield client.sendMessage(chat, {
	                message: scope.selected.title
	              });
	              var tmessages = yield client.getMessages(chat, {
	                ids: result.id
	              });

	              if (tmessages.length > 0) {
	                pushMessageToMerge(tmessages[0]);
	              }
	            } catch (err) {
	              console.log('MessageEntityBotCommand:', err);
	            }
	          } else if (scope.selected.args.className === 'MessageEntityUrl') {
	            handleTelegramLink(scope.selected.title);
	          } else if (scope.selected.args.className === 'MessageEntityEmail') {
	            window.open(`mailto:${scope.selected.title}`);
	          } else if (scope.selected.args.className === 'MessageEntityTextUrl') {
	            window.open(scope.selected.args.url);
	          } else if (['MessageEntityMentionName', 'InputMessageEntityMentionName'].indexOf(scope.selected.args.className) > -1) {
	            openRoom(scope.selected.args.userId);
	          } else if (scope.selected.args.className === 'MessageEntityPhone') {
	            window.open(`tel:${scope.selected.title}`);
	          }
	        }),
	        onBackspace: (evt, scope) => {
	          evt.preventDefault();
	          evt.stopPropagation();
	          entitiesMenu.$destroy();
	        },
	        onOpened: () => {
	          navInstance.detachListener();
	        },
	        onClosed: scope => {
	          navInstance.attachListener();
	          entitiesMenu = null;
	        }
	      }
	    });
	  }

	  function archivingChat() {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (chat && chat.inputEntity) {
	        var folderId;

	        if (chat.archived) {
	          folderId = 0;
	        } else {
	          folderId = 1;
	        }

	        try {
	          var result = yield client.invoke(new Api.folders.EditPeerFolders({
	            folderPeers: [new Api.InputFolderPeer({
	              peer: chat.inputEntity,
	              folderId
	            })]
	          })); // console.log(result);

	          $$invalidate(1, chat.archived = !chat.archived, chat);
	        } catch (err) {
	          console.log(err);
	        }
	      }
	    });
	  }

	  function openContextMenu(msg, index) {
	    return __awaiter(this, void 0, void 0, function* () {
	      var entities = [];

	      if (msg.entities) {
	        msg.entities.forEach((e, i) => {
	          if (['MessageEntityMention', 'MessageEntityBotCommand', 'MessageEntityUrl', 'MessageEntityEmail', 'MessageEntityTextUrl', 'MessageEntityMentionName', 'InputMessageEntityMentionName', 'MessageEntityPhone'].indexOf(e.className) > -1) {
	            entities.push({
	              title: msg.message.substring(e.offset, e.offset + e.length),
	              subtitle: e.className,
	              args: e
	            });
	          }
	        });
	      }

	      try {
	        var user = yield getAuthorizedUser();
	        var menu = [];

	        if (entities.length > 0) {
	          menu.push({
	            title: 'Entities'
	          });
	        }

	        if (msg.media) {
	          menu.push({
	            title: 'Message Media'
	          });
	        }

	        if (msg.replyMarkup && msg.replyMarkup.rows) {
	          var show = true;

	          if (['ReplyKeyboardHide', 'ReplyKeyboardForceReply', 'ReplyKeyboardMarkup'].indexOf(msg.replyMarkup.className) > -1 && msg.replyMarkup.selective) {
	            show = false;
	          }

	          if (show) menu.push({
	            title: 'Show Reply Buttons'
	          });
	        }

	        menu.push({
	          title: 'Show Full'
	        });
	        var isReply = getReplyHeader(msg);

	        if (isReply !== false && isReply !== -1) {
	          menu.push({
	            title: 'Show Reply Header'
	          });
	        }

	        if (!msg.noforwards) {
	          menu.push({
	            title: 'Forward'
	          });
	        }

	        if (msg.replies && msg.replies.replies > 0) {
	          menu.push({
	            title: 'Discussion'
	          });
	        }

	        if (chat.entity.className === 'Channel' && chat.entity.creator || chat.entity.className === 'Channel' && chat.entity.megagroup && !chat.entity.left || chat.entity.className === 'User') {
	          menu.push({
	            title: 'Reply'
	          });
	        }

	        var sender = msg.sender || msg.__sender;

	        if (sender && sender.id.value.toString() === user[0].id.value.toString()) {
	          if ((new Date().getTime() - new Date(msg.date * 1000).getTime() < 172800000 || chat.entity.__isSavedMessages) && msg.fwdFrom == null) {
	            menu.push({
	              title: 'Edit'
	            });
	          }

	          menu.push({
	            title: 'Delete'
	          });
	        } else if (chat.entity.className === 'Channel' && chat.entity.creator || chat.entity.className === 'User') {
	          menu.push({
	            title: 'Delete'
	          });
	        }

	        if (msg.pinned && (chat.entity.className === 'Channel' && chat.entity.creator || chat.entity.className === 'User')) {
	          menu.push({
	            title: 'Unpin'
	          });
	        }

	        if (!msg.pinned && (chat.entity.className === 'Channel' && chat.entity.creator || chat.entity.className === 'User')) {
	          menu.push({
	            title: 'Pin'
	          });
	        }

	        if (chat.entity.className === 'Channel' && !chat.entity.left || chat.entity.className === 'User') {
	          if (muteUntil === false) {
	            menu.push({
	              title: 'Mute Chat'
	            });
	          } else {
	            menu.push({
	              title: 'Unmute Chat'
	            });
	          }
	        }

	        if (chat.archived) {
	          menu.push({
	            title: 'Unarchive'
	          });
	        } else {
	          menu.push({
	            title: 'Archive'
	          });
	        }

	        if (chat.entity.className === 'Channel') {
	          menu.push({
	            title: 'Report'
	          });
	        }

	        if (chat.entity.className === 'Channel' && chat.entity.megagroup && !chat.entity.left && !location.state.entity.creator) {
	          menu.push({
	            title: 'Leave Group'
	          });
	        }

	        contextMenu = new OptionMenu({
	          target: document.body,
	          props: {
	            title: 'Action',
	            focusIndex: 0,
	            options: menu,
	            softKeyCenterText: 'select',
	            onSoftkeyRight: (evt, scope) => {},
	            onSoftkeyLeft: (evt, scope) => {},
	            onEnter: (evt, scope) => {
	              contextMenu.$destroy();
	              setTimeout(() => __awaiter(this, void 0, void 0, function* () {
	                if (scope.selected.title === 'Entities') {
	                  showEntities(entities);
	                } else if (scope.selected.title === 'Message Media') {
	                  if (msg && msg.id.toString()) {
	                    if (messageMetadata[msg.id.toString()]) {
	                      var cb = messageMetadata[msg.id.toString()].callback;
	                      cb && cb();
	                    }
	                  }
	                } else if (scope.selected.title === 'Show Full' && msg.className === "Message") {
	                  showFull(msg, index);
	                } else if (scope.selected.title === 'Discussion' && msg.className === "Message" && msg.replies && msg.replies.replies > 0) {
	                  showReplies(msg);
	                } else if (scope.selected.title === 'Forward') {} else if (scope.selected.title === 'Reply') {
	                  openSendMessage(msg); // msg.forwardTo
	                } else if (scope.selected.title === 'Report') {} else if (scope.selected.title === 'Edit') {
	                  openSendMessage(msg, true); // msg.?
	                } else if (scope.selected.title === 'Delete') {
	                  deleteMessage(msg, index);
	                } else if (['Pin', 'Unpin'].indexOf(scope.selected.title) > -1) {
	                  pinnedMessage(msg, index);
	                } else if (scope.selected.title === 'Mute Chat') {} else if (scope.selected.title === 'Unmute Chat') {} else if (scope.selected.title === 'Show Reply Buttons') {
	                  showReplyButtons(msg); // chat.
	                  // chat.
	                } else if (scope.selected.title === 'Show Reply Header') {
	                  showReplies(getReplyHeader(msg), true);
	                } else if (scope.selected.title === 'Leave Group') {
	                  leaveChannel();
	                } else if (['Archive', 'Unarchive'].indexOf(scope.selected.title) > -1) {
	                  archivingChat();
	                }
	              }), 200);
	            },
	            onBackspace: (evt, scope) => {
	              evt.preventDefault();
	              evt.stopPropagation();
	              contextMenu.$destroy();
	            },
	            onOpened: () => {
	              navInstance.detachListener();
	            },
	            onClosed: scope => {
	              navInstance.attachListener();
	              contextMenu = null;
	            }
	          }
	        });
	      } catch (err) {
	        console.log('openContextMenu:'.err);
	      }
	    });
	  }

	  function showReplies(msg) {
	    var reply = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        if (msg.replies && msg.replies.replies > 0 || reply) {
	          var replies;

	          if (reply) {
	            replies = [msg];
	          } else {
	            var httpTasks = [];
	            var websocketTasks = [];
	            var fetchReply = [];
	            var query = {
	              limit: msg.replies.replies,
	              replyTo: msg.id
	            };
	            replies = yield client.getMessages(chat, query);
	            replies.forEach(message => {
	              var sender = message.sender || message.__sender;

	              if (!(location.state.entity.className === 'Channel' && !location.state.entity.megagroup)) {
	                if (sender && !(sender.username == null && sender.phone == null) && sender.photo != null && sender.photo.photoId) {
	                  message.iconRef = sender.photo.photoId.toString();
	                  httpTasks.push({
	                    url: `https://api.codetabs.com/v1/proxy/?quest=https://t.me/${sender.phone === "42777" ? 'telegram' : sender.username}`,
	                    photoId: sender.photo.photoId.toString(),
	                    chat: sender,
	                    origin: {
	                      chat,
	                      message
	                    }
	                  });
	                } else if (sender && sender.photo != null && sender.photo.photoId) {
	                  message.iconRef = sender.photo.photoId.toString();
	                  websocketTasks.push({
	                    photoId: sender.photo.photoId.toString(),
	                    chat: sender,
	                    origin: {
	                      chat,
	                      message
	                    }
	                  });
	                } // console.log(sender); // no username

	              }
	            });
	            runTask(httpTasks, websocketTasks); // non-blocking
	          }

	          repliesDialog = new Replies({
	            target: document.body,
	            props: {
	              replyThreadId: msg.id,
	              title: reply ? 'Reply' : 'Discussion',
	              chat,
	              messages: reply ? replies : [msg, ...replies.reverse()],
	              resolveMessageWidget,
	              getReplyHeader,
	              onBackspace: evt => {
	                evt.preventDefault();
	                evt.stopPropagation();
	                repliesDialog.$destroy();
	              },
	              onOpened: () => {
	                navInstance.detachListener();
	              },
	              onClosed: value => {
	                navInstance.attachListener();
	                repliesDialog = null;
	              }
	            }
	          });
	        }
	      } catch (err) {
	        console.log('showReplies:', err);
	      }
	    });
	  }

	  function resolveMessageWidget(m) {
	    if (Message[m.className]) return Message[m.className];
	    return Dummy$2;
	  }

	  function buildIndex(_messages) {
	    return __awaiter(this, void 0, void 0, function* () {
	      var _start_ = new Date().getTime();

	      forwardedUsersIndex = [];
	      forwardedChannelsIndex = [];
	      var httpTasks = [];
	      var websocketTasks = [];
	      var fetchReply = [];

	      _messages.forEach((message, index) => {
	        if (message && message.id) {
	          if (messageMetadata[message.id.toString()] == null) {
	            $$invalidate(3, messageMetadata[message.id.toString()] = {}, messageMetadata);
	          }

	          $$invalidate(3, messageMetadata[message.id.toString()].index = index, messageMetadata);
	          $$invalidate(3, messageMetadata[message.id.toString()].deleted = false, messageMetadata);

	          if (message.media && message.media.poll) {
	            pollMetadata[message.media.poll.id.value.toString()] = message.id.toString();
	          } // Skip for channel, only group or private chat


	          if (!(location.state.entity.className === 'Channel' && !location.state.entity.megagroup)) {
	            if (message.sender && message.sender.className === 'User' && cachedForwardedUsers[message.sender.id.value.toString()] == null) {
	              cachedForwardedUsers[message.sender.id.value.toString()] = message.sender;
	            } else if (message.sender && message.sender.className === 'Channel' && cachedForwardedChannels[message.sender.id.value.toString()] == null) {
	              cachedForwardedChannels[message.sender.id.value.toString()] = message.sender;
	            } else if (message.sender == null && message.senderId != null) {
	              if (cachedForwardedUsers[message.senderId.value.toString()]) {
	                // console.log('get sender from cachedForwardedUsers:', cachedForwardedUsers[message.senderId.value.toString()]);
	                message.__sender = cachedForwardedUsers[message.senderId.value.toString()];
	              } else if (cachedForwardedChannels[message.senderId.value.toString()]) {
	                // console.log('get sender from cachedForwardedChannels:', cachedForwardedChannels[message.senderId.value.toString()]);
	                message.__sender = cachedForwardedChannels[message.senderId.value.toString()];
	              }
	            }

	            var sender = message.sender || message.__sender;

	            if (!(location.state.entity.className === 'Channel' && !location.state.entity.megagroup)) {
	              if (sender && !(sender.username == null && sender.phone == null) && sender.photo != null && sender.photo.photoId) {
	                message.iconRef = sender.photo.photoId.toString();
	                httpTasks.push({
	                  url: `https://api.codetabs.com/v1/proxy/?quest=https://t.me/${sender.phone === "42777" ? 'telegram' : sender.username}`,
	                  photoId: sender.photo.photoId.toString(),
	                  chat: sender,
	                  origin: {
	                    chat,
	                    message
	                  }
	                });
	              } else if (sender && sender.photo != null && sender.photo.photoId) {
	                message.iconRef = sender.photo.photoId.toString();
	                websocketTasks.push({
	                  photoId: sender.photo.photoId.toString(),
	                  chat: sender,
	                  origin: {
	                    chat,
	                    message
	                  }
	                });
	              } // console.log(sender); // no username

	            }
	          }

	          if (message.fwdFrom) {
	            if (message.fwdFrom.fromName) {
	              delete message.iconRef;
	            } else if (message.fwdFrom.fromId) {
	              delete message.iconRef;

	              if (message.fwdFrom.fromId.className === 'PeerUser') {
	                if (cachedForwardedUsers[message.fwdFrom.fromId.userId.toString()] == null) {
	                  fetchForwardedUsers.push(message.fwdFrom.fromId);
	                }

	                forwardedUsersIndex.push(index);
	              } else if (message.fwdFrom.fromId.className === 'PeerChannel') {
	                if (cachedForwardedChannels[message.fwdFrom.fromId.channelId.toString()] == null) {
	                  fetchForwardedChannels.push(message.fwdFrom.fromId);
	                }

	                forwardedChannelsIndex.push(index);
	              }
	            }
	          }

	          if (message.replyTo) {
	            if (messageMetadata[message.replyTo.replyToMsgId.toString()]) {
	              replyIndex[message.replyTo.replyToMsgId.toString()] = messageMetadata[message.replyTo.replyToMsgId.toString()].index;
	            } else {
	              if (fetchReply.indexOf(message.replyTo.replyToMsgId) < 0) fetchReply.push(message.replyTo.replyToMsgId);
	            }
	          }
	        }
	      });

	      if (fetchReply.length > 0) {
	        var _start = new Date().getTime();

	        try {
	          var fmessages = yield client.getMessages(chat, {
	            ids: fetchReply
	          });
	          fetchReply.forEach((id, index) => {
	            replyIndex[id.toString()] = fmessages[index];
	          });
	        } catch (err) {
	          console.log('fetchReply:', err);
	        }

	        console.log(`fetchReply: ${new Date().getTime() - _start}ms`);
	      }

	      if (fetchForwardedUsers.length > 0) {
	        var _start2 = new Date().getTime();

	        try {
	          var users = yield client.invoke(new Api.users.GetUsers({
	            id: fetchForwardedUsers
	          }));
	          users.forEach(u => {
	            cachedForwardedUsers[u.id.toString()] = u;

	            if (!(u.username == null && u.phone == null) && u.photo != null && u.photo.photoId) {
	              httpTasks.push({
	                url: `https://api.codetabs.com/v1/proxy/?quest=https://t.me/${u.phone === "42777" ? 'telegram' : u.username}`,
	                photoId: u.photo.photoId.toString(),
	                chat: u
	              }); //origin: { chat, message }, // TODO
	            } else if (u.photo != null && u.photo.photoId) {
	              websocketTasks.push({
	                photoId: u.photo.photoId.toString(),
	                chat: u
	              }); //origin: { chat, message }, // TODO
	            } // console.log(u); // no username

	          });
	        } catch (err) {
	          console.log('fetchForwardedUsers:', err);
	        }

	        console.log(`fetchForwardedUsers: ${new Date().getTime() - _start2}ms`);
	      }

	      forwardedUsersIndex.forEach(i => {
	        try {
	          _messages[i].fwdFrom.sender = cachedForwardedUsers[_messages[i].fwdFrom.fromId.userId.toString()];

	          if (!(_messages[i].fwdFrom.sender.username == null && _messages[i].fwdFrom.sender.phone == null) && _messages[i].fwdFrom.sender.photo != null && _messages[i].fwdFrom.sender.photo.photoId) {
	            _messages[i].iconRef = _messages[i].fwdFrom.sender.photo.photoId.toString();
	          } else if (_messages[i].fwdFrom.sender.photo != null) {
	            _messages[i].iconRef = _messages[i].fwdFrom.sender.photo.photoId.toString();
	          }
	        } catch (err) {}
	      });
	      fetchForwardedUsers = [];

	      if (fetchForwardedChannels.length > 0) {
	        var _start3 = new Date().getTime();

	        try {
	          var channels = yield client.invoke(new Api.channels.GetChannels({
	            id: fetchForwardedChannels
	          }));
	          channels.chats.forEach(c => {
	            cachedForwardedChannels[c.id.toString()] = c;

	            if (!(c.username == null && c.phone == null) && c.photo != null && c.photo.photoId) {
	              httpTasks.push({
	                url: `https://api.codetabs.com/v1/proxy/?quest=https://t.me/${c.phone === "42777" ? 'telegram' : c.username}`,
	                photoId: c.photo.photoId.toString(),
	                chat: c
	              }); //origin: { chat, message }, // TODO
	            } else if (c.photo != null && c.photo.photoId) {
	              websocketTasks.push({
	                photoId: c.photo.photoId.toString(),
	                chat: c
	              }); //origin: { chat, message }, // TODO
	            }
	          });
	        } catch (err) {
	          console.log('fetchForwardedChannels:', err);
	        }

	        console.log(`fetchForwardedChannels: ${new Date().getTime() - _start3}ms`);
	      }

	      forwardedChannelsIndex.forEach(i => {
	        try {
	          _messages[i].fwdFrom.sender = cachedForwardedChannels[_messages[i].fwdFrom.fromId.channelId.toString()];

	          if (!(_messages[i].fwdFrom.sender.username == null && _messages[i].fwdFrom.sender.phone == null) && _messages[i].fwdFrom.sender.photo != null && _messages[i].fwdFrom.sender.photo.photoId) {
	            _messages[i].iconRef = _messages[i].fwdFrom.sender.photo.photoId.toString();
	          } else if (_messages[i].fwdFrom.sender.photo != null && _messages[i].fwdFrom.sender.photo.photoId) {
	            _messages[i].iconRef = _messages[i].fwdFrom.sender.photo.photoId.toString();
	          }
	        } catch (err) {}
	      });
	      fetchForwardedChannels = [];
	      runTask(httpTasks, websocketTasks); // non-blocking

	      console.log(`buildIndex: ${new Date().getTime() - _start_}ms`);
	      return _messages;
	    });
	  }

	  function registerCallButtonHandler(id, callback) {
	    if (messageMetadata[id]) {
	      $$invalidate(3, messageMetadata[id].callback = callback, messageMetadata);
	    }
	  }

	  function merging() {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        var msg = messagesToMerge.pop();
	        var temp = [...messages, msg];
	        $$invalidate(2, messages = yield buildIndex(temp));
	        autoScroll();
	      } catch (err) {
	        console.log('merging:', err);
	      }
	    });
	  }

	  function pushMessageToMerge(msg) {
	    console.log('pushMessageToMerge', msg.id);
	    var len = messagesToMerge.length;

	    if (len === 0) {
	      messagesToMerge.push(msg);
	    } else {
	      if (messagesToMerge[len - 1].date > msg.date) {
	        messagesToMerge = [msg, ...messagesToMerge];
	      } else {
	        messagesToMerge = [...messagesToMerge, msg];
	      }
	    }

	    if (len === 0) merging();
	  }

	  function refetchMessage(id) {
	    return __awaiter(this, void 0, void 0, function* () {
	      try {
	        id = id.toString();

	        if (messageMetadata[id] && messages[messageMetadata[id].index]) {
	          var update = yield client.getMessages(chat, {
	            ids: messages[messageMetadata[id].index].id
	          });

	          if (update.length > 0) {
	            $$invalidate(2, messages[messageMetadata[id].index] = update[0], messages);
	            $$invalidate(2, messages = [...messages]);
	          }
	        }
	      } catch (err) {
	        console.log('refetchMessage:', err);
	      }
	    });
	  }

	  function clientListener(evt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (chat.entity.__isSavedMessages) return;

	      try {
	        console.log('Room :', location.state.entity.id.value.toString(), evt.className, evt);

	        switch (evt.className) {
	          case "UpdateNotifySettings":
	            var id = evt.peer.peer.channelId ? evt.peer.peer.channelId.value.toString() : evt.peer.peer.userId.value.toString();
	            if (id !== chat.entity.id.value.toString()) break;

	            if (evt.notifySettings.muteUntil) {
	              muteUntil = new Date(new Date().getTime() + evt.notifySettings.muteUntil);
	            } else {
	              muteUntil = false;
	            } // console.log('muteUntil:', muteUntil);


	            break;

	          case 'UpdateMessagePoll':
	            if (pollMetadata[evt.pollId.value.toString()]) {
	              var _id = pollMetadata[evt.pollId.value.toString()];
	              var update = yield client.getMessages(chat, {
	                ids: messages[messageMetadata[_id].index].id
	              });

	              if (update.length > 0) {
	                $$invalidate(2, messages[messageMetadata[_id].index] = update[0], messages);
	                $$invalidate(2, messages = [...messages]);
	              }
	            }

	            break;

	          case 'UpdateShortMessage':
	            if (evt.userId && evt.userId.value.toString() === location.state.entity.id.value.toString()) {
	              var tmessages = yield client.getMessages(chat, {
	                ids: evt.id
	              });

	              if (tmessages.length > 0) {
	                pushMessageToMerge(tmessages[0]);
	              }
	            }

	            break;

	          case 'UpdateNewChannelMessage':
	          case 'UpdateNewMessage':
	            client.invoke(new Api.messages.ReceivedMessages({
	              maxId: evt.message.id
	            }));
	            var entities = Array.from(evt._entities.entries());

	            for (var i in entities) {
	              if (entities[i][1].id.toString() === location.state.entity.id.value.toString()) {
	                // Skip for channel, only group or private chat
	                if (!(location.state.entity.className === 'Channel' && !location.state.entity.megagroup)) {
	                  if (!cachedForwardedUsers[evt.message.senderId.value.toString()]) {
	                    var _start = new Date().getTime();

	                    var users = yield client.invoke(new Api.users.GetUsers({
	                      id: [evt.message.senderId.value.toString()]
	                    }));

	                    if (users.length > 0) {
	                      cachedForwardedUsers[users[0].id.toString()] = users[0];
	                    }

	                    console.log(`fetchuncachedforwardsuser: ${new Date().getTime() - _start}ms`);
	                  }
	                }

	                pushMessageToMerge(evt.message);
	                break;
	              }
	            }

	            break;

	          case 'UpdateEditChannelMessage':
	          case 'UpdateEditMessage':
	            var entities = Array.from(evt._entities.entries());

	            for (var _i6 in entities) {
	              if (entities[_i6][1].id.toString() === location.state.entity.id.value.toString()) {
	                if (messageMetadata[evt.message.id.toString()]) {
	                  var idx = messageMetadata[evt.message.id.toString()].index;
	                  $$invalidate(2, messages[idx] = evt.message, messages);
	                  $$invalidate(2, messages = [...messages]);
	                }

	                break;
	              }
	            }

	            break;

	          case 'UpdateDeleteChannelMessages':
	          case 'UpdateDeleteMessages':
	            var scroll = navInstance.verticalNavIndex !== Object.keys(messageMetadata).length - 1;
	            var pops = [];
	            var temp = [];
	            evt.messages.forEach(id => {
	              if (messageMetadata[id.toString()]) {
	                $$invalidate(3, messageMetadata[id.toString()].deleted = true, messageMetadata);
	                pops.push(messageMetadata[id.toString()].index);
	                delete messageMetadata[id.toString()];
	                navInstance.navigateListNav(-1);
	              }
	            });

	            for (var _i7 in messages) {
	              if (!isNaN(parseInt(_i7))) {
	                if (pops.indexOf(parseInt(_i7)) === -1) {
	                  temp.push(messages[_i7]);
	                }
	              }
	            }

	            if (temp.length > 0) {
	              $$invalidate(2, messages = yield buildIndex(temp));
	              if (scroll) autoScroll();
	            }

	            break;
	        }
	      } catch (err) {
	        console.log(evt.className + ':', err);
	      }
	    });
	  }

	  function autoScroll() {
	    setTimeout(() => {
	      if (Object.keys(messageMetadata).length - navInstance.verticalNavIndex === 2) navInstance.navigateListNav(1);
	    }, 500);
	  }

	  function getReplyHeader(message) {
	    if (message.replyTo == null) return false;

	    if (replyIndex[message.replyTo.replyToMsgId] || replyIndex[message.replyTo.replyToMsgId] === 0) {
	      if (typeof replyIndex[message.replyTo.replyToMsgId] === 'number') return messages[replyIndex[message.replyTo.replyToMsgId]];
	      return replyIndex[message.replyTo.replyToMsgId];
	    }

	    return -1;
	  }

	  function fetchMessages(entity, _scrollAt) {
	    return __awaiter(this, void 0, void 0, function* () {
	      var _getAppProp5 = getAppProp(),
	          softwareKey = _getAppProp5.softwareKey;

	      console.log('%cSTART', 'background: #222; color: #bada55');

	      var _start = new Date().getTime();

	      try {
	        var chats = yield getDialogList();
	        $$invalidate(1, chat = chats.find(chat => {
	          return chat.entity.id.value == entity.id.value;
	        }));

	        if (chat == null) {
	          $$invalidate(1, chat = {});

	          if (entity.className === 'User') {
	            var result = yield client.invoke(new Api.users.GetUsers({
	              id: [entity.id.value]
	            }));
	            $$invalidate(1, chat.entity = result[0], chat);
	            $$invalidate(1, chat.isChannel = false, chat);
	            $$invalidate(1, chat.isGroup = false, chat);
	            $$invalidate(1, chat.isUser = true, chat);
	          } else {
	            var _result = yield client.invoke(new Api.channels.GetChannels({
	              id: [entity.id.value]
	            }));

	            $$invalidate(1, chat.entity = _result.chats[0], chat);

	            if (entity.megagroup) {
	              $$invalidate(1, chat.isChannel = true, chat);
	              $$invalidate(1, chat.isGroup = true, chat);
	              $$invalidate(1, chat.isUser = false, chat);
	            } else {
	              $$invalidate(1, chat.isChannel = true, chat);
	              $$invalidate(1, chat.isGroup = false, chat);
	              $$invalidate(1, chat.isUser = false, chat);
	            }
	          }
	        } // console.log('isChannel:', chat.isChannel, ', isGroup:', chat.isGroup, ', isUser:', chat.isUser, chat, location.state.entity);
	        // console.log('muteUntil:', muteUntil);


	        if (chat.entity == null) $$invalidate(1, chat.entity = entity, chat);
	        if (chat.entity) muteUntil = chat.entity.__muted || false;
	        var latestMessages = [];
	        var msgToscrollAt = [];

	        if (_scrollAt != null) {
	          msgToscrollAt = yield client.getMessages(chat.entity, {
	            limit: 1,
	            ids: [_scrollAt]
	          });
	        }

	        if (msgToscrollAt.length == 0 || msgToscrollAt.length == 1 && msgToscrollAt[0] == null) {
	          latestMessages = yield client.getMessages(chat.entity, {
	            limit: 20
	          });
	        } else {
	          var minId = yield client.getMessages(chat.entity, {
	            limit: 10,
	            minId: _scrollAt,
	            reverse: true
	          });
	          minId.reverse();
	          var maxId = yield client.getMessages(chat.entity, {
	            limit: 10,
	            maxId: _scrollAt
	          });
	          latestMessages = [...minId, ...msgToscrollAt, ...maxId];
	        }

	        latestMessages.reverse();
	        $$invalidate(2, messages = yield buildIndex(latestMessages));

	        if (location.state.entity.className === 'Channel' && !location.state.entity.megagroup) {
	          // Channel
	          if (location.state.entity.creator) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'BROADCAST',
	              right: ''
	            });
	          } else if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SUB',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'UNSUB',
	              right: ''
	            });
	          }
	        } else if (location.state.entity.className === 'Channel' && location.state.entity.megagroup) {
	          // Group
	          if (location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'JOIN',
	              right: ''
	            });
	          } else if (!location.state.entity.left) {
	            softwareKey.setText({
	              left: 'Action',
	              center: 'SEND',
	              right: ''
	            });
	          }
	        } else if (location.state.entity.bot && messages.length == 0) {
	          softwareKey.setText({
	            left: 'Action',
	            center: 'START',
	            right: ''
	          });
	        } else {
	          softwareKey.setText({
	            left: 'Action',
	            center: 'SEND',
	            right: ''
	          });
	        }

	        var cursor = messages.findIndex(msg => {
	          return msg.id == _scrollAt;
	        });
	        if (cursor) cursor++;
	        $$invalidate(4, navInstance.verticalNavIndex = -1, navInstance);
	        navInstance.navigateListNav(1);
	        setTimeout(() => {
	          navInstance.navigateListNav(cursor || Object.keys(messageMetadata).length);

	          if (messages[navInstance.verticalNavIndex] && messages[navInstance.verticalNavIndex].markAsRead) {
	            messages[navInstance.verticalNavIndex].markAsRead();
	            scrollAt = messages[navInstance.verticalNavIndex].id;
	          }
	        }, 300);
	      } catch (err) {
	        console.log('fetchMessages:', err);
	      }

	      console.log(`fetchMessages: ${new Date().getTime() - _start}ms`);
	      console.log('%cFINISH', 'background: #222; color: #bada55');
	    });
	  }

	  afterUpdate(() => {
	    if (messagesToMerge.length > 0) merging();
	  });
	  onMount(() => {
	    var _getAppProp6 = getAppProp(),
	        appBar = _getAppProp6.appBar;
	        _getAppProp6.softwareKey;

	    appBar.setTitleText(location.state.name || name);
	    fetchMessages(location.state.entity, location.state.scrollAt);
	    navInstance.attachListener();
	    client.addEventHandler(clientListener);
	    $$invalidate(0, ready = true);
	  });
	  onDestroy(() => {
	    navInstance.detachListener();
	    client.removeEventHandler(clientListener);
	  });
	  var writable_props = ['location', 'navigate', 'getAppProp'];
	  Object_1.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Room> was created with unknown prop '${key}'`);
	  });

	  $$self.$$set = $$props => {
	    if ('location' in $$props) $$invalidate(9, location = $$props.location);
	    if ('navigate' in $$props) $$invalidate(10, navigate = $$props.navigate);
	    if ('getAppProp' in $$props) $$invalidate(11, getAppProp = $$props.getAppProp);
	  };

	  $$self.$capture_state = () => ({
	    __awaiter,
	    createKaiNavigator,
	    onMount,
	    onDestroy,
	    afterUpdate,
	    Api,
	    client,
	    cachedDatabase,
	    shouldGetDialogs,
	    getDialogList,
	    runTask,
	    getAuthorizedUser,
	    Message,
	    TextAreaDialog,
	    OptionMenu,
	    Dialog,
	    Replies,
	    location,
	    navigate,
	    getAppProp,
	    sendMessageDialog,
	    repliesDialog,
	    contextMenu,
	    deleteMessageDialog,
	    replyButtons,
	    entitiesMenu,
	    fetchForwardedUsers,
	    forwardedUsersIndex,
	    cachedForwardedUsers,
	    fetchForwardedChannels,
	    forwardedChannelsIndex,
	    cachedForwardedChannels,
	    messagesToMerge,
	    roomStack,
	    scrollAt,
	    ready,
	    chat,
	    name,
	    messages,
	    messageMetadata,
	    pollMetadata,
	    replyIndex,
	    muteUntil,
	    navOptions,
	    navInstance,
	    updateScrollAt,
	    joinChannel,
	    leaveChannel,
	    openSendMessage,
	    showFull,
	    deleteMessage,
	    pinnedMessage,
	    showReplyButtons,
	    handleTelegramLink,
	    openRoom,
	    showEntities,
	    archivingChat,
	    openContextMenu,
	    showReplies,
	    resolveMessageWidget,
	    buildIndex,
	    registerCallButtonHandler,
	    merging,
	    pushMessageToMerge,
	    refetchMessage,
	    clientListener,
	    autoScroll,
	    getReplyHeader,
	    fetchMessages
	  });

	  $$self.$inject_state = $$props => {
	    if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	    if ('location' in $$props) $$invalidate(9, location = $$props.location);
	    if ('navigate' in $$props) $$invalidate(10, navigate = $$props.navigate);
	    if ('getAppProp' in $$props) $$invalidate(11, getAppProp = $$props.getAppProp);
	    if ('sendMessageDialog' in $$props) sendMessageDialog = $$props.sendMessageDialog;
	    if ('repliesDialog' in $$props) repliesDialog = $$props.repliesDialog;
	    if ('contextMenu' in $$props) contextMenu = $$props.contextMenu;
	    if ('deleteMessageDialog' in $$props) deleteMessageDialog = $$props.deleteMessageDialog;
	    if ('replyButtons' in $$props) replyButtons = $$props.replyButtons;
	    if ('entitiesMenu' in $$props) entitiesMenu = $$props.entitiesMenu;
	    if ('fetchForwardedUsers' in $$props) fetchForwardedUsers = $$props.fetchForwardedUsers;
	    if ('forwardedUsersIndex' in $$props) forwardedUsersIndex = $$props.forwardedUsersIndex;
	    if ('cachedForwardedUsers' in $$props) cachedForwardedUsers = $$props.cachedForwardedUsers;
	    if ('fetchForwardedChannels' in $$props) fetchForwardedChannels = $$props.fetchForwardedChannels;
	    if ('forwardedChannelsIndex' in $$props) forwardedChannelsIndex = $$props.forwardedChannelsIndex;
	    if ('cachedForwardedChannels' in $$props) cachedForwardedChannels = $$props.cachedForwardedChannels;
	    if ('messagesToMerge' in $$props) messagesToMerge = $$props.messagesToMerge;
	    if ('roomStack' in $$props) roomStack = $$props.roomStack;
	    if ('scrollAt' in $$props) scrollAt = $$props.scrollAt;
	    if ('ready' in $$props) $$invalidate(0, ready = $$props.ready);
	    if ('chat' in $$props) $$invalidate(1, chat = $$props.chat);
	    if ('name' in $$props) name = $$props.name;
	    if ('messages' in $$props) $$invalidate(2, messages = $$props.messages);
	    if ('messageMetadata' in $$props) $$invalidate(3, messageMetadata = $$props.messageMetadata);
	    if ('pollMetadata' in $$props) pollMetadata = $$props.pollMetadata;
	    if ('replyIndex' in $$props) replyIndex = $$props.replyIndex;
	    if ('muteUntil' in $$props) muteUntil = $$props.muteUntil;
	    if ('navOptions' in $$props) navOptions = $$props.navOptions;
	    if ('navInstance' in $$props) $$invalidate(4, navInstance = $$props.navInstance);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [ready, chat, messages, messageMetadata, navInstance, resolveMessageWidget, registerCallButtonHandler, refetchMessage, getReplyHeader, location, navigate, getAppProp];
	}

	class Room extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1, create_fragment$1, not_equal, {
	      location: 9,
	      navigate: 10,
	      getAppProp: 11
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Room",
	      options,
	      id: create_fragment$1.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*location*/
	    ctx[9] === undefined && !('location' in props)) {
	      console_1.warn("<Room> was created without expected prop 'location'");
	    }

	    if (
	    /*navigate*/
	    ctx[10] === undefined && !('navigate' in props)) {
	      console_1.warn("<Room> was created without expected prop 'navigate'");
	    }

	    if (
	    /*getAppProp*/
	    ctx[11] === undefined && !('getAppProp' in props)) {
	      console_1.warn("<Room> was created without expected prop 'getAppProp'");
	    }
	  }

	  get location() {
	    return this.$$.ctx[9];
	  }

	  set location(location) {
	    this.$$set({
	      location
	    });
	    flush();
	  }

	  get navigate() {
	    return this.$$.ctx[10];
	  }

	  set navigate(navigate) {
	    this.$$set({
	      navigate
	    });
	    flush();
	  }

	  get getAppProp() {
	    return this.$$.ctx[11];
	  }

	  set getAppProp(getAppProp) {
	    this.$$set({
	      getAppProp
	    });
	    flush();
	  }

	}

	/* global window, exports, define */
	var sprintf = createCommonjsModule(function (module, exports) {
	  !function () {

	    var re = {
	      not_string: /[^s]/,
	      not_bool: /[^t]/,
	      not_type: /[^T]/,
	      not_primitive: /[^v]/,
	      number: /[diefg]/,
	      numeric_arg: /[bcdiefguxX]/,
	      json: /[j]/,
	      not_json: /[^j]/,
	      text: /^[^\x25]+/,
	      modulo: /^\x25{2}/,
	      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
	      key: /^([a-z_][a-z_\d]*)/i,
	      key_access: /^\.([a-z_][a-z_\d]*)/i,
	      index_access: /^\[(\d+)\]/,
	      sign: /^[+-]/
	    };

	    function sprintf(key) {
	      // `arguments` is not an array, but should be fine for this call
	      return sprintf_format(sprintf_parse(key), arguments);
	    }

	    function vsprintf(fmt, argv) {
	      return sprintf.apply(null, [fmt].concat(argv || []));
	    }

	    function sprintf_format(parse_tree, argv) {
	      var cursor = 1,
	          tree_length = parse_tree.length,
	          arg,
	          output = '',
	          i,
	          k,
	          ph,
	          pad,
	          pad_character,
	          pad_length,
	          is_positive,
	          sign;

	      for (i = 0; i < tree_length; i++) {
	        if (typeof parse_tree[i] === 'string') {
	          output += parse_tree[i];
	        } else if (typeof parse_tree[i] === 'object') {
	          ph = parse_tree[i]; // convenience purposes only

	          if (ph.keys) {
	            // keyword argument
	            arg = argv[cursor];

	            for (k = 0; k < ph.keys.length; k++) {
	              if (arg == undefined) {
	                throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
	              }

	              arg = arg[ph.keys[k]];
	            }
	          } else if (ph.param_no) {
	            // positional argument (explicit)
	            arg = argv[ph.param_no];
	          } else {
	            // positional argument (implicit)
	            arg = argv[cursor++];
	          }

	          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
	            arg = arg();
	          }

	          if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
	            throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
	          }

	          if (re.number.test(ph.type)) {
	            is_positive = arg >= 0;
	          }

	          switch (ph.type) {
	            case 'b':
	              arg = parseInt(arg, 10).toString(2);
	              break;

	            case 'c':
	              arg = String.fromCharCode(parseInt(arg, 10));
	              break;

	            case 'd':
	            case 'i':
	              arg = parseInt(arg, 10);
	              break;

	            case 'j':
	              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
	              break;

	            case 'e':
	              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
	              break;

	            case 'f':
	              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
	              break;

	            case 'g':
	              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
	              break;

	            case 'o':
	              arg = (parseInt(arg, 10) >>> 0).toString(8);
	              break;

	            case 's':
	              arg = String(arg);
	              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
	              break;

	            case 't':
	              arg = String(!!arg);
	              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
	              break;

	            case 'T':
	              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
	              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
	              break;

	            case 'u':
	              arg = parseInt(arg, 10) >>> 0;
	              break;

	            case 'v':
	              arg = arg.valueOf();
	              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
	              break;

	            case 'x':
	              arg = (parseInt(arg, 10) >>> 0).toString(16);
	              break;

	            case 'X':
	              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
	              break;
	          }

	          if (re.json.test(ph.type)) {
	            output += arg;
	          } else {
	            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
	              sign = is_positive ? '+' : '-';
	              arg = arg.toString().replace(re.sign, '');
	            } else {
	              sign = '';
	            }

	            pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
	            pad_length = ph.width - (sign + arg).length;
	            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
	            output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
	          }
	        }
	      }

	      return output;
	    }

	    var sprintf_cache = Object.create(null);

	    function sprintf_parse(fmt) {
	      if (sprintf_cache[fmt]) {
	        return sprintf_cache[fmt];
	      }

	      var _fmt = fmt,
	          match,
	          parse_tree = [],
	          arg_names = 0;

	      while (_fmt) {
	        if ((match = re.text.exec(_fmt)) !== null) {
	          parse_tree.push(match[0]);
	        } else if ((match = re.modulo.exec(_fmt)) !== null) {
	          parse_tree.push('%');
	        } else if ((match = re.placeholder.exec(_fmt)) !== null) {
	          if (match[2]) {
	            arg_names |= 1;
	            var field_list = [],
	                replacement_field = match[2],
	                field_match = [];

	            if ((field_match = re.key.exec(replacement_field)) !== null) {
	              field_list.push(field_match[1]);

	              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                  field_list.push(field_match[1]);
	                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                  field_list.push(field_match[1]);
	                } else {
	                  throw new SyntaxError('[sprintf] failed to parse named argument key');
	                }
	              }
	            } else {
	              throw new SyntaxError('[sprintf] failed to parse named argument key');
	            }

	            match[2] = field_list;
	          } else {
	            arg_names |= 2;
	          }

	          if (arg_names === 3) {
	            throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
	          }

	          parse_tree.push({
	            placeholder: match[0],
	            param_no: match[1],
	            keys: match[2],
	            sign: match[3],
	            pad_char: match[4],
	            align: match[5],
	            width: match[6],
	            precision: match[7],
	            type: match[8]
	          });
	        } else {
	          throw new SyntaxError('[sprintf] unexpected placeholder');
	        }

	        _fmt = _fmt.substring(match[0].length);
	      }

	      return sprintf_cache[fmt] = parse_tree;
	    }
	    /**
	     * export to either browser or node.js
	     */

	    /* eslint-disable quote-props */


	    {
	      exports['sprintf'] = sprintf;
	      exports['vsprintf'] = vsprintf;
	    }

	    if (typeof window !== 'undefined') {
	      window['sprintf'] = sprintf;
	      window['vsprintf'] = vsprintf;
	    }
	    /* eslint-enable quote-props */

	  }(); // eslint-disable-line
	});

	class Localization {
	  constructor(locale, namespace) {
	    this.locales = {};
	    this.defaultLocale = locale;
	    this.namespace = namespace;
	    this.loadLocale(this.defaultLocale);
	  }

	  loadLocale(locale) {
	    var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.location.origin;

	    if (cache && this.locales[locale] != null) {
	      this.defaultLocale = locale;
	      return true;
	    } else {
	      var url = [];
	      url.push(origin);
	      if (this.namespace !== '' && origin === document.location.origin) url.push(this.namespace);
	      url.push(`${locale}.json`);
	      var request = new XMLHttpRequest();
	      request.open('GET', url.join('/'), false);
	      request.send(null);

	      if (request.readyState === 4 && request.status >= 200 && request.status <= 399) {
	        this.defaultLocale = locale;
	        this.locales[this.defaultLocale] = JSON.parse(request.responseText);
	        return true;
	      } else if (request.readyState === 4) {
	        return false;
	      }
	    }
	  }

	  lang(key) {
	    var line = this.locales[this.defaultLocale][key];
	    if (line == null) return false;

	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    return sprintf.sprintf(line, ...args);
	  }

	  langByLocale(key, locale) {
	    if (this.locales[locale] == null) return false;
	    var line = this.locales[locale][key];
	    if (line == null) return false;

	    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	      args[_key2 - 2] = arguments[_key2];
	    }

	    return sprintf.sprintf(line, ...args);
	  }

	  getLocaleTranslation(locale) {
	    return this.locales[locale];
	  }

	}

	var file = "src/App.svelte"; // (21:4) <Route primary={false} path="index.html" let:location let:navigate>

	function create_default_slot_3(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value = Home;

	  function switch_props(ctx) {
	    return {
	      props: {
	        location:
	        /*location*/
	        ctx[6],
	        navigate:
	        /*navigate*/
	        ctx[7],
	        getAppProp:
	        /*getAppProp*/
	        ctx[2]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty &
	      /*location*/
	      64) switch_instance_changes.location =
	      /*location*/
	      ctx[6];
	      if (dirty &
	      /*navigate*/
	      128) switch_instance_changes.navigate =
	      /*navigate*/
	      ctx[7];

	      if (switch_value !== (switch_value = Home)) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_3.name,
	    type: "slot",
	    source: "(21:4) <Route primary={false} path=\\\"index.html\\\" let:location let:navigate>",
	    ctx
	  });
	  return block;
	} // (24:4) <Route primary={false} path="/" let:location let:navigate>


	function create_default_slot_2(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value = Home;

	  function switch_props(ctx) {
	    return {
	      props: {
	        location:
	        /*location*/
	        ctx[6],
	        navigate:
	        /*navigate*/
	        ctx[7],
	        getAppProp:
	        /*getAppProp*/
	        ctx[2]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty &
	      /*location*/
	      64) switch_instance_changes.location =
	      /*location*/
	      ctx[6];
	      if (dirty &
	      /*navigate*/
	      128) switch_instance_changes.navigate =
	      /*navigate*/
	      ctx[7];

	      if (switch_value !== (switch_value = Home)) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_2.name,
	    type: "slot",
	    source: "(24:4) <Route primary={false} path=\\\"/\\\" let:location let:navigate>",
	    ctx
	  });
	  return block;
	} // (27:4) <Route primary={false} path="room" let:location let:navigate>


	function create_default_slot_1(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_value = Room;

	  function switch_props(ctx) {
	    return {
	      props: {
	        location:
	        /*location*/
	        ctx[6],
	        navigate:
	        /*navigate*/
	        ctx[7],
	        getAppProp:
	        /*getAppProp*/
	        ctx[2]
	      },
	      $$inline: true
	    };
	  }

	  if (switch_value) {
	    switch_instance = new switch_value(switch_props(ctx));
	  }

	  var block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) {
	        mount_component(switch_instance, target, anchor);
	      }

	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty &
	      /*location*/
	      64) switch_instance_changes.location =
	      /*location*/
	      ctx[6];
	      if (dirty &
	      /*navigate*/
	      128) switch_instance_changes.navigate =
	      /*navigate*/
	      ctx[7];

	      if (switch_value !== (switch_value = Room)) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = new switch_value(switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_1.name,
	    type: "slot",
	    source: "(27:4) <Route primary={false} path=\\\"room\\\" let:location let:navigate>",
	    ctx
	  });
	  return block;
	} // (17:0) <Router>


	function create_default_slot(ctx) {
	  var div;
	  var t0;
	  var appbar;
	  var t1;
	  var main;
	  var route0;
	  var t2;
	  var route1;
	  var t3;
	  var route2;
	  var t4;
	  var softwarekey;
	  var current;
	  var appbar_props = {};
	  appbar = new AppBar({
	    props: appbar_props,
	    $$inline: true
	  });
	  /*appbar_binding*/

	  ctx[4](appbar);
	  route0 = new Route$1({
	    props: {
	      primary: false,
	      path: "index.html",
	      $$slots: {
	        default: [create_default_slot_3, _ref => {
	          var location = _ref.location,
	              navigate = _ref.navigate;
	          return {
	            6: location,
	            7: navigate
	          };
	        }, _ref2 => {
	          var location = _ref2.location,
	              navigate = _ref2.navigate;
	          return (location ? 64 : 0) | (navigate ? 128 : 0);
	        }]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  route1 = new Route$1({
	    props: {
	      primary: false,
	      path: "/",
	      $$slots: {
	        default: [create_default_slot_2, _ref3 => {
	          var location = _ref3.location,
	              navigate = _ref3.navigate;
	          return {
	            6: location,
	            7: navigate
	          };
	        }, _ref4 => {
	          var location = _ref4.location,
	              navigate = _ref4.navigate;
	          return (location ? 64 : 0) | (navigate ? 128 : 0);
	        }]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  route2 = new Route$1({
	    props: {
	      primary: false,
	      path: "room",
	      $$slots: {
	        default: [create_default_slot_1, _ref5 => {
	          var location = _ref5.location,
	              navigate = _ref5.navigate;
	          return {
	            6: location,
	            7: navigate
	          };
	        }, _ref6 => {
	          var location = _ref6.location,
	              navigate = _ref6.navigate;
	          return (location ? 64 : 0) | (navigate ? 128 : 0);
	        }]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var softwarekey_props = {};
	  softwarekey = new SoftwareKey({
	    props: softwarekey_props,
	    $$inline: true
	  });
	  /*softwarekey_binding*/

	  ctx[5](softwarekey);
	  var block = {
	    c: function create() {
	      div = element("div");
	      t0 = space();
	      create_component(appbar.$$.fragment);
	      t1 = space();
	      main = element("main");
	      create_component(route0.$$.fragment);
	      t2 = space();
	      create_component(route1.$$.fragment);
	      t3 = space();
	      create_component(route2.$$.fragment);
	      t4 = space();
	      create_component(softwarekey.$$.fragment);
	      attr_dev(div, "id", "kai-status-bar");
	      attr_dev(div, "class", "svelte-yeprez");
	      add_location(div, file, 17, 2, 518);
	      attr_dev(main, "class", "svelte-yeprez");
	      add_location(main, file, 19, 2, 584);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      insert_dev(target, t0, anchor);
	      mount_component(appbar, target, anchor);
	      insert_dev(target, t1, anchor);
	      insert_dev(target, main, anchor);
	      mount_component(route0, main, null);
	      append_dev(main, t2);
	      mount_component(route1, main, null);
	      append_dev(main, t3);
	      mount_component(route2, main, null);
	      insert_dev(target, t4, anchor);
	      mount_component(softwarekey, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      var appbar_changes = {};
	      appbar.$set(appbar_changes);
	      var route0_changes = {};

	      if (dirty &
	      /*$$scope, location, navigate*/
	      448) {
	        route0_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      route0.$set(route0_changes);
	      var route1_changes = {};

	      if (dirty &
	      /*$$scope, location, navigate*/
	      448) {
	        route1_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      route1.$set(route1_changes);
	      var route2_changes = {};

	      if (dirty &
	      /*$$scope, location, navigate*/
	      448) {
	        route2_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      route2.$set(route2_changes);
	      var softwarekey_changes = {};
	      softwarekey.$set(softwarekey_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(appbar.$$.fragment, local);
	      transition_in(route0.$$.fragment, local);
	      transition_in(route1.$$.fragment, local);
	      transition_in(route2.$$.fragment, local);
	      transition_in(softwarekey.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(appbar.$$.fragment, local);
	      transition_out(route0.$$.fragment, local);
	      transition_out(route1.$$.fragment, local);
	      transition_out(route2.$$.fragment, local);
	      transition_out(softwarekey.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) detach_dev(div);
	      if (detaching) detach_dev(t0);
	      /*appbar_binding*/

	      ctx[4](null);
	      destroy_component(appbar, detaching);
	      if (detaching) detach_dev(t1);
	      if (detaching) detach_dev(main);
	      destroy_component(route0);
	      destroy_component(route1);
	      destroy_component(route2);
	      if (detaching) detach_dev(t4);
	      /*softwarekey_binding*/

	      ctx[5](null);
	      destroy_component(softwarekey, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot.name,
	    type: "slot",
	    source: "(17:0) <Router>",
	    ctx
	  });
	  return block;
	}

	function create_fragment(ctx) {
	  var router;
	  var current;
	  router = new Router$1({
	    props: {
	      $$slots: {
	        default: [create_default_slot]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  var block = {
	    c: function create() {
	      create_component(router.$$.fragment);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      mount_component(router, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref7) {
	      var _ref8 = _slicedToArray(_ref7, 1),
	          dirty = _ref8[0];

	      var router_changes = {};

	      if (dirty &
	      /*$$scope, softwareKey, appBar*/
	      259) {
	        router_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }

	      router.$set(router_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(router.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(router.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(router, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}

	function instance($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
	      $$props.$$scope;
	  validate_slots('App', slots, []);
	  var _$$props$localization = $$props.localization,
	      localization = _$$props$localization === void 0 ? new Localization('en-US', 'langs') : _$$props$localization;
	  var appBar = $$props.appBar;
	  var softwareKey = $$props.softwareKey;

	  var getAppProp = () => {
	    return {
	      appBar,
	      softwareKey,
	      localization
	    };
	  };

	  onMount(() => {}); // console.log('onMount', 'App');

	  var writable_props = ['localization', 'appBar', 'softwareKey'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
	  });

	  function appbar_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      appBar = $$value;
	      $$invalidate(0, appBar);
	    });
	  }

	  function softwarekey_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      softwareKey = $$value;
	      $$invalidate(1, softwareKey);
	    });
	  }

	  $$self.$$set = $$props => {
	    if ('localization' in $$props) $$invalidate(3, localization = $$props.localization);
	    if ('appBar' in $$props) $$invalidate(0, appBar = $$props.appBar);
	    if ('softwareKey' in $$props) $$invalidate(1, softwareKey = $$props.softwareKey);
	  };

	  $$self.$capture_state = () => ({
	    Router: Router$1,
	    Route: Route$1,
	    AppBar,
	    SoftwareKey,
	    Home,
	    Room,
	    onMount,
	    Localization,
	    localization,
	    appBar,
	    softwareKey,
	    getAppProp
	  });

	  $$self.$inject_state = $$props => {
	    if ('localization' in $$props) $$invalidate(3, localization = $$props.localization);
	    if ('appBar' in $$props) $$invalidate(0, appBar = $$props.appBar);
	    if ('softwareKey' in $$props) $$invalidate(1, softwareKey = $$props.softwareKey);
	  };

	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }

	  return [appBar, softwareKey, getAppProp, localization, appbar_binding, softwarekey_binding];
	}

	class App extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance, create_fragment, safe_not_equal, {
	      localization: 3,
	      appBar: 0,
	      softwareKey: 1,
	      getAppProp: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "App",
	      options,
	      id: create_fragment.name
	    });
	    var ctx = this.$$.ctx;
	    var props = options.props || {};

	    if (
	    /*appBar*/
	    ctx[0] === undefined && !('appBar' in props)) {
	      console.warn("<App> was created without expected prop 'appBar'");
	    }

	    if (
	    /*softwareKey*/
	    ctx[1] === undefined && !('softwareKey' in props)) {
	      console.warn("<App> was created without expected prop 'softwareKey'");
	    }
	  }

	  get localization() {
	    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set localization(value) {
	    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get appBar() {
	    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set appBar(value) {
	    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get softwareKey() {
	    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  set softwareKey(value) {
	    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	  get getAppProp() {
	    return this.$$.ctx[2];
	  }

	  set getAppProp(value) {
	    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }

	}

	var app = new App({
	  target: document.body,
	  props: {}
	});

	return app;

})();
//# sourceMappingURL=bundle.js.map
